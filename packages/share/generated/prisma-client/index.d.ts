
/**
 * Client
**/

import * as runtime from './runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model Account
 * 
 */
export type Account = {
  id: string
  userId: string
  type: string
  provider: string
  providerAccountId: string
  refresh_token: string | null
  access_token: string | null
  expires_at: number | null
  token_type: string | null
  scope: string | null
  id_token: string | null
  session_state: string | null
}

/**
 * Model Session
 * 
 */
export type Session = {
  id: string
  sessionToken: string
  userId: string
  expires: Date
}

/**
 * Model User
 * 
 */
export type User = {
  id: string
  name: string | null
  email: string | null
  emailVerified: Date | null
  image: string | null
  introduction: string | null
  totalPoint: number
}

/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = {
  identifier: string
  token: string
  expires: Date
}

/**
 * Model RequestPost
 * 
 */
export type RequestPost = {
  id: bigint
  createdAt: Date
  updatedAt: Date
  userId: string | null
  title: string
  content: string
  category: RequestCategoryType | null
  creatorId: bigint | null
  expires: Date | null
  totalViews: number
  status: RequestStatusType
  solvedUrl: string | null
  thumbnailUrl: string | null
  refusalReason: string | null
  totalQuantity: number
  totalLikeScroe: number
  isUnspecified: boolean
}

/**
 * Model RequestFunding
 * 
 */
export type RequestFunding = {
  id: bigint
  userId: string | null
  quantity: number
  requestId: bigint | null
  createdAt: Date
  status: RequestFundingStatus
}

/**
 * Model RequestReaction
 * 
 */
export type RequestReaction = {
  id: bigint
  userId: string
  type: ReactionType
  requestId: bigint
  createdAt: Date
}

/**
 * Model RequestComment
 * 
 */
export type RequestComment = {
  id: bigint
  requestId: bigint
  userId: string | null
  parentId: bigint | null
  rootId: bigint | null
  content: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model RequestCommentHeart
 * 
 */
export type RequestCommentHeart = {
  id: bigint
  requestCommentId: bigint
  userId: string
  createdAt: Date
}

/**
 * Model RequestBookmark
 * 
 */
export type RequestBookmark = {
  id: bigint
  requestId: bigint | null
  userId: string
  createdAt: Date
}

/**
 * Model RequestPlatform
 * 
 */
export type RequestPlatform = {
  id: bigint
  requestId: bigint
  name: RequestPlatformType
}

/**
 * Model RequestApplyCreator
 * 
 */
export type RequestApplyCreator = {
  id: bigint
  requestId: bigint
  creatorId: bigint | null
}

/**
 * Model RequestReport
 * 
 */
export type RequestReport = {
  id: bigint
  requestId: bigint
  userId: string | null
  content: string
  type: RequestReportType
  status: RequestReportStatus
  createdAt: Date
}

/**
 * Model RequestInquiry
 * 
 */
export type RequestInquiry = {
  id: bigint
  requestId: bigint
  creatorId: bigint | null
  userId: string | null
  createdAt: Date
}

/**
 * Model RequestInquiryMessage
 * 
 */
export type RequestInquiryMessage = {
  id: bigint
  roomId: bigint
  fromId: string
  text: string
  fileUrl: string | null
  type: MessageType
  isRead: boolean | null
  createdAt: Date
}

/**
 * Model Point
 * 
 */
export type Point = {
  id: bigint
  userId: string
  quantity: number
  type: PoinType
  createdAt: Date
}

/**
 * Model Ranking
 * 
 */
export type Ranking = {
  id: number
  userId: string | null
  ranking: number
  type: RankingType
  score: bigint
  change: number
  createdAt: Date
}

/**
 * Model Faq
 * 
 */
export type Faq = {
  id: number
  type: FaqType
  title: string
  content: string
  createdAt: Date
}

/**
 * Model Notice
 * 
 */
export type Notice = {
  id: number
  title: string
  content: string
  createdAt: Date
}

/**
 * Model Creator
 * 
 */
export type Creator = {
  id: bigint
  userId: string
  createdAt: Date
}

/**
 * Model CreatorAuth
 * 
 */
export type CreatorAuth = {
  id: bigint
  creatorId: bigint
  isMain: boolean
  profileUrl: string | null
  platform: AuthPlatformType
  createdAt: Date
}

/**
 * Model CreatorReview
 * 
 */
export type CreatorReview = {
  id: bigint
  creatorId: bigint
  userId: string | null
  content: string | null
  createdAt: Date
}

/**
 * Model CreatorReviewItem
 * 
 */
export type CreatorReviewItem = {
  id: bigint
  reviewId: bigint
  content: string
  isChecked: boolean
}

/**
 * Model Log
 * 
 */
export type Log = {
  id: bigint
  logType: LogType
  message: string | null
  senderId: string | null
  isRead: boolean | null
  requestId: bigint | null
  createdAt: Date
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const AuthPlatformType: {
  YOUTUBE: 'YOUTUBE',
  INSTAGRAM: 'INSTAGRAM',
  FACEBOOK: 'FACEBOOK',
  TWITCH: 'TWITCH'
};

export type AuthPlatformType = (typeof AuthPlatformType)[keyof typeof AuthPlatformType]


export const FaqType: {
  BEST: 'BEST',
  GUIDE: 'GUIDE',
  ACCOUNT: 'ACCOUNT',
  CREATOR: 'CREATOR',
  BUSSINESS: 'BUSSINESS'
};

export type FaqType = (typeof FaqType)[keyof typeof FaqType]


export const LogType: {
  POINT_CHARGE: 'POINT_CHARGE',
  REQUEST_STATUS_CHANGE: 'REQUEST_STATUS_CHANGE',
  NEW_REQUEST: 'NEW_REQUEST',
  REQUEST_ACCEPT: 'REQUEST_ACCEPT',
  BRING_FUNDING: 'BRING_FUNDING'
};

export type LogType = (typeof LogType)[keyof typeof LogType]


export const MessageType: {
  TEXT: 'TEXT',
  IMAGE: 'IMAGE',
  VIDEO: 'VIDEO',
  FILE: 'FILE'
};

export type MessageType = (typeof MessageType)[keyof typeof MessageType]


export const PoinType: {
  WITHDRAW: 'WITHDRAW',
  DEPOSIT: 'DEPOSIT',
  FUNDING: 'FUNDING',
  RETURN: 'RETURN'
};

export type PoinType = (typeof PoinType)[keyof typeof PoinType]


export const RankingType: {
  FUN: 'FUN',
  COOL: 'COOL',
  SEXY: 'SEXY'
};

export type RankingType = (typeof RankingType)[keyof typeof RankingType]


export const ReactionType: {
  LIKE: 'LIKE',
  DISLIKE: 'DISLIKE'
};

export type ReactionType = (typeof ReactionType)[keyof typeof ReactionType]


export const RequestCategoryType: {
  GAME: 'GAME',
  LIFE_TALK: 'LIFE_TALK',
  COOK_EAT: 'COOK_EAT',
  TOUR_FOOD: 'TOUR_FOOD',
  DANCE_MUSIC: 'DANCE_MUSIC',
  ENTERTAINMENT: 'ENTERTAINMENT',
  EDUCATION: 'EDUCATION',
  FINANCE: 'FINANCE',
  SPORTS_HEALTH: 'SPORTS_HEALTH',
  BEAUTY_FASHION: 'BEAUTY_FASHION',
  HOBBY: 'HOBBY',
  ETC: 'ETC'
};

export type RequestCategoryType = (typeof RequestCategoryType)[keyof typeof RequestCategoryType]


export const RequestFundingStatus: {
  FUNDING: 'FUNDING',
  COMPLETION: 'COMPLETION',
  CANCELED: 'CANCELED',
  REFUND: 'REFUND'
};

export type RequestFundingStatus = (typeof RequestFundingStatus)[keyof typeof RequestFundingStatus]


export const RequestPlatformType: {
  YOUTUBE: 'YOUTUBE',
  INSTAGRAM: 'INSTAGRAM',
  FACEBOOK: 'FACEBOOK',
  TWITCH: 'TWITCH'
};

export type RequestPlatformType = (typeof RequestPlatformType)[keyof typeof RequestPlatformType]


export const RequestReportStatus: {
  PROCESSING: 'PROCESSING',
  COMPLETION: 'COMPLETION'
};

export type RequestReportStatus = (typeof RequestReportStatus)[keyof typeof RequestReportStatus]


export const RequestReportType: {
  SEXUAL: 'SEXUAL',
  SLANG: 'SLANG',
  SPAMMER: 'SPAMMER',
  TERRORISM: 'TERRORISM',
  PRIVACY: 'PRIVACY',
  COPYRIGHT: 'COPYRIGHT',
  SPAM: 'SPAM',
  RIOT: 'RIOT',
  ETC: 'ETC'
};

export type RequestReportType = (typeof RequestReportType)[keyof typeof RequestReportType]


export const RequestStatusType: {
  REQUEST: 'REQUEST',
  ACCEPT: 'ACCEPT',
  REGISTRATION: 'REGISTRATION',
  COMPLETION: 'COMPLETION',
  EXPIRATION: 'EXPIRATION',
  REFUSE: 'REFUSE'
};

export type RequestStatusType = (typeof RequestStatusType)[keyof typeof RequestStatusType]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Accounts
 * const accounts = await prisma.account.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Accounts
   * const accounts = await prisma.account.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>;

  $transaction<R>(fn: (prisma: Prisma.TransactionClient) => Promise<R>, options?: {maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel}): Promise<R>;

      /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<GlobalReject>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<GlobalReject>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<GlobalReject>;

  /**
   * `prisma.requestPost`: Exposes CRUD operations for the **RequestPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RequestPosts
    * const requestPosts = await prisma.requestPost.findMany()
    * ```
    */
  get requestPost(): Prisma.RequestPostDelegate<GlobalReject>;

  /**
   * `prisma.requestFunding`: Exposes CRUD operations for the **RequestFunding** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RequestFundings
    * const requestFundings = await prisma.requestFunding.findMany()
    * ```
    */
  get requestFunding(): Prisma.RequestFundingDelegate<GlobalReject>;

  /**
   * `prisma.requestReaction`: Exposes CRUD operations for the **RequestReaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RequestReactions
    * const requestReactions = await prisma.requestReaction.findMany()
    * ```
    */
  get requestReaction(): Prisma.RequestReactionDelegate<GlobalReject>;

  /**
   * `prisma.requestComment`: Exposes CRUD operations for the **RequestComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RequestComments
    * const requestComments = await prisma.requestComment.findMany()
    * ```
    */
  get requestComment(): Prisma.RequestCommentDelegate<GlobalReject>;

  /**
   * `prisma.requestCommentHeart`: Exposes CRUD operations for the **RequestCommentHeart** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RequestCommentHearts
    * const requestCommentHearts = await prisma.requestCommentHeart.findMany()
    * ```
    */
  get requestCommentHeart(): Prisma.RequestCommentHeartDelegate<GlobalReject>;

  /**
   * `prisma.requestBookmark`: Exposes CRUD operations for the **RequestBookmark** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RequestBookmarks
    * const requestBookmarks = await prisma.requestBookmark.findMany()
    * ```
    */
  get requestBookmark(): Prisma.RequestBookmarkDelegate<GlobalReject>;

  /**
   * `prisma.requestPlatform`: Exposes CRUD operations for the **RequestPlatform** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RequestPlatforms
    * const requestPlatforms = await prisma.requestPlatform.findMany()
    * ```
    */
  get requestPlatform(): Prisma.RequestPlatformDelegate<GlobalReject>;

  /**
   * `prisma.requestApplyCreator`: Exposes CRUD operations for the **RequestApplyCreator** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RequestApplyCreators
    * const requestApplyCreators = await prisma.requestApplyCreator.findMany()
    * ```
    */
  get requestApplyCreator(): Prisma.RequestApplyCreatorDelegate<GlobalReject>;

  /**
   * `prisma.requestReport`: Exposes CRUD operations for the **RequestReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RequestReports
    * const requestReports = await prisma.requestReport.findMany()
    * ```
    */
  get requestReport(): Prisma.RequestReportDelegate<GlobalReject>;

  /**
   * `prisma.requestInquiry`: Exposes CRUD operations for the **RequestInquiry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RequestInquiries
    * const requestInquiries = await prisma.requestInquiry.findMany()
    * ```
    */
  get requestInquiry(): Prisma.RequestInquiryDelegate<GlobalReject>;

  /**
   * `prisma.requestInquiryMessage`: Exposes CRUD operations for the **RequestInquiryMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RequestInquiryMessages
    * const requestInquiryMessages = await prisma.requestInquiryMessage.findMany()
    * ```
    */
  get requestInquiryMessage(): Prisma.RequestInquiryMessageDelegate<GlobalReject>;

  /**
   * `prisma.point`: Exposes CRUD operations for the **Point** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Points
    * const points = await prisma.point.findMany()
    * ```
    */
  get point(): Prisma.PointDelegate<GlobalReject>;

  /**
   * `prisma.ranking`: Exposes CRUD operations for the **Ranking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rankings
    * const rankings = await prisma.ranking.findMany()
    * ```
    */
  get ranking(): Prisma.RankingDelegate<GlobalReject>;

  /**
   * `prisma.faq`: Exposes CRUD operations for the **Faq** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Faqs
    * const faqs = await prisma.faq.findMany()
    * ```
    */
  get faq(): Prisma.FaqDelegate<GlobalReject>;

  /**
   * `prisma.notice`: Exposes CRUD operations for the **Notice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notices
    * const notices = await prisma.notice.findMany()
    * ```
    */
  get notice(): Prisma.NoticeDelegate<GlobalReject>;

  /**
   * `prisma.creator`: Exposes CRUD operations for the **Creator** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Creators
    * const creators = await prisma.creator.findMany()
    * ```
    */
  get creator(): Prisma.CreatorDelegate<GlobalReject>;

  /**
   * `prisma.creatorAuth`: Exposes CRUD operations for the **CreatorAuth** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CreatorAuths
    * const creatorAuths = await prisma.creatorAuth.findMany()
    * ```
    */
  get creatorAuth(): Prisma.CreatorAuthDelegate<GlobalReject>;

  /**
   * `prisma.creatorReview`: Exposes CRUD operations for the **CreatorReview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CreatorReviews
    * const creatorReviews = await prisma.creatorReview.findMany()
    * ```
    */
  get creatorReview(): Prisma.CreatorReviewDelegate<GlobalReject>;

  /**
   * `prisma.creatorReviewItem`: Exposes CRUD operations for the **CreatorReviewItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CreatorReviewItems
    * const creatorReviewItems = await prisma.creatorReviewItem.findMany()
    * ```
    */
  get creatorReviewItem(): Prisma.CreatorReviewItemDelegate<GlobalReject>;

  /**
   * `prisma.log`: Exposes CRUD operations for the **Log** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Logs
    * const logs = await prisma.log.findMany()
    * ```
    */
  get log(): Prisma.LogDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export import Metrics = runtime.Metrics
  export import Metric = runtime.Metric
  export import MetricHistogram = runtime.MetricHistogram
  export import MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
   * Extensions
   */
  export type Extension = runtime.Extension 

  /**
   * Prisma Client JS version: 4.5.0
   * Query Engine version: 0362da9eebca54d94c8ef5edd3b2e90af99ba452
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export import FieldRef = runtime.FieldRef

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    Account: 'Account',
    Session: 'Session',
    User: 'User',
    VerificationToken: 'VerificationToken',
    RequestPost: 'RequestPost',
    RequestFunding: 'RequestFunding',
    RequestReaction: 'RequestReaction',
    RequestComment: 'RequestComment',
    RequestCommentHeart: 'RequestCommentHeart',
    RequestBookmark: 'RequestBookmark',
    RequestPlatform: 'RequestPlatform',
    RequestApplyCreator: 'RequestApplyCreator',
    RequestReport: 'RequestReport',
    RequestInquiry: 'RequestInquiry',
    RequestInquiryMessage: 'RequestInquiryMessage',
    Point: 'Point',
    Ranking: 'Ranking',
    Faq: 'Faq',
    Notice: 'Notice',
    Creator: 'Creator',
    CreatorAuth: 'CreatorAuth',
    CreatorReview: 'CreatorReview',
    CreatorReviewItem: 'CreatorReviewItem',
    Log: 'Log'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;


  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<PrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    accounts: number
    sessions: number
    requestPosts: number
    requestFundings: number
    requestComments: number
    requestReactions: number
    requestBookmarks: number
    requestReports: number
    requestInquiries: number
    requestinquiryMessages: number
    requestCommentHearts: number
    logs: number
    points: number
    rankings: number
    creatorReviews: number
    Log: number
  }

  export type UserCountOutputTypeSelect = {
    accounts?: boolean
    sessions?: boolean
    requestPosts?: boolean
    requestFundings?: boolean
    requestComments?: boolean
    requestReactions?: boolean
    requestBookmarks?: boolean
    requestReports?: boolean
    requestInquiries?: boolean
    requestinquiryMessages?: boolean
    requestCommentHearts?: boolean
    logs?: boolean
    points?: boolean
    rankings?: boolean
    creatorReviews?: boolean
    Log?: boolean
  }

  export type UserCountOutputTypeGetPayload<
    S extends boolean | null | undefined | UserCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? UserCountOutputType
    : S extends undefined
    ? never
    : S extends UserCountOutputTypeArgs
    ?'include' extends U
    ? UserCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof UserCountOutputType ? UserCountOutputType[P] : never
  } 
    : UserCountOutputType
  : UserCountOutputType




  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     * 
    **/
    select?: UserCountOutputTypeSelect | null
  }



  /**
   * Count Type RequestPostCountOutputType
   */


  export type RequestPostCountOutputType = {
    requestFundings: number
    requestReactions: number
    requestApplyCreators: number
    requestPlatforms: number
    requestComments: number
    requestBookmarks: number
    requestReports: number
    requestInquirys: number
    Log: number
  }

  export type RequestPostCountOutputTypeSelect = {
    requestFundings?: boolean
    requestReactions?: boolean
    requestApplyCreators?: boolean
    requestPlatforms?: boolean
    requestComments?: boolean
    requestBookmarks?: boolean
    requestReports?: boolean
    requestInquirys?: boolean
    Log?: boolean
  }

  export type RequestPostCountOutputTypeGetPayload<
    S extends boolean | null | undefined | RequestPostCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? RequestPostCountOutputType
    : S extends undefined
    ? never
    : S extends RequestPostCountOutputTypeArgs
    ?'include' extends U
    ? RequestPostCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof RequestPostCountOutputType ? RequestPostCountOutputType[P] : never
  } 
    : RequestPostCountOutputType
  : RequestPostCountOutputType




  // Custom InputTypes

  /**
   * RequestPostCountOutputType without action
   */
  export type RequestPostCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the RequestPostCountOutputType
     * 
    **/
    select?: RequestPostCountOutputTypeSelect | null
  }



  /**
   * Count Type RequestCommentCountOutputType
   */


  export type RequestCommentCountOutputType = {
    hearts: number
    childrenComments: number
  }

  export type RequestCommentCountOutputTypeSelect = {
    hearts?: boolean
    childrenComments?: boolean
  }

  export type RequestCommentCountOutputTypeGetPayload<
    S extends boolean | null | undefined | RequestCommentCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? RequestCommentCountOutputType
    : S extends undefined
    ? never
    : S extends RequestCommentCountOutputTypeArgs
    ?'include' extends U
    ? RequestCommentCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof RequestCommentCountOutputType ? RequestCommentCountOutputType[P] : never
  } 
    : RequestCommentCountOutputType
  : RequestCommentCountOutputType




  // Custom InputTypes

  /**
   * RequestCommentCountOutputType without action
   */
  export type RequestCommentCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the RequestCommentCountOutputType
     * 
    **/
    select?: RequestCommentCountOutputTypeSelect | null
  }



  /**
   * Count Type RequestInquiryCountOutputType
   */


  export type RequestInquiryCountOutputType = {
    requestInquiryMessages: number
  }

  export type RequestInquiryCountOutputTypeSelect = {
    requestInquiryMessages?: boolean
  }

  export type RequestInquiryCountOutputTypeGetPayload<
    S extends boolean | null | undefined | RequestInquiryCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? RequestInquiryCountOutputType
    : S extends undefined
    ? never
    : S extends RequestInquiryCountOutputTypeArgs
    ?'include' extends U
    ? RequestInquiryCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof RequestInquiryCountOutputType ? RequestInquiryCountOutputType[P] : never
  } 
    : RequestInquiryCountOutputType
  : RequestInquiryCountOutputType




  // Custom InputTypes

  /**
   * RequestInquiryCountOutputType without action
   */
  export type RequestInquiryCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the RequestInquiryCountOutputType
     * 
    **/
    select?: RequestInquiryCountOutputTypeSelect | null
  }



  /**
   * Count Type CreatorCountOutputType
   */


  export type CreatorCountOutputType = {
    requestPosts: number
    requestApplyCreators: number
    requestInquiries: number
    creatorAuths: number
    creatorReviews: number
  }

  export type CreatorCountOutputTypeSelect = {
    requestPosts?: boolean
    requestApplyCreators?: boolean
    requestInquiries?: boolean
    creatorAuths?: boolean
    creatorReviews?: boolean
  }

  export type CreatorCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CreatorCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CreatorCountOutputType
    : S extends undefined
    ? never
    : S extends CreatorCountOutputTypeArgs
    ?'include' extends U
    ? CreatorCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof CreatorCountOutputType ? CreatorCountOutputType[P] : never
  } 
    : CreatorCountOutputType
  : CreatorCountOutputType




  // Custom InputTypes

  /**
   * CreatorCountOutputType without action
   */
  export type CreatorCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CreatorCountOutputType
     * 
    **/
    select?: CreatorCountOutputTypeSelect | null
  }



  /**
   * Count Type CreatorReviewCountOutputType
   */


  export type CreatorReviewCountOutputType = {
    reviewItems: number
  }

  export type CreatorReviewCountOutputTypeSelect = {
    reviewItems?: boolean
  }

  export type CreatorReviewCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CreatorReviewCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CreatorReviewCountOutputType
    : S extends undefined
    ? never
    : S extends CreatorReviewCountOutputTypeArgs
    ?'include' extends U
    ? CreatorReviewCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof CreatorReviewCountOutputType ? CreatorReviewCountOutputType[P] : never
  } 
    : CreatorReviewCountOutputType
  : CreatorReviewCountOutputType




  // Custom InputTypes

  /**
   * CreatorReviewCountOutputType without action
   */
  export type CreatorReviewCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CreatorReviewCountOutputType
     * 
    **/
    select?: CreatorReviewCountOutputTypeSelect | null
  }



  /**
   * Count Type LogCountOutputType
   */


  export type LogCountOutputType = {
    receiver: number
  }

  export type LogCountOutputTypeSelect = {
    receiver?: boolean
  }

  export type LogCountOutputTypeGetPayload<
    S extends boolean | null | undefined | LogCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? LogCountOutputType
    : S extends undefined
    ? never
    : S extends LogCountOutputTypeArgs
    ?'include' extends U
    ? LogCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof LogCountOutputType ? LogCountOutputType[P] : never
  } 
    : LogCountOutputType
  : LogCountOutputType




  // Custom InputTypes

  /**
   * LogCountOutputType without action
   */
  export type LogCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the LogCountOutputType
     * 
    **/
    select?: LogCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model Account
   */


  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    _all?: true
  }

  export type AccountAggregateArgs = {
    /**
     * Filter which Account to aggregate.
     * 
    **/
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     * 
    **/
    orderBy?: Enumerable<AccountOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs = {
    where?: AccountWhereInput
    orderBy?: Enumerable<AccountOrderByWithAggregationInput>
    by: Array<AccountScalarFieldEnum>
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }


  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = PrismaPromise<
    Array<
      PickArray<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserArgs
  }

  export type AccountInclude = {
    user?: boolean | UserArgs
  }

  export type AccountGetPayload<
    S extends boolean | null | undefined | AccountArgs,
    U = keyof S
      > = S extends true
        ? Account
    : S extends undefined
    ? never
    : S extends AccountArgs | AccountFindManyArgs
    ?'include' extends U
    ? Account  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Account ? Account[P] : never
  } 
    : Account
  : Account


  type AccountCountArgs = Merge<
    Omit<AccountFindManyArgs, 'select' | 'include'> & {
      select?: AccountCountAggregateInputType | true
    }
  >

  export interface AccountDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AccountFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AccountFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Account'> extends True ? CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>> : CheckSelect<T, Prisma__AccountClient<Account | null, null>, Prisma__AccountClient<AccountGetPayload<T> | null, null>>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AccountFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AccountFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Account'> extends True ? CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>> : CheckSelect<T, Prisma__AccountClient<Account | null, null>, Prisma__AccountClient<AccountGetPayload<T> | null, null>>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AccountFindManyArgs>(
      args?: SelectSubset<T, AccountFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Account>>, PrismaPromise<Array<AccountGetPayload<T>>>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
    **/
    create<T extends AccountCreateArgs>(
      args: SelectSubset<T, AccountCreateArgs>
    ): CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>>

    /**
     * Create many Accounts.
     *     @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     *     @example
     *     // Create many Accounts
     *     const account = await prisma.account.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AccountCreateManyArgs>(
      args?: SelectSubset<T, AccountCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
    **/
    delete<T extends AccountDeleteArgs>(
      args: SelectSubset<T, AccountDeleteArgs>
    ): CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AccountUpdateArgs>(
      args: SelectSubset<T, AccountUpdateArgs>
    ): CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AccountDeleteManyArgs>(
      args?: SelectSubset<T, AccountDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AccountUpdateManyArgs>(
      args: SelectSubset<T, AccountUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
    **/
    upsert<T extends AccountUpsertArgs>(
      args: SelectSubset<T, AccountUpsertArgs>
    ): CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>>

    /**
     * Find one Account that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, AccountFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>>

    /**
     * Find the first Account that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AccountFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>>

    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AccountClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | Null>, Prisma__UserClient<UserGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Account base type for findUnique actions
   */
  export type AccountFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
    /**
     * Filter, which Account to fetch.
     * 
    **/
    where: AccountWhereUniqueInput
  }

  /**
   * Account: findUnique
   */
  export interface AccountFindUniqueArgs extends AccountFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Account base type for findFirst actions
   */
  export type AccountFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
    /**
     * Filter, which Account to fetch.
     * 
    **/
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     * 
    **/
    orderBy?: Enumerable<AccountOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     * 
    **/
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     * 
    **/
    distinct?: Enumerable<AccountScalarFieldEnum>
  }

  /**
   * Account: findFirst
   */
  export interface AccountFindFirstArgs extends AccountFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Account findMany
   */
  export type AccountFindManyArgs = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
    /**
     * Filter, which Accounts to fetch.
     * 
    **/
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     * 
    **/
    orderBy?: Enumerable<AccountOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     * 
    **/
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AccountScalarFieldEnum>
  }


  /**
   * Account create
   */
  export type AccountCreateArgs = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
    /**
     * The data needed to create a Account.
     * 
    **/
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }


  /**
   * Account createMany
   */
  export type AccountCreateManyArgs = {
    /**
     * The data used to create many Accounts.
     * 
    **/
    data: Enumerable<AccountCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Account update
   */
  export type AccountUpdateArgs = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
    /**
     * The data needed to update a Account.
     * 
    **/
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     * 
    **/
    where: AccountWhereUniqueInput
  }


  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs = {
    /**
     * The data used to update Accounts.
     * 
    **/
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     * 
    **/
    where?: AccountWhereInput
  }


  /**
   * Account upsert
   */
  export type AccountUpsertArgs = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
    /**
     * The filter to search for the Account to update in case it exists.
     * 
    **/
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     * 
    **/
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }


  /**
   * Account delete
   */
  export type AccountDeleteArgs = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
    /**
     * Filter which Account to delete.
     * 
    **/
    where: AccountWhereUniqueInput
  }


  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs = {
    /**
     * Filter which Accounts to delete
     * 
    **/
    where?: AccountWhereInput
  }


  /**
   * Account: findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs = AccountFindUniqueArgsBase
      

  /**
   * Account: findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs = AccountFindFirstArgsBase
      

  /**
   * Account without action
   */
  export type AccountArgs = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
  }



  /**
   * Model Session
   */


  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    _all?: true
  }

  export type SessionAggregateArgs = {
    /**
     * Filter which Session to aggregate.
     * 
    **/
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     * 
    **/
    orderBy?: Enumerable<SessionOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs = {
    where?: SessionWhereInput
    orderBy?: Enumerable<SessionOrderByWithAggregationInput>
    by: Array<SessionScalarFieldEnum>
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }


  export type SessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expires: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserArgs
  }

  export type SessionInclude = {
    user?: boolean | UserArgs
  }

  export type SessionGetPayload<
    S extends boolean | null | undefined | SessionArgs,
    U = keyof S
      > = S extends true
        ? Session
    : S extends undefined
    ? never
    : S extends SessionArgs | SessionFindManyArgs
    ?'include' extends U
    ? Session  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Session ? Session[P] : never
  } 
    : Session
  : Session


  type SessionCountArgs = Merge<
    Omit<SessionFindManyArgs, 'select' | 'include'> & {
      select?: SessionCountAggregateInputType | true
    }
  >

  export interface SessionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SessionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SessionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Session'> extends True ? CheckSelect<T, Prisma__SessionClient<Session>, Prisma__SessionClient<SessionGetPayload<T>>> : CheckSelect<T, Prisma__SessionClient<Session | null, null>, Prisma__SessionClient<SessionGetPayload<T> | null, null>>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SessionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SessionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Session'> extends True ? CheckSelect<T, Prisma__SessionClient<Session>, Prisma__SessionClient<SessionGetPayload<T>>> : CheckSelect<T, Prisma__SessionClient<Session | null, null>, Prisma__SessionClient<SessionGetPayload<T> | null, null>>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SessionFindManyArgs>(
      args?: SelectSubset<T, SessionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Session>>, PrismaPromise<Array<SessionGetPayload<T>>>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
    **/
    create<T extends SessionCreateArgs>(
      args: SelectSubset<T, SessionCreateArgs>
    ): CheckSelect<T, Prisma__SessionClient<Session>, Prisma__SessionClient<SessionGetPayload<T>>>

    /**
     * Create many Sessions.
     *     @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     *     @example
     *     // Create many Sessions
     *     const session = await prisma.session.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SessionCreateManyArgs>(
      args?: SelectSubset<T, SessionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
    **/
    delete<T extends SessionDeleteArgs>(
      args: SelectSubset<T, SessionDeleteArgs>
    ): CheckSelect<T, Prisma__SessionClient<Session>, Prisma__SessionClient<SessionGetPayload<T>>>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SessionUpdateArgs>(
      args: SelectSubset<T, SessionUpdateArgs>
    ): CheckSelect<T, Prisma__SessionClient<Session>, Prisma__SessionClient<SessionGetPayload<T>>>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SessionDeleteManyArgs>(
      args?: SelectSubset<T, SessionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SessionUpdateManyArgs>(
      args: SelectSubset<T, SessionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
    **/
    upsert<T extends SessionUpsertArgs>(
      args: SelectSubset<T, SessionUpsertArgs>
    ): CheckSelect<T, Prisma__SessionClient<Session>, Prisma__SessionClient<SessionGetPayload<T>>>

    /**
     * Find one Session that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SessionFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__SessionClient<Session>, Prisma__SessionClient<SessionGetPayload<T>>>

    /**
     * Find the first Session that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SessionFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__SessionClient<Session>, Prisma__SessionClient<SessionGetPayload<T>>>

    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SessionClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | Null>, Prisma__UserClient<UserGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Session base type for findUnique actions
   */
  export type SessionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SessionInclude | null
    /**
     * Filter, which Session to fetch.
     * 
    **/
    where: SessionWhereUniqueInput
  }

  /**
   * Session: findUnique
   */
  export interface SessionFindUniqueArgs extends SessionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Session base type for findFirst actions
   */
  export type SessionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SessionInclude | null
    /**
     * Filter, which Session to fetch.
     * 
    **/
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     * 
    **/
    orderBy?: Enumerable<SessionOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     * 
    **/
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     * 
    **/
    distinct?: Enumerable<SessionScalarFieldEnum>
  }

  /**
   * Session: findFirst
   */
  export interface SessionFindFirstArgs extends SessionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Session findMany
   */
  export type SessionFindManyArgs = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SessionInclude | null
    /**
     * Filter, which Sessions to fetch.
     * 
    **/
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     * 
    **/
    orderBy?: Enumerable<SessionOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     * 
    **/
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SessionScalarFieldEnum>
  }


  /**
   * Session create
   */
  export type SessionCreateArgs = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SessionInclude | null
    /**
     * The data needed to create a Session.
     * 
    **/
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }


  /**
   * Session createMany
   */
  export type SessionCreateManyArgs = {
    /**
     * The data used to create many Sessions.
     * 
    **/
    data: Enumerable<SessionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Session update
   */
  export type SessionUpdateArgs = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SessionInclude | null
    /**
     * The data needed to update a Session.
     * 
    **/
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     * 
    **/
    where: SessionWhereUniqueInput
  }


  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs = {
    /**
     * The data used to update Sessions.
     * 
    **/
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     * 
    **/
    where?: SessionWhereInput
  }


  /**
   * Session upsert
   */
  export type SessionUpsertArgs = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SessionInclude | null
    /**
     * The filter to search for the Session to update in case it exists.
     * 
    **/
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     * 
    **/
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }


  /**
   * Session delete
   */
  export type SessionDeleteArgs = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SessionInclude | null
    /**
     * Filter which Session to delete.
     * 
    **/
    where: SessionWhereUniqueInput
  }


  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs = {
    /**
     * Filter which Sessions to delete
     * 
    **/
    where?: SessionWhereInput
  }


  /**
   * Session: findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs = SessionFindUniqueArgsBase
      

  /**
   * Session: findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs = SessionFindFirstArgsBase
      

  /**
   * Session without action
   */
  export type SessionArgs = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SessionInclude | null
  }



  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    totalPoint: number | null
  }

  export type UserSumAggregateOutputType = {
    totalPoint: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    introduction: string | null
    totalPoint: number | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    introduction: string | null
    totalPoint: number | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    emailVerified: number
    image: number
    introduction: number
    totalPoint: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    totalPoint?: true
  }

  export type UserSumAggregateInputType = {
    totalPoint?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    introduction?: true
    totalPoint?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    introduction?: true
    totalPoint?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    introduction?: true
    totalPoint?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: Array<UserScalarFieldEnum>
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: string
    name: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    introduction: string | null
    totalPoint: number
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect = {
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    introduction?: boolean
    totalPoint?: boolean
    accounts?: boolean | AccountFindManyArgs
    sessions?: boolean | SessionFindManyArgs
    requestPosts?: boolean | RequestPostFindManyArgs
    requestFundings?: boolean | RequestFundingFindManyArgs
    requestComments?: boolean | RequestCommentFindManyArgs
    requestReactions?: boolean | RequestReactionFindManyArgs
    requestBookmarks?: boolean | RequestBookmarkFindManyArgs
    requestReports?: boolean | RequestReportFindManyArgs
    requestInquiries?: boolean | RequestInquiryFindManyArgs
    requestinquiryMessages?: boolean | RequestInquiryMessageFindManyArgs
    requestCommentHearts?: boolean | RequestCommentHeartFindManyArgs
    logs?: boolean | LogFindManyArgs
    points?: boolean | PointFindManyArgs
    rankings?: boolean | RankingFindManyArgs
    creatorReviews?: boolean | CreatorReviewFindManyArgs
    creator?: boolean | CreatorArgs
    Log?: boolean | LogFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserInclude = {
    accounts?: boolean | AccountFindManyArgs
    sessions?: boolean | SessionFindManyArgs
    requestPosts?: boolean | RequestPostFindManyArgs
    requestFundings?: boolean | RequestFundingFindManyArgs
    requestComments?: boolean | RequestCommentFindManyArgs
    requestReactions?: boolean | RequestReactionFindManyArgs
    requestBookmarks?: boolean | RequestBookmarkFindManyArgs
    requestReports?: boolean | RequestReportFindManyArgs
    requestInquiries?: boolean | RequestInquiryFindManyArgs
    requestinquiryMessages?: boolean | RequestInquiryMessageFindManyArgs
    requestCommentHearts?: boolean | RequestCommentHeartFindManyArgs
    logs?: boolean | LogFindManyArgs
    points?: boolean | PointFindManyArgs
    rankings?: boolean | RankingFindManyArgs
    creatorReviews?: boolean | CreatorReviewFindManyArgs
    creator?: boolean | CreatorArgs
    Log?: boolean | LogFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserGetPayload<
    S extends boolean | null | undefined | UserArgs,
    U = keyof S
      > = S extends true
        ? User
    : S extends undefined
    ? never
    : S extends UserArgs | UserFindManyArgs
    ?'include' extends U
    ? User  & {
    [P in TrueKeys<S['include']>]:
        P extends 'accounts' ? Array < AccountGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'sessions' ? Array < SessionGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'requestPosts' ? Array < RequestPostGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'requestFundings' ? Array < RequestFundingGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'requestComments' ? Array < RequestCommentGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'requestReactions' ? Array < RequestReactionGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'requestBookmarks' ? Array < RequestBookmarkGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'requestReports' ? Array < RequestReportGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'requestInquiries' ? Array < RequestInquiryGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'requestinquiryMessages' ? Array < RequestInquiryMessageGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'requestCommentHearts' ? Array < RequestCommentHeartGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'logs' ? Array < LogGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'points' ? Array < PointGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'rankings' ? Array < RankingGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'creatorReviews' ? Array < CreatorReviewGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'creator' ? CreatorGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'Log' ? Array < LogGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'accounts' ? Array < AccountGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'sessions' ? Array < SessionGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'requestPosts' ? Array < RequestPostGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'requestFundings' ? Array < RequestFundingGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'requestComments' ? Array < RequestCommentGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'requestReactions' ? Array < RequestReactionGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'requestBookmarks' ? Array < RequestBookmarkGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'requestReports' ? Array < RequestReportGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'requestInquiries' ? Array < RequestInquiryGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'requestinquiryMessages' ? Array < RequestInquiryMessageGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'requestCommentHearts' ? Array < RequestCommentHeartGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'logs' ? Array < LogGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'points' ? Array < PointGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'rankings' ? Array < RankingGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'creatorReviews' ? Array < CreatorReviewGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'creator' ? CreatorGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'Log' ? Array < LogGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof User ? User[P] : never
  } 
    : User
  : User


  type UserCountArgs = Merge<
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }
  >

  export interface UserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null, null>, Prisma__UserClient<UserGetPayload<T> | null, null>>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null, null>, Prisma__UserClient<UserGetPayload<T> | null, null>>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Find one User that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    accounts<T extends AccountFindManyArgs = {}>(args?: Subset<T, AccountFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Account>| Null>, PrismaPromise<Array<AccountGetPayload<T>>| Null>>;

    sessions<T extends SessionFindManyArgs = {}>(args?: Subset<T, SessionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Session>| Null>, PrismaPromise<Array<SessionGetPayload<T>>| Null>>;

    requestPosts<T extends RequestPostFindManyArgs = {}>(args?: Subset<T, RequestPostFindManyArgs>): CheckSelect<T, PrismaPromise<Array<RequestPost>| Null>, PrismaPromise<Array<RequestPostGetPayload<T>>| Null>>;

    requestFundings<T extends RequestFundingFindManyArgs = {}>(args?: Subset<T, RequestFundingFindManyArgs>): CheckSelect<T, PrismaPromise<Array<RequestFunding>| Null>, PrismaPromise<Array<RequestFundingGetPayload<T>>| Null>>;

    requestComments<T extends RequestCommentFindManyArgs = {}>(args?: Subset<T, RequestCommentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<RequestComment>| Null>, PrismaPromise<Array<RequestCommentGetPayload<T>>| Null>>;

    requestReactions<T extends RequestReactionFindManyArgs = {}>(args?: Subset<T, RequestReactionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<RequestReaction>| Null>, PrismaPromise<Array<RequestReactionGetPayload<T>>| Null>>;

    requestBookmarks<T extends RequestBookmarkFindManyArgs = {}>(args?: Subset<T, RequestBookmarkFindManyArgs>): CheckSelect<T, PrismaPromise<Array<RequestBookmark>| Null>, PrismaPromise<Array<RequestBookmarkGetPayload<T>>| Null>>;

    requestReports<T extends RequestReportFindManyArgs = {}>(args?: Subset<T, RequestReportFindManyArgs>): CheckSelect<T, PrismaPromise<Array<RequestReport>| Null>, PrismaPromise<Array<RequestReportGetPayload<T>>| Null>>;

    requestInquiries<T extends RequestInquiryFindManyArgs = {}>(args?: Subset<T, RequestInquiryFindManyArgs>): CheckSelect<T, PrismaPromise<Array<RequestInquiry>| Null>, PrismaPromise<Array<RequestInquiryGetPayload<T>>| Null>>;

    requestinquiryMessages<T extends RequestInquiryMessageFindManyArgs = {}>(args?: Subset<T, RequestInquiryMessageFindManyArgs>): CheckSelect<T, PrismaPromise<Array<RequestInquiryMessage>| Null>, PrismaPromise<Array<RequestInquiryMessageGetPayload<T>>| Null>>;

    requestCommentHearts<T extends RequestCommentHeartFindManyArgs = {}>(args?: Subset<T, RequestCommentHeartFindManyArgs>): CheckSelect<T, PrismaPromise<Array<RequestCommentHeart>| Null>, PrismaPromise<Array<RequestCommentHeartGetPayload<T>>| Null>>;

    logs<T extends LogFindManyArgs = {}>(args?: Subset<T, LogFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Log>| Null>, PrismaPromise<Array<LogGetPayload<T>>| Null>>;

    points<T extends PointFindManyArgs = {}>(args?: Subset<T, PointFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Point>| Null>, PrismaPromise<Array<PointGetPayload<T>>| Null>>;

    rankings<T extends RankingFindManyArgs = {}>(args?: Subset<T, RankingFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Ranking>| Null>, PrismaPromise<Array<RankingGetPayload<T>>| Null>>;

    creatorReviews<T extends CreatorReviewFindManyArgs = {}>(args?: Subset<T, CreatorReviewFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CreatorReview>| Null>, PrismaPromise<Array<CreatorReviewGetPayload<T>>| Null>>;

    creator<T extends CreatorArgs = {}>(args?: Subset<T, CreatorArgs>): CheckSelect<T, Prisma__CreatorClient<Creator | Null>, Prisma__CreatorClient<CreatorGetPayload<T> | Null>>;

    Log<T extends LogFindManyArgs = {}>(args?: Subset<T, LogFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Log>| Null>, PrismaPromise<Array<LogGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * User base type for findUnique actions
   */
  export type UserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     * 
    **/
    where: UserWhereUniqueInput
  }

  /**
   * User: findUnique
   */
  export interface UserFindUniqueArgs extends UserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User base type for findFirst actions
   */
  export type UserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     * 
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * User: findFirst
   */
  export interface UserFindFirstArgs extends UserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     * 
    **/
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    /**
     * The data used to create many Users.
     * 
    **/
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     * 
    **/
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    /**
     * The data used to update Users.
     * 
    **/
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     * 
    **/
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     * 
    **/
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    /**
     * Filter which Users to delete
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User: findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs = UserFindUniqueArgsBase
      

  /**
   * User: findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs = UserFindFirstArgsBase
      

  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
  }



  /**
   * Model VerificationToken
   */


  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number
    token: number
    expires: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs = {
    /**
     * Filter which VerificationToken to aggregate.
     * 
    **/
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     * 
    **/
    orderBy?: Enumerable<VerificationTokenOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs = {
    where?: VerificationTokenWhereInput
    orderBy?: Enumerable<VerificationTokenOrderByWithAggregationInput>
    by: Array<VerificationTokenScalarFieldEnum>
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }


  export type VerificationTokenGroupByOutputType = {
    identifier: string
    token: string
    expires: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = PrismaPromise<
    Array<
      PickArray<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect = {
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }

  export type VerificationTokenGetPayload<
    S extends boolean | null | undefined | VerificationTokenArgs,
    U = keyof S
      > = S extends true
        ? VerificationToken
    : S extends undefined
    ? never
    : S extends VerificationTokenArgs | VerificationTokenFindManyArgs
    ?'include' extends U
    ? VerificationToken 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof VerificationToken ? VerificationToken[P] : never
  } 
    : VerificationToken
  : VerificationToken


  type VerificationTokenCountArgs = Merge<
    Omit<VerificationTokenFindManyArgs, 'select' | 'include'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }
  >

  export interface VerificationTokenDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends VerificationTokenFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, VerificationTokenFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'VerificationToken'> extends True ? CheckSelect<T, Prisma__VerificationTokenClient<VerificationToken>, Prisma__VerificationTokenClient<VerificationTokenGetPayload<T>>> : CheckSelect<T, Prisma__VerificationTokenClient<VerificationToken | null, null>, Prisma__VerificationTokenClient<VerificationTokenGetPayload<T> | null, null>>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends VerificationTokenFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, VerificationTokenFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'VerificationToken'> extends True ? CheckSelect<T, Prisma__VerificationTokenClient<VerificationToken>, Prisma__VerificationTokenClient<VerificationTokenGetPayload<T>>> : CheckSelect<T, Prisma__VerificationTokenClient<VerificationToken | null, null>, Prisma__VerificationTokenClient<VerificationTokenGetPayload<T> | null, null>>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     * 
    **/
    findMany<T extends VerificationTokenFindManyArgs>(
      args?: SelectSubset<T, VerificationTokenFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<VerificationToken>>, PrismaPromise<Array<VerificationTokenGetPayload<T>>>>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
    **/
    create<T extends VerificationTokenCreateArgs>(
      args: SelectSubset<T, VerificationTokenCreateArgs>
    ): CheckSelect<T, Prisma__VerificationTokenClient<VerificationToken>, Prisma__VerificationTokenClient<VerificationTokenGetPayload<T>>>

    /**
     * Create many VerificationTokens.
     *     @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     *     @example
     *     // Create many VerificationTokens
     *     const verificationToken = await prisma.verificationToken.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends VerificationTokenCreateManyArgs>(
      args?: SelectSubset<T, VerificationTokenCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
    **/
    delete<T extends VerificationTokenDeleteArgs>(
      args: SelectSubset<T, VerificationTokenDeleteArgs>
    ): CheckSelect<T, Prisma__VerificationTokenClient<VerificationToken>, Prisma__VerificationTokenClient<VerificationTokenGetPayload<T>>>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VerificationTokenUpdateArgs>(
      args: SelectSubset<T, VerificationTokenUpdateArgs>
    ): CheckSelect<T, Prisma__VerificationTokenClient<VerificationToken>, Prisma__VerificationTokenClient<VerificationTokenGetPayload<T>>>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VerificationTokenDeleteManyArgs>(
      args?: SelectSubset<T, VerificationTokenDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VerificationTokenUpdateManyArgs>(
      args: SelectSubset<T, VerificationTokenUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
    **/
    upsert<T extends VerificationTokenUpsertArgs>(
      args: SelectSubset<T, VerificationTokenUpsertArgs>
    ): CheckSelect<T, Prisma__VerificationTokenClient<VerificationToken>, Prisma__VerificationTokenClient<VerificationTokenGetPayload<T>>>

    /**
     * Find one VerificationToken that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__VerificationTokenClient<VerificationToken>, Prisma__VerificationTokenClient<VerificationTokenGetPayload<T>>>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(
      args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__VerificationTokenClient<VerificationToken>, Prisma__VerificationTokenClient<VerificationTokenGetPayload<T>>>

    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__VerificationTokenClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * VerificationToken base type for findUnique actions
   */
  export type VerificationTokenFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the VerificationToken
     * 
    **/
    select?: VerificationTokenSelect | null
    /**
     * Filter, which VerificationToken to fetch.
     * 
    **/
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken: findUnique
   */
  export interface VerificationTokenFindUniqueArgs extends VerificationTokenFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * VerificationToken base type for findFirst actions
   */
  export type VerificationTokenFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the VerificationToken
     * 
    **/
    select?: VerificationTokenSelect | null
    /**
     * Filter, which VerificationToken to fetch.
     * 
    **/
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     * 
    **/
    orderBy?: Enumerable<VerificationTokenOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     * 
    **/
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     * 
    **/
    distinct?: Enumerable<VerificationTokenScalarFieldEnum>
  }

  /**
   * VerificationToken: findFirst
   */
  export interface VerificationTokenFindFirstArgs extends VerificationTokenFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs = {
    /**
     * Select specific fields to fetch from the VerificationToken
     * 
    **/
    select?: VerificationTokenSelect | null
    /**
     * Filter, which VerificationTokens to fetch.
     * 
    **/
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     * 
    **/
    orderBy?: Enumerable<VerificationTokenOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     * 
    **/
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     * 
    **/
    skip?: number
    distinct?: Enumerable<VerificationTokenScalarFieldEnum>
  }


  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs = {
    /**
     * Select specific fields to fetch from the VerificationToken
     * 
    **/
    select?: VerificationTokenSelect | null
    /**
     * The data needed to create a VerificationToken.
     * 
    **/
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }


  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs = {
    /**
     * The data used to create many VerificationTokens.
     * 
    **/
    data: Enumerable<VerificationTokenCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs = {
    /**
     * Select specific fields to fetch from the VerificationToken
     * 
    **/
    select?: VerificationTokenSelect | null
    /**
     * The data needed to update a VerificationToken.
     * 
    **/
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     * 
    **/
    where: VerificationTokenWhereUniqueInput
  }


  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs = {
    /**
     * The data used to update VerificationTokens.
     * 
    **/
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     * 
    **/
    where?: VerificationTokenWhereInput
  }


  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs = {
    /**
     * Select specific fields to fetch from the VerificationToken
     * 
    **/
    select?: VerificationTokenSelect | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     * 
    **/
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     * 
    **/
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }


  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs = {
    /**
     * Select specific fields to fetch from the VerificationToken
     * 
    **/
    select?: VerificationTokenSelect | null
    /**
     * Filter which VerificationToken to delete.
     * 
    **/
    where: VerificationTokenWhereUniqueInput
  }


  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs = {
    /**
     * Filter which VerificationTokens to delete
     * 
    **/
    where?: VerificationTokenWhereInput
  }


  /**
   * VerificationToken: findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs = VerificationTokenFindUniqueArgsBase
      

  /**
   * VerificationToken: findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs = VerificationTokenFindFirstArgsBase
      

  /**
   * VerificationToken without action
   */
  export type VerificationTokenArgs = {
    /**
     * Select specific fields to fetch from the VerificationToken
     * 
    **/
    select?: VerificationTokenSelect | null
  }



  /**
   * Model RequestPost
   */


  export type AggregateRequestPost = {
    _count: RequestPostCountAggregateOutputType | null
    _avg: RequestPostAvgAggregateOutputType | null
    _sum: RequestPostSumAggregateOutputType | null
    _min: RequestPostMinAggregateOutputType | null
    _max: RequestPostMaxAggregateOutputType | null
  }

  export type RequestPostAvgAggregateOutputType = {
    id: number | null
    creatorId: number | null
    totalViews: number | null
    totalQuantity: number | null
    totalLikeScroe: number | null
  }

  export type RequestPostSumAggregateOutputType = {
    id: bigint | null
    creatorId: bigint | null
    totalViews: number | null
    totalQuantity: number | null
    totalLikeScroe: number | null
  }

  export type RequestPostMinAggregateOutputType = {
    id: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    title: string | null
    content: string | null
    category: RequestCategoryType | null
    creatorId: bigint | null
    expires: Date | null
    totalViews: number | null
    status: RequestStatusType | null
    solvedUrl: string | null
    thumbnailUrl: string | null
    refusalReason: string | null
    totalQuantity: number | null
    totalLikeScroe: number | null
    isUnspecified: boolean | null
  }

  export type RequestPostMaxAggregateOutputType = {
    id: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    title: string | null
    content: string | null
    category: RequestCategoryType | null
    creatorId: bigint | null
    expires: Date | null
    totalViews: number | null
    status: RequestStatusType | null
    solvedUrl: string | null
    thumbnailUrl: string | null
    refusalReason: string | null
    totalQuantity: number | null
    totalLikeScroe: number | null
    isUnspecified: boolean | null
  }

  export type RequestPostCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    userId: number
    title: number
    content: number
    category: number
    creatorId: number
    expires: number
    totalViews: number
    status: number
    solvedUrl: number
    thumbnailUrl: number
    refusalReason: number
    totalQuantity: number
    totalLikeScroe: number
    isUnspecified: number
    _all: number
  }


  export type RequestPostAvgAggregateInputType = {
    id?: true
    creatorId?: true
    totalViews?: true
    totalQuantity?: true
    totalLikeScroe?: true
  }

  export type RequestPostSumAggregateInputType = {
    id?: true
    creatorId?: true
    totalViews?: true
    totalQuantity?: true
    totalLikeScroe?: true
  }

  export type RequestPostMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    title?: true
    content?: true
    category?: true
    creatorId?: true
    expires?: true
    totalViews?: true
    status?: true
    solvedUrl?: true
    thumbnailUrl?: true
    refusalReason?: true
    totalQuantity?: true
    totalLikeScroe?: true
    isUnspecified?: true
  }

  export type RequestPostMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    title?: true
    content?: true
    category?: true
    creatorId?: true
    expires?: true
    totalViews?: true
    status?: true
    solvedUrl?: true
    thumbnailUrl?: true
    refusalReason?: true
    totalQuantity?: true
    totalLikeScroe?: true
    isUnspecified?: true
  }

  export type RequestPostCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    title?: true
    content?: true
    category?: true
    creatorId?: true
    expires?: true
    totalViews?: true
    status?: true
    solvedUrl?: true
    thumbnailUrl?: true
    refusalReason?: true
    totalQuantity?: true
    totalLikeScroe?: true
    isUnspecified?: true
    _all?: true
  }

  export type RequestPostAggregateArgs = {
    /**
     * Filter which RequestPost to aggregate.
     * 
    **/
    where?: RequestPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestPosts to fetch.
     * 
    **/
    orderBy?: Enumerable<RequestPostOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: RequestPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestPosts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestPosts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RequestPosts
    **/
    _count?: true | RequestPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RequestPostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RequestPostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RequestPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RequestPostMaxAggregateInputType
  }

  export type GetRequestPostAggregateType<T extends RequestPostAggregateArgs> = {
        [P in keyof T & keyof AggregateRequestPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequestPost[P]>
      : GetScalarType<T[P], AggregateRequestPost[P]>
  }




  export type RequestPostGroupByArgs = {
    where?: RequestPostWhereInput
    orderBy?: Enumerable<RequestPostOrderByWithAggregationInput>
    by: Array<RequestPostScalarFieldEnum>
    having?: RequestPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RequestPostCountAggregateInputType | true
    _avg?: RequestPostAvgAggregateInputType
    _sum?: RequestPostSumAggregateInputType
    _min?: RequestPostMinAggregateInputType
    _max?: RequestPostMaxAggregateInputType
  }


  export type RequestPostGroupByOutputType = {
    id: bigint
    createdAt: Date
    updatedAt: Date
    userId: string | null
    title: string
    content: string
    category: RequestCategoryType | null
    creatorId: bigint | null
    expires: Date | null
    totalViews: number
    status: RequestStatusType
    solvedUrl: string | null
    thumbnailUrl: string | null
    refusalReason: string | null
    totalQuantity: number
    totalLikeScroe: number
    isUnspecified: boolean
    _count: RequestPostCountAggregateOutputType | null
    _avg: RequestPostAvgAggregateOutputType | null
    _sum: RequestPostSumAggregateOutputType | null
    _min: RequestPostMinAggregateOutputType | null
    _max: RequestPostMaxAggregateOutputType | null
  }

  type GetRequestPostGroupByPayload<T extends RequestPostGroupByArgs> = PrismaPromise<
    Array<
      PickArray<RequestPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RequestPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RequestPostGroupByOutputType[P]>
            : GetScalarType<T[P], RequestPostGroupByOutputType[P]>
        }
      >
    >


  export type RequestPostSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserArgs
    userId?: boolean
    title?: boolean
    content?: boolean
    creator?: boolean | CreatorArgs
    category?: boolean
    creatorId?: boolean
    expires?: boolean
    totalViews?: boolean
    status?: boolean
    solvedUrl?: boolean
    thumbnailUrl?: boolean
    refusalReason?: boolean
    totalQuantity?: boolean
    totalLikeScroe?: boolean
    isUnspecified?: boolean
    requestFundings?: boolean | RequestFundingFindManyArgs
    requestReactions?: boolean | RequestReactionFindManyArgs
    requestApplyCreators?: boolean | RequestApplyCreatorFindManyArgs
    requestPlatforms?: boolean | RequestPlatformFindManyArgs
    requestComments?: boolean | RequestCommentFindManyArgs
    requestBookmarks?: boolean | RequestBookmarkFindManyArgs
    requestReports?: boolean | RequestReportFindManyArgs
    requestInquirys?: boolean | RequestInquiryFindManyArgs
    Log?: boolean | LogFindManyArgs
    _count?: boolean | RequestPostCountOutputTypeArgs
  }

  export type RequestPostInclude = {
    user?: boolean | UserArgs
    creator?: boolean | CreatorArgs
    requestFundings?: boolean | RequestFundingFindManyArgs
    requestReactions?: boolean | RequestReactionFindManyArgs
    requestApplyCreators?: boolean | RequestApplyCreatorFindManyArgs
    requestPlatforms?: boolean | RequestPlatformFindManyArgs
    requestComments?: boolean | RequestCommentFindManyArgs
    requestBookmarks?: boolean | RequestBookmarkFindManyArgs
    requestReports?: boolean | RequestReportFindManyArgs
    requestInquirys?: boolean | RequestInquiryFindManyArgs
    Log?: boolean | LogFindManyArgs
    _count?: boolean | RequestPostCountOutputTypeArgs
  }

  export type RequestPostGetPayload<
    S extends boolean | null | undefined | RequestPostArgs,
    U = keyof S
      > = S extends true
        ? RequestPost
    : S extends undefined
    ? never
    : S extends RequestPostArgs | RequestPostFindManyArgs
    ?'include' extends U
    ? RequestPost  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'creator' ? CreatorGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'requestFundings' ? Array < RequestFundingGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'requestReactions' ? Array < RequestReactionGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'requestApplyCreators' ? Array < RequestApplyCreatorGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'requestPlatforms' ? Array < RequestPlatformGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'requestComments' ? Array < RequestCommentGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'requestBookmarks' ? Array < RequestBookmarkGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'requestReports' ? Array < RequestReportGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'requestInquirys' ? Array < RequestInquiryGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'Log' ? Array < LogGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? RequestPostCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'creator' ? CreatorGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'requestFundings' ? Array < RequestFundingGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'requestReactions' ? Array < RequestReactionGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'requestApplyCreators' ? Array < RequestApplyCreatorGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'requestPlatforms' ? Array < RequestPlatformGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'requestComments' ? Array < RequestCommentGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'requestBookmarks' ? Array < RequestBookmarkGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'requestReports' ? Array < RequestReportGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'requestInquirys' ? Array < RequestInquiryGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'Log' ? Array < LogGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? RequestPostCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof RequestPost ? RequestPost[P] : never
  } 
    : RequestPost
  : RequestPost


  type RequestPostCountArgs = Merge<
    Omit<RequestPostFindManyArgs, 'select' | 'include'> & {
      select?: RequestPostCountAggregateInputType | true
    }
  >

  export interface RequestPostDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one RequestPost that matches the filter.
     * @param {RequestPostFindUniqueArgs} args - Arguments to find a RequestPost
     * @example
     * // Get one RequestPost
     * const requestPost = await prisma.requestPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RequestPostFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RequestPostFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RequestPost'> extends True ? CheckSelect<T, Prisma__RequestPostClient<RequestPost>, Prisma__RequestPostClient<RequestPostGetPayload<T>>> : CheckSelect<T, Prisma__RequestPostClient<RequestPost | null, null>, Prisma__RequestPostClient<RequestPostGetPayload<T> | null, null>>

    /**
     * Find the first RequestPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestPostFindFirstArgs} args - Arguments to find a RequestPost
     * @example
     * // Get one RequestPost
     * const requestPost = await prisma.requestPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RequestPostFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RequestPostFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RequestPost'> extends True ? CheckSelect<T, Prisma__RequestPostClient<RequestPost>, Prisma__RequestPostClient<RequestPostGetPayload<T>>> : CheckSelect<T, Prisma__RequestPostClient<RequestPost | null, null>, Prisma__RequestPostClient<RequestPostGetPayload<T> | null, null>>

    /**
     * Find zero or more RequestPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestPostFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RequestPosts
     * const requestPosts = await prisma.requestPost.findMany()
     * 
     * // Get first 10 RequestPosts
     * const requestPosts = await prisma.requestPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const requestPostWithIdOnly = await prisma.requestPost.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RequestPostFindManyArgs>(
      args?: SelectSubset<T, RequestPostFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<RequestPost>>, PrismaPromise<Array<RequestPostGetPayload<T>>>>

    /**
     * Create a RequestPost.
     * @param {RequestPostCreateArgs} args - Arguments to create a RequestPost.
     * @example
     * // Create one RequestPost
     * const RequestPost = await prisma.requestPost.create({
     *   data: {
     *     // ... data to create a RequestPost
     *   }
     * })
     * 
    **/
    create<T extends RequestPostCreateArgs>(
      args: SelectSubset<T, RequestPostCreateArgs>
    ): CheckSelect<T, Prisma__RequestPostClient<RequestPost>, Prisma__RequestPostClient<RequestPostGetPayload<T>>>

    /**
     * Create many RequestPosts.
     *     @param {RequestPostCreateManyArgs} args - Arguments to create many RequestPosts.
     *     @example
     *     // Create many RequestPosts
     *     const requestPost = await prisma.requestPost.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RequestPostCreateManyArgs>(
      args?: SelectSubset<T, RequestPostCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a RequestPost.
     * @param {RequestPostDeleteArgs} args - Arguments to delete one RequestPost.
     * @example
     * // Delete one RequestPost
     * const RequestPost = await prisma.requestPost.delete({
     *   where: {
     *     // ... filter to delete one RequestPost
     *   }
     * })
     * 
    **/
    delete<T extends RequestPostDeleteArgs>(
      args: SelectSubset<T, RequestPostDeleteArgs>
    ): CheckSelect<T, Prisma__RequestPostClient<RequestPost>, Prisma__RequestPostClient<RequestPostGetPayload<T>>>

    /**
     * Update one RequestPost.
     * @param {RequestPostUpdateArgs} args - Arguments to update one RequestPost.
     * @example
     * // Update one RequestPost
     * const requestPost = await prisma.requestPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RequestPostUpdateArgs>(
      args: SelectSubset<T, RequestPostUpdateArgs>
    ): CheckSelect<T, Prisma__RequestPostClient<RequestPost>, Prisma__RequestPostClient<RequestPostGetPayload<T>>>

    /**
     * Delete zero or more RequestPosts.
     * @param {RequestPostDeleteManyArgs} args - Arguments to filter RequestPosts to delete.
     * @example
     * // Delete a few RequestPosts
     * const { count } = await prisma.requestPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RequestPostDeleteManyArgs>(
      args?: SelectSubset<T, RequestPostDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequestPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RequestPosts
     * const requestPost = await prisma.requestPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RequestPostUpdateManyArgs>(
      args: SelectSubset<T, RequestPostUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one RequestPost.
     * @param {RequestPostUpsertArgs} args - Arguments to update or create a RequestPost.
     * @example
     * // Update or create a RequestPost
     * const requestPost = await prisma.requestPost.upsert({
     *   create: {
     *     // ... data to create a RequestPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RequestPost we want to update
     *   }
     * })
    **/
    upsert<T extends RequestPostUpsertArgs>(
      args: SelectSubset<T, RequestPostUpsertArgs>
    ): CheckSelect<T, Prisma__RequestPostClient<RequestPost>, Prisma__RequestPostClient<RequestPostGetPayload<T>>>

    /**
     * Find one RequestPost that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {RequestPostFindUniqueOrThrowArgs} args - Arguments to find a RequestPost
     * @example
     * // Get one RequestPost
     * const requestPost = await prisma.requestPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RequestPostFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RequestPostFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__RequestPostClient<RequestPost>, Prisma__RequestPostClient<RequestPostGetPayload<T>>>

    /**
     * Find the first RequestPost that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestPostFindFirstOrThrowArgs} args - Arguments to find a RequestPost
     * @example
     * // Get one RequestPost
     * const requestPost = await prisma.requestPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RequestPostFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RequestPostFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__RequestPostClient<RequestPost>, Prisma__RequestPostClient<RequestPostGetPayload<T>>>

    /**
     * Count the number of RequestPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestPostCountArgs} args - Arguments to filter RequestPosts to count.
     * @example
     * // Count the number of RequestPosts
     * const count = await prisma.requestPost.count({
     *   where: {
     *     // ... the filter for the RequestPosts we want to count
     *   }
     * })
    **/
    count<T extends RequestPostCountArgs>(
      args?: Subset<T, RequestPostCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequestPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RequestPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequestPostAggregateArgs>(args: Subset<T, RequestPostAggregateArgs>): PrismaPromise<GetRequestPostAggregateType<T>>

    /**
     * Group by RequestPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RequestPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RequestPostGroupByArgs['orderBy'] }
        : { orderBy?: RequestPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RequestPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequestPostGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for RequestPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RequestPostClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | Null>, Prisma__UserClient<UserGetPayload<T> | Null>>;

    creator<T extends CreatorArgs = {}>(args?: Subset<T, CreatorArgs>): CheckSelect<T, Prisma__CreatorClient<Creator | Null>, Prisma__CreatorClient<CreatorGetPayload<T> | Null>>;

    requestFundings<T extends RequestFundingFindManyArgs = {}>(args?: Subset<T, RequestFundingFindManyArgs>): CheckSelect<T, PrismaPromise<Array<RequestFunding>| Null>, PrismaPromise<Array<RequestFundingGetPayload<T>>| Null>>;

    requestReactions<T extends RequestReactionFindManyArgs = {}>(args?: Subset<T, RequestReactionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<RequestReaction>| Null>, PrismaPromise<Array<RequestReactionGetPayload<T>>| Null>>;

    requestApplyCreators<T extends RequestApplyCreatorFindManyArgs = {}>(args?: Subset<T, RequestApplyCreatorFindManyArgs>): CheckSelect<T, PrismaPromise<Array<RequestApplyCreator>| Null>, PrismaPromise<Array<RequestApplyCreatorGetPayload<T>>| Null>>;

    requestPlatforms<T extends RequestPlatformFindManyArgs = {}>(args?: Subset<T, RequestPlatformFindManyArgs>): CheckSelect<T, PrismaPromise<Array<RequestPlatform>| Null>, PrismaPromise<Array<RequestPlatformGetPayload<T>>| Null>>;

    requestComments<T extends RequestCommentFindManyArgs = {}>(args?: Subset<T, RequestCommentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<RequestComment>| Null>, PrismaPromise<Array<RequestCommentGetPayload<T>>| Null>>;

    requestBookmarks<T extends RequestBookmarkFindManyArgs = {}>(args?: Subset<T, RequestBookmarkFindManyArgs>): CheckSelect<T, PrismaPromise<Array<RequestBookmark>| Null>, PrismaPromise<Array<RequestBookmarkGetPayload<T>>| Null>>;

    requestReports<T extends RequestReportFindManyArgs = {}>(args?: Subset<T, RequestReportFindManyArgs>): CheckSelect<T, PrismaPromise<Array<RequestReport>| Null>, PrismaPromise<Array<RequestReportGetPayload<T>>| Null>>;

    requestInquirys<T extends RequestInquiryFindManyArgs = {}>(args?: Subset<T, RequestInquiryFindManyArgs>): CheckSelect<T, PrismaPromise<Array<RequestInquiry>| Null>, PrismaPromise<Array<RequestInquiryGetPayload<T>>| Null>>;

    Log<T extends LogFindManyArgs = {}>(args?: Subset<T, LogFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Log>| Null>, PrismaPromise<Array<LogGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * RequestPost base type for findUnique actions
   */
  export type RequestPostFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the RequestPost
     * 
    **/
    select?: RequestPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestPostInclude | null
    /**
     * Filter, which RequestPost to fetch.
     * 
    **/
    where: RequestPostWhereUniqueInput
  }

  /**
   * RequestPost: findUnique
   */
  export interface RequestPostFindUniqueArgs extends RequestPostFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RequestPost base type for findFirst actions
   */
  export type RequestPostFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the RequestPost
     * 
    **/
    select?: RequestPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestPostInclude | null
    /**
     * Filter, which RequestPost to fetch.
     * 
    **/
    where?: RequestPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestPosts to fetch.
     * 
    **/
    orderBy?: Enumerable<RequestPostOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RequestPosts.
     * 
    **/
    cursor?: RequestPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestPosts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestPosts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RequestPosts.
     * 
    **/
    distinct?: Enumerable<RequestPostScalarFieldEnum>
  }

  /**
   * RequestPost: findFirst
   */
  export interface RequestPostFindFirstArgs extends RequestPostFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RequestPost findMany
   */
  export type RequestPostFindManyArgs = {
    /**
     * Select specific fields to fetch from the RequestPost
     * 
    **/
    select?: RequestPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestPostInclude | null
    /**
     * Filter, which RequestPosts to fetch.
     * 
    **/
    where?: RequestPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestPosts to fetch.
     * 
    **/
    orderBy?: Enumerable<RequestPostOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RequestPosts.
     * 
    **/
    cursor?: RequestPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestPosts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestPosts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RequestPostScalarFieldEnum>
  }


  /**
   * RequestPost create
   */
  export type RequestPostCreateArgs = {
    /**
     * Select specific fields to fetch from the RequestPost
     * 
    **/
    select?: RequestPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestPostInclude | null
    /**
     * The data needed to create a RequestPost.
     * 
    **/
    data: XOR<RequestPostCreateInput, RequestPostUncheckedCreateInput>
  }


  /**
   * RequestPost createMany
   */
  export type RequestPostCreateManyArgs = {
    /**
     * The data used to create many RequestPosts.
     * 
    **/
    data: Enumerable<RequestPostCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * RequestPost update
   */
  export type RequestPostUpdateArgs = {
    /**
     * Select specific fields to fetch from the RequestPost
     * 
    **/
    select?: RequestPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestPostInclude | null
    /**
     * The data needed to update a RequestPost.
     * 
    **/
    data: XOR<RequestPostUpdateInput, RequestPostUncheckedUpdateInput>
    /**
     * Choose, which RequestPost to update.
     * 
    **/
    where: RequestPostWhereUniqueInput
  }


  /**
   * RequestPost updateMany
   */
  export type RequestPostUpdateManyArgs = {
    /**
     * The data used to update RequestPosts.
     * 
    **/
    data: XOR<RequestPostUpdateManyMutationInput, RequestPostUncheckedUpdateManyInput>
    /**
     * Filter which RequestPosts to update
     * 
    **/
    where?: RequestPostWhereInput
  }


  /**
   * RequestPost upsert
   */
  export type RequestPostUpsertArgs = {
    /**
     * Select specific fields to fetch from the RequestPost
     * 
    **/
    select?: RequestPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestPostInclude | null
    /**
     * The filter to search for the RequestPost to update in case it exists.
     * 
    **/
    where: RequestPostWhereUniqueInput
    /**
     * In case the RequestPost found by the `where` argument doesn't exist, create a new RequestPost with this data.
     * 
    **/
    create: XOR<RequestPostCreateInput, RequestPostUncheckedCreateInput>
    /**
     * In case the RequestPost was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<RequestPostUpdateInput, RequestPostUncheckedUpdateInput>
  }


  /**
   * RequestPost delete
   */
  export type RequestPostDeleteArgs = {
    /**
     * Select specific fields to fetch from the RequestPost
     * 
    **/
    select?: RequestPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestPostInclude | null
    /**
     * Filter which RequestPost to delete.
     * 
    **/
    where: RequestPostWhereUniqueInput
  }


  /**
   * RequestPost deleteMany
   */
  export type RequestPostDeleteManyArgs = {
    /**
     * Filter which RequestPosts to delete
     * 
    **/
    where?: RequestPostWhereInput
  }


  /**
   * RequestPost: findUniqueOrThrow
   */
  export type RequestPostFindUniqueOrThrowArgs = RequestPostFindUniqueArgsBase
      

  /**
   * RequestPost: findFirstOrThrow
   */
  export type RequestPostFindFirstOrThrowArgs = RequestPostFindFirstArgsBase
      

  /**
   * RequestPost without action
   */
  export type RequestPostArgs = {
    /**
     * Select specific fields to fetch from the RequestPost
     * 
    **/
    select?: RequestPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestPostInclude | null
  }



  /**
   * Model RequestFunding
   */


  export type AggregateRequestFunding = {
    _count: RequestFundingCountAggregateOutputType | null
    _avg: RequestFundingAvgAggregateOutputType | null
    _sum: RequestFundingSumAggregateOutputType | null
    _min: RequestFundingMinAggregateOutputType | null
    _max: RequestFundingMaxAggregateOutputType | null
  }

  export type RequestFundingAvgAggregateOutputType = {
    id: number | null
    quantity: number | null
    requestId: number | null
  }

  export type RequestFundingSumAggregateOutputType = {
    id: bigint | null
    quantity: number | null
    requestId: bigint | null
  }

  export type RequestFundingMinAggregateOutputType = {
    id: bigint | null
    userId: string | null
    quantity: number | null
    requestId: bigint | null
    createdAt: Date | null
    status: RequestFundingStatus | null
  }

  export type RequestFundingMaxAggregateOutputType = {
    id: bigint | null
    userId: string | null
    quantity: number | null
    requestId: bigint | null
    createdAt: Date | null
    status: RequestFundingStatus | null
  }

  export type RequestFundingCountAggregateOutputType = {
    id: number
    userId: number
    quantity: number
    requestId: number
    createdAt: number
    status: number
    _all: number
  }


  export type RequestFundingAvgAggregateInputType = {
    id?: true
    quantity?: true
    requestId?: true
  }

  export type RequestFundingSumAggregateInputType = {
    id?: true
    quantity?: true
    requestId?: true
  }

  export type RequestFundingMinAggregateInputType = {
    id?: true
    userId?: true
    quantity?: true
    requestId?: true
    createdAt?: true
    status?: true
  }

  export type RequestFundingMaxAggregateInputType = {
    id?: true
    userId?: true
    quantity?: true
    requestId?: true
    createdAt?: true
    status?: true
  }

  export type RequestFundingCountAggregateInputType = {
    id?: true
    userId?: true
    quantity?: true
    requestId?: true
    createdAt?: true
    status?: true
    _all?: true
  }

  export type RequestFundingAggregateArgs = {
    /**
     * Filter which RequestFunding to aggregate.
     * 
    **/
    where?: RequestFundingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestFundings to fetch.
     * 
    **/
    orderBy?: Enumerable<RequestFundingOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: RequestFundingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestFundings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestFundings.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RequestFundings
    **/
    _count?: true | RequestFundingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RequestFundingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RequestFundingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RequestFundingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RequestFundingMaxAggregateInputType
  }

  export type GetRequestFundingAggregateType<T extends RequestFundingAggregateArgs> = {
        [P in keyof T & keyof AggregateRequestFunding]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequestFunding[P]>
      : GetScalarType<T[P], AggregateRequestFunding[P]>
  }




  export type RequestFundingGroupByArgs = {
    where?: RequestFundingWhereInput
    orderBy?: Enumerable<RequestFundingOrderByWithAggregationInput>
    by: Array<RequestFundingScalarFieldEnum>
    having?: RequestFundingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RequestFundingCountAggregateInputType | true
    _avg?: RequestFundingAvgAggregateInputType
    _sum?: RequestFundingSumAggregateInputType
    _min?: RequestFundingMinAggregateInputType
    _max?: RequestFundingMaxAggregateInputType
  }


  export type RequestFundingGroupByOutputType = {
    id: bigint
    userId: string | null
    quantity: number
    requestId: bigint | null
    createdAt: Date
    status: RequestFundingStatus
    _count: RequestFundingCountAggregateOutputType | null
    _avg: RequestFundingAvgAggregateOutputType | null
    _sum: RequestFundingSumAggregateOutputType | null
    _min: RequestFundingMinAggregateOutputType | null
    _max: RequestFundingMaxAggregateOutputType | null
  }

  type GetRequestFundingGroupByPayload<T extends RequestFundingGroupByArgs> = PrismaPromise<
    Array<
      PickArray<RequestFundingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RequestFundingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RequestFundingGroupByOutputType[P]>
            : GetScalarType<T[P], RequestFundingGroupByOutputType[P]>
        }
      >
    >


  export type RequestFundingSelect = {
    id?: boolean
    user?: boolean | UserArgs
    userId?: boolean
    quantity?: boolean
    request?: boolean | RequestPostArgs
    requestId?: boolean
    createdAt?: boolean
    status?: boolean
  }

  export type RequestFundingInclude = {
    user?: boolean | UserArgs
    request?: boolean | RequestPostArgs
  }

  export type RequestFundingGetPayload<
    S extends boolean | null | undefined | RequestFundingArgs,
    U = keyof S
      > = S extends true
        ? RequestFunding
    : S extends undefined
    ? never
    : S extends RequestFundingArgs | RequestFundingFindManyArgs
    ?'include' extends U
    ? RequestFunding  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'request' ? RequestPostGetPayload<Exclude<S['include'], undefined | null>[P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'request' ? RequestPostGetPayload<Exclude<S['select'], undefined | null>[P]> | null :  P extends keyof RequestFunding ? RequestFunding[P] : never
  } 
    : RequestFunding
  : RequestFunding


  type RequestFundingCountArgs = Merge<
    Omit<RequestFundingFindManyArgs, 'select' | 'include'> & {
      select?: RequestFundingCountAggregateInputType | true
    }
  >

  export interface RequestFundingDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one RequestFunding that matches the filter.
     * @param {RequestFundingFindUniqueArgs} args - Arguments to find a RequestFunding
     * @example
     * // Get one RequestFunding
     * const requestFunding = await prisma.requestFunding.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RequestFundingFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RequestFundingFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RequestFunding'> extends True ? CheckSelect<T, Prisma__RequestFundingClient<RequestFunding>, Prisma__RequestFundingClient<RequestFundingGetPayload<T>>> : CheckSelect<T, Prisma__RequestFundingClient<RequestFunding | null, null>, Prisma__RequestFundingClient<RequestFundingGetPayload<T> | null, null>>

    /**
     * Find the first RequestFunding that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestFundingFindFirstArgs} args - Arguments to find a RequestFunding
     * @example
     * // Get one RequestFunding
     * const requestFunding = await prisma.requestFunding.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RequestFundingFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RequestFundingFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RequestFunding'> extends True ? CheckSelect<T, Prisma__RequestFundingClient<RequestFunding>, Prisma__RequestFundingClient<RequestFundingGetPayload<T>>> : CheckSelect<T, Prisma__RequestFundingClient<RequestFunding | null, null>, Prisma__RequestFundingClient<RequestFundingGetPayload<T> | null, null>>

    /**
     * Find zero or more RequestFundings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestFundingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RequestFundings
     * const requestFundings = await prisma.requestFunding.findMany()
     * 
     * // Get first 10 RequestFundings
     * const requestFundings = await prisma.requestFunding.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const requestFundingWithIdOnly = await prisma.requestFunding.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RequestFundingFindManyArgs>(
      args?: SelectSubset<T, RequestFundingFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<RequestFunding>>, PrismaPromise<Array<RequestFundingGetPayload<T>>>>

    /**
     * Create a RequestFunding.
     * @param {RequestFundingCreateArgs} args - Arguments to create a RequestFunding.
     * @example
     * // Create one RequestFunding
     * const RequestFunding = await prisma.requestFunding.create({
     *   data: {
     *     // ... data to create a RequestFunding
     *   }
     * })
     * 
    **/
    create<T extends RequestFundingCreateArgs>(
      args: SelectSubset<T, RequestFundingCreateArgs>
    ): CheckSelect<T, Prisma__RequestFundingClient<RequestFunding>, Prisma__RequestFundingClient<RequestFundingGetPayload<T>>>

    /**
     * Create many RequestFundings.
     *     @param {RequestFundingCreateManyArgs} args - Arguments to create many RequestFundings.
     *     @example
     *     // Create many RequestFundings
     *     const requestFunding = await prisma.requestFunding.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RequestFundingCreateManyArgs>(
      args?: SelectSubset<T, RequestFundingCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a RequestFunding.
     * @param {RequestFundingDeleteArgs} args - Arguments to delete one RequestFunding.
     * @example
     * // Delete one RequestFunding
     * const RequestFunding = await prisma.requestFunding.delete({
     *   where: {
     *     // ... filter to delete one RequestFunding
     *   }
     * })
     * 
    **/
    delete<T extends RequestFundingDeleteArgs>(
      args: SelectSubset<T, RequestFundingDeleteArgs>
    ): CheckSelect<T, Prisma__RequestFundingClient<RequestFunding>, Prisma__RequestFundingClient<RequestFundingGetPayload<T>>>

    /**
     * Update one RequestFunding.
     * @param {RequestFundingUpdateArgs} args - Arguments to update one RequestFunding.
     * @example
     * // Update one RequestFunding
     * const requestFunding = await prisma.requestFunding.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RequestFundingUpdateArgs>(
      args: SelectSubset<T, RequestFundingUpdateArgs>
    ): CheckSelect<T, Prisma__RequestFundingClient<RequestFunding>, Prisma__RequestFundingClient<RequestFundingGetPayload<T>>>

    /**
     * Delete zero or more RequestFundings.
     * @param {RequestFundingDeleteManyArgs} args - Arguments to filter RequestFundings to delete.
     * @example
     * // Delete a few RequestFundings
     * const { count } = await prisma.requestFunding.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RequestFundingDeleteManyArgs>(
      args?: SelectSubset<T, RequestFundingDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequestFundings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestFundingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RequestFundings
     * const requestFunding = await prisma.requestFunding.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RequestFundingUpdateManyArgs>(
      args: SelectSubset<T, RequestFundingUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one RequestFunding.
     * @param {RequestFundingUpsertArgs} args - Arguments to update or create a RequestFunding.
     * @example
     * // Update or create a RequestFunding
     * const requestFunding = await prisma.requestFunding.upsert({
     *   create: {
     *     // ... data to create a RequestFunding
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RequestFunding we want to update
     *   }
     * })
    **/
    upsert<T extends RequestFundingUpsertArgs>(
      args: SelectSubset<T, RequestFundingUpsertArgs>
    ): CheckSelect<T, Prisma__RequestFundingClient<RequestFunding>, Prisma__RequestFundingClient<RequestFundingGetPayload<T>>>

    /**
     * Find one RequestFunding that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {RequestFundingFindUniqueOrThrowArgs} args - Arguments to find a RequestFunding
     * @example
     * // Get one RequestFunding
     * const requestFunding = await prisma.requestFunding.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RequestFundingFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RequestFundingFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__RequestFundingClient<RequestFunding>, Prisma__RequestFundingClient<RequestFundingGetPayload<T>>>

    /**
     * Find the first RequestFunding that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestFundingFindFirstOrThrowArgs} args - Arguments to find a RequestFunding
     * @example
     * // Get one RequestFunding
     * const requestFunding = await prisma.requestFunding.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RequestFundingFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RequestFundingFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__RequestFundingClient<RequestFunding>, Prisma__RequestFundingClient<RequestFundingGetPayload<T>>>

    /**
     * Count the number of RequestFundings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestFundingCountArgs} args - Arguments to filter RequestFundings to count.
     * @example
     * // Count the number of RequestFundings
     * const count = await prisma.requestFunding.count({
     *   where: {
     *     // ... the filter for the RequestFundings we want to count
     *   }
     * })
    **/
    count<T extends RequestFundingCountArgs>(
      args?: Subset<T, RequestFundingCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequestFundingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RequestFunding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestFundingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequestFundingAggregateArgs>(args: Subset<T, RequestFundingAggregateArgs>): PrismaPromise<GetRequestFundingAggregateType<T>>

    /**
     * Group by RequestFunding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestFundingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RequestFundingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RequestFundingGroupByArgs['orderBy'] }
        : { orderBy?: RequestFundingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RequestFundingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequestFundingGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for RequestFunding.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RequestFundingClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | Null>, Prisma__UserClient<UserGetPayload<T> | Null>>;

    request<T extends RequestPostArgs = {}>(args?: Subset<T, RequestPostArgs>): CheckSelect<T, Prisma__RequestPostClient<RequestPost | Null>, Prisma__RequestPostClient<RequestPostGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * RequestFunding base type for findUnique actions
   */
  export type RequestFundingFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the RequestFunding
     * 
    **/
    select?: RequestFundingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestFundingInclude | null
    /**
     * Filter, which RequestFunding to fetch.
     * 
    **/
    where: RequestFundingWhereUniqueInput
  }

  /**
   * RequestFunding: findUnique
   */
  export interface RequestFundingFindUniqueArgs extends RequestFundingFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RequestFunding base type for findFirst actions
   */
  export type RequestFundingFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the RequestFunding
     * 
    **/
    select?: RequestFundingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestFundingInclude | null
    /**
     * Filter, which RequestFunding to fetch.
     * 
    **/
    where?: RequestFundingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestFundings to fetch.
     * 
    **/
    orderBy?: Enumerable<RequestFundingOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RequestFundings.
     * 
    **/
    cursor?: RequestFundingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestFundings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestFundings.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RequestFundings.
     * 
    **/
    distinct?: Enumerable<RequestFundingScalarFieldEnum>
  }

  /**
   * RequestFunding: findFirst
   */
  export interface RequestFundingFindFirstArgs extends RequestFundingFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RequestFunding findMany
   */
  export type RequestFundingFindManyArgs = {
    /**
     * Select specific fields to fetch from the RequestFunding
     * 
    **/
    select?: RequestFundingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestFundingInclude | null
    /**
     * Filter, which RequestFundings to fetch.
     * 
    **/
    where?: RequestFundingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestFundings to fetch.
     * 
    **/
    orderBy?: Enumerable<RequestFundingOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RequestFundings.
     * 
    **/
    cursor?: RequestFundingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestFundings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestFundings.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RequestFundingScalarFieldEnum>
  }


  /**
   * RequestFunding create
   */
  export type RequestFundingCreateArgs = {
    /**
     * Select specific fields to fetch from the RequestFunding
     * 
    **/
    select?: RequestFundingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestFundingInclude | null
    /**
     * The data needed to create a RequestFunding.
     * 
    **/
    data: XOR<RequestFundingCreateInput, RequestFundingUncheckedCreateInput>
  }


  /**
   * RequestFunding createMany
   */
  export type RequestFundingCreateManyArgs = {
    /**
     * The data used to create many RequestFundings.
     * 
    **/
    data: Enumerable<RequestFundingCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * RequestFunding update
   */
  export type RequestFundingUpdateArgs = {
    /**
     * Select specific fields to fetch from the RequestFunding
     * 
    **/
    select?: RequestFundingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestFundingInclude | null
    /**
     * The data needed to update a RequestFunding.
     * 
    **/
    data: XOR<RequestFundingUpdateInput, RequestFundingUncheckedUpdateInput>
    /**
     * Choose, which RequestFunding to update.
     * 
    **/
    where: RequestFundingWhereUniqueInput
  }


  /**
   * RequestFunding updateMany
   */
  export type RequestFundingUpdateManyArgs = {
    /**
     * The data used to update RequestFundings.
     * 
    **/
    data: XOR<RequestFundingUpdateManyMutationInput, RequestFundingUncheckedUpdateManyInput>
    /**
     * Filter which RequestFundings to update
     * 
    **/
    where?: RequestFundingWhereInput
  }


  /**
   * RequestFunding upsert
   */
  export type RequestFundingUpsertArgs = {
    /**
     * Select specific fields to fetch from the RequestFunding
     * 
    **/
    select?: RequestFundingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestFundingInclude | null
    /**
     * The filter to search for the RequestFunding to update in case it exists.
     * 
    **/
    where: RequestFundingWhereUniqueInput
    /**
     * In case the RequestFunding found by the `where` argument doesn't exist, create a new RequestFunding with this data.
     * 
    **/
    create: XOR<RequestFundingCreateInput, RequestFundingUncheckedCreateInput>
    /**
     * In case the RequestFunding was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<RequestFundingUpdateInput, RequestFundingUncheckedUpdateInput>
  }


  /**
   * RequestFunding delete
   */
  export type RequestFundingDeleteArgs = {
    /**
     * Select specific fields to fetch from the RequestFunding
     * 
    **/
    select?: RequestFundingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestFundingInclude | null
    /**
     * Filter which RequestFunding to delete.
     * 
    **/
    where: RequestFundingWhereUniqueInput
  }


  /**
   * RequestFunding deleteMany
   */
  export type RequestFundingDeleteManyArgs = {
    /**
     * Filter which RequestFundings to delete
     * 
    **/
    where?: RequestFundingWhereInput
  }


  /**
   * RequestFunding: findUniqueOrThrow
   */
  export type RequestFundingFindUniqueOrThrowArgs = RequestFundingFindUniqueArgsBase
      

  /**
   * RequestFunding: findFirstOrThrow
   */
  export type RequestFundingFindFirstOrThrowArgs = RequestFundingFindFirstArgsBase
      

  /**
   * RequestFunding without action
   */
  export type RequestFundingArgs = {
    /**
     * Select specific fields to fetch from the RequestFunding
     * 
    **/
    select?: RequestFundingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestFundingInclude | null
  }



  /**
   * Model RequestReaction
   */


  export type AggregateRequestReaction = {
    _count: RequestReactionCountAggregateOutputType | null
    _avg: RequestReactionAvgAggregateOutputType | null
    _sum: RequestReactionSumAggregateOutputType | null
    _min: RequestReactionMinAggregateOutputType | null
    _max: RequestReactionMaxAggregateOutputType | null
  }

  export type RequestReactionAvgAggregateOutputType = {
    id: number | null
    requestId: number | null
  }

  export type RequestReactionSumAggregateOutputType = {
    id: bigint | null
    requestId: bigint | null
  }

  export type RequestReactionMinAggregateOutputType = {
    id: bigint | null
    userId: string | null
    type: ReactionType | null
    requestId: bigint | null
    createdAt: Date | null
  }

  export type RequestReactionMaxAggregateOutputType = {
    id: bigint | null
    userId: string | null
    type: ReactionType | null
    requestId: bigint | null
    createdAt: Date | null
  }

  export type RequestReactionCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    requestId: number
    createdAt: number
    _all: number
  }


  export type RequestReactionAvgAggregateInputType = {
    id?: true
    requestId?: true
  }

  export type RequestReactionSumAggregateInputType = {
    id?: true
    requestId?: true
  }

  export type RequestReactionMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    requestId?: true
    createdAt?: true
  }

  export type RequestReactionMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    requestId?: true
    createdAt?: true
  }

  export type RequestReactionCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    requestId?: true
    createdAt?: true
    _all?: true
  }

  export type RequestReactionAggregateArgs = {
    /**
     * Filter which RequestReaction to aggregate.
     * 
    **/
    where?: RequestReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestReactions to fetch.
     * 
    **/
    orderBy?: Enumerable<RequestReactionOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: RequestReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestReactions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestReactions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RequestReactions
    **/
    _count?: true | RequestReactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RequestReactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RequestReactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RequestReactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RequestReactionMaxAggregateInputType
  }

  export type GetRequestReactionAggregateType<T extends RequestReactionAggregateArgs> = {
        [P in keyof T & keyof AggregateRequestReaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequestReaction[P]>
      : GetScalarType<T[P], AggregateRequestReaction[P]>
  }




  export type RequestReactionGroupByArgs = {
    where?: RequestReactionWhereInput
    orderBy?: Enumerable<RequestReactionOrderByWithAggregationInput>
    by: Array<RequestReactionScalarFieldEnum>
    having?: RequestReactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RequestReactionCountAggregateInputType | true
    _avg?: RequestReactionAvgAggregateInputType
    _sum?: RequestReactionSumAggregateInputType
    _min?: RequestReactionMinAggregateInputType
    _max?: RequestReactionMaxAggregateInputType
  }


  export type RequestReactionGroupByOutputType = {
    id: bigint
    userId: string
    type: ReactionType
    requestId: bigint
    createdAt: Date
    _count: RequestReactionCountAggregateOutputType | null
    _avg: RequestReactionAvgAggregateOutputType | null
    _sum: RequestReactionSumAggregateOutputType | null
    _min: RequestReactionMinAggregateOutputType | null
    _max: RequestReactionMaxAggregateOutputType | null
  }

  type GetRequestReactionGroupByPayload<T extends RequestReactionGroupByArgs> = PrismaPromise<
    Array<
      PickArray<RequestReactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RequestReactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RequestReactionGroupByOutputType[P]>
            : GetScalarType<T[P], RequestReactionGroupByOutputType[P]>
        }
      >
    >


  export type RequestReactionSelect = {
    id?: boolean
    user?: boolean | UserArgs
    userId?: boolean
    type?: boolean
    request?: boolean | RequestPostArgs
    requestId?: boolean
    createdAt?: boolean
  }

  export type RequestReactionInclude = {
    user?: boolean | UserArgs
    request?: boolean | RequestPostArgs
  }

  export type RequestReactionGetPayload<
    S extends boolean | null | undefined | RequestReactionArgs,
    U = keyof S
      > = S extends true
        ? RequestReaction
    : S extends undefined
    ? never
    : S extends RequestReactionArgs | RequestReactionFindManyArgs
    ?'include' extends U
    ? RequestReaction  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'request' ? RequestPostGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'request' ? RequestPostGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof RequestReaction ? RequestReaction[P] : never
  } 
    : RequestReaction
  : RequestReaction


  type RequestReactionCountArgs = Merge<
    Omit<RequestReactionFindManyArgs, 'select' | 'include'> & {
      select?: RequestReactionCountAggregateInputType | true
    }
  >

  export interface RequestReactionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one RequestReaction that matches the filter.
     * @param {RequestReactionFindUniqueArgs} args - Arguments to find a RequestReaction
     * @example
     * // Get one RequestReaction
     * const requestReaction = await prisma.requestReaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RequestReactionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RequestReactionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RequestReaction'> extends True ? CheckSelect<T, Prisma__RequestReactionClient<RequestReaction>, Prisma__RequestReactionClient<RequestReactionGetPayload<T>>> : CheckSelect<T, Prisma__RequestReactionClient<RequestReaction | null, null>, Prisma__RequestReactionClient<RequestReactionGetPayload<T> | null, null>>

    /**
     * Find the first RequestReaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestReactionFindFirstArgs} args - Arguments to find a RequestReaction
     * @example
     * // Get one RequestReaction
     * const requestReaction = await prisma.requestReaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RequestReactionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RequestReactionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RequestReaction'> extends True ? CheckSelect<T, Prisma__RequestReactionClient<RequestReaction>, Prisma__RequestReactionClient<RequestReactionGetPayload<T>>> : CheckSelect<T, Prisma__RequestReactionClient<RequestReaction | null, null>, Prisma__RequestReactionClient<RequestReactionGetPayload<T> | null, null>>

    /**
     * Find zero or more RequestReactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestReactionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RequestReactions
     * const requestReactions = await prisma.requestReaction.findMany()
     * 
     * // Get first 10 RequestReactions
     * const requestReactions = await prisma.requestReaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const requestReactionWithIdOnly = await prisma.requestReaction.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RequestReactionFindManyArgs>(
      args?: SelectSubset<T, RequestReactionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<RequestReaction>>, PrismaPromise<Array<RequestReactionGetPayload<T>>>>

    /**
     * Create a RequestReaction.
     * @param {RequestReactionCreateArgs} args - Arguments to create a RequestReaction.
     * @example
     * // Create one RequestReaction
     * const RequestReaction = await prisma.requestReaction.create({
     *   data: {
     *     // ... data to create a RequestReaction
     *   }
     * })
     * 
    **/
    create<T extends RequestReactionCreateArgs>(
      args: SelectSubset<T, RequestReactionCreateArgs>
    ): CheckSelect<T, Prisma__RequestReactionClient<RequestReaction>, Prisma__RequestReactionClient<RequestReactionGetPayload<T>>>

    /**
     * Create many RequestReactions.
     *     @param {RequestReactionCreateManyArgs} args - Arguments to create many RequestReactions.
     *     @example
     *     // Create many RequestReactions
     *     const requestReaction = await prisma.requestReaction.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RequestReactionCreateManyArgs>(
      args?: SelectSubset<T, RequestReactionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a RequestReaction.
     * @param {RequestReactionDeleteArgs} args - Arguments to delete one RequestReaction.
     * @example
     * // Delete one RequestReaction
     * const RequestReaction = await prisma.requestReaction.delete({
     *   where: {
     *     // ... filter to delete one RequestReaction
     *   }
     * })
     * 
    **/
    delete<T extends RequestReactionDeleteArgs>(
      args: SelectSubset<T, RequestReactionDeleteArgs>
    ): CheckSelect<T, Prisma__RequestReactionClient<RequestReaction>, Prisma__RequestReactionClient<RequestReactionGetPayload<T>>>

    /**
     * Update one RequestReaction.
     * @param {RequestReactionUpdateArgs} args - Arguments to update one RequestReaction.
     * @example
     * // Update one RequestReaction
     * const requestReaction = await prisma.requestReaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RequestReactionUpdateArgs>(
      args: SelectSubset<T, RequestReactionUpdateArgs>
    ): CheckSelect<T, Prisma__RequestReactionClient<RequestReaction>, Prisma__RequestReactionClient<RequestReactionGetPayload<T>>>

    /**
     * Delete zero or more RequestReactions.
     * @param {RequestReactionDeleteManyArgs} args - Arguments to filter RequestReactions to delete.
     * @example
     * // Delete a few RequestReactions
     * const { count } = await prisma.requestReaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RequestReactionDeleteManyArgs>(
      args?: SelectSubset<T, RequestReactionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequestReactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestReactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RequestReactions
     * const requestReaction = await prisma.requestReaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RequestReactionUpdateManyArgs>(
      args: SelectSubset<T, RequestReactionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one RequestReaction.
     * @param {RequestReactionUpsertArgs} args - Arguments to update or create a RequestReaction.
     * @example
     * // Update or create a RequestReaction
     * const requestReaction = await prisma.requestReaction.upsert({
     *   create: {
     *     // ... data to create a RequestReaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RequestReaction we want to update
     *   }
     * })
    **/
    upsert<T extends RequestReactionUpsertArgs>(
      args: SelectSubset<T, RequestReactionUpsertArgs>
    ): CheckSelect<T, Prisma__RequestReactionClient<RequestReaction>, Prisma__RequestReactionClient<RequestReactionGetPayload<T>>>

    /**
     * Find one RequestReaction that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {RequestReactionFindUniqueOrThrowArgs} args - Arguments to find a RequestReaction
     * @example
     * // Get one RequestReaction
     * const requestReaction = await prisma.requestReaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RequestReactionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RequestReactionFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__RequestReactionClient<RequestReaction>, Prisma__RequestReactionClient<RequestReactionGetPayload<T>>>

    /**
     * Find the first RequestReaction that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestReactionFindFirstOrThrowArgs} args - Arguments to find a RequestReaction
     * @example
     * // Get one RequestReaction
     * const requestReaction = await prisma.requestReaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RequestReactionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RequestReactionFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__RequestReactionClient<RequestReaction>, Prisma__RequestReactionClient<RequestReactionGetPayload<T>>>

    /**
     * Count the number of RequestReactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestReactionCountArgs} args - Arguments to filter RequestReactions to count.
     * @example
     * // Count the number of RequestReactions
     * const count = await prisma.requestReaction.count({
     *   where: {
     *     // ... the filter for the RequestReactions we want to count
     *   }
     * })
    **/
    count<T extends RequestReactionCountArgs>(
      args?: Subset<T, RequestReactionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequestReactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RequestReaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestReactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequestReactionAggregateArgs>(args: Subset<T, RequestReactionAggregateArgs>): PrismaPromise<GetRequestReactionAggregateType<T>>

    /**
     * Group by RequestReaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestReactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RequestReactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RequestReactionGroupByArgs['orderBy'] }
        : { orderBy?: RequestReactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RequestReactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequestReactionGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for RequestReaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RequestReactionClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | Null>, Prisma__UserClient<UserGetPayload<T> | Null>>;

    request<T extends RequestPostArgs = {}>(args?: Subset<T, RequestPostArgs>): CheckSelect<T, Prisma__RequestPostClient<RequestPost | Null>, Prisma__RequestPostClient<RequestPostGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * RequestReaction base type for findUnique actions
   */
  export type RequestReactionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the RequestReaction
     * 
    **/
    select?: RequestReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestReactionInclude | null
    /**
     * Filter, which RequestReaction to fetch.
     * 
    **/
    where: RequestReactionWhereUniqueInput
  }

  /**
   * RequestReaction: findUnique
   */
  export interface RequestReactionFindUniqueArgs extends RequestReactionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RequestReaction base type for findFirst actions
   */
  export type RequestReactionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the RequestReaction
     * 
    **/
    select?: RequestReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestReactionInclude | null
    /**
     * Filter, which RequestReaction to fetch.
     * 
    **/
    where?: RequestReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestReactions to fetch.
     * 
    **/
    orderBy?: Enumerable<RequestReactionOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RequestReactions.
     * 
    **/
    cursor?: RequestReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestReactions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestReactions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RequestReactions.
     * 
    **/
    distinct?: Enumerable<RequestReactionScalarFieldEnum>
  }

  /**
   * RequestReaction: findFirst
   */
  export interface RequestReactionFindFirstArgs extends RequestReactionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RequestReaction findMany
   */
  export type RequestReactionFindManyArgs = {
    /**
     * Select specific fields to fetch from the RequestReaction
     * 
    **/
    select?: RequestReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestReactionInclude | null
    /**
     * Filter, which RequestReactions to fetch.
     * 
    **/
    where?: RequestReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestReactions to fetch.
     * 
    **/
    orderBy?: Enumerable<RequestReactionOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RequestReactions.
     * 
    **/
    cursor?: RequestReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestReactions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestReactions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RequestReactionScalarFieldEnum>
  }


  /**
   * RequestReaction create
   */
  export type RequestReactionCreateArgs = {
    /**
     * Select specific fields to fetch from the RequestReaction
     * 
    **/
    select?: RequestReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestReactionInclude | null
    /**
     * The data needed to create a RequestReaction.
     * 
    **/
    data: XOR<RequestReactionCreateInput, RequestReactionUncheckedCreateInput>
  }


  /**
   * RequestReaction createMany
   */
  export type RequestReactionCreateManyArgs = {
    /**
     * The data used to create many RequestReactions.
     * 
    **/
    data: Enumerable<RequestReactionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * RequestReaction update
   */
  export type RequestReactionUpdateArgs = {
    /**
     * Select specific fields to fetch from the RequestReaction
     * 
    **/
    select?: RequestReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestReactionInclude | null
    /**
     * The data needed to update a RequestReaction.
     * 
    **/
    data: XOR<RequestReactionUpdateInput, RequestReactionUncheckedUpdateInput>
    /**
     * Choose, which RequestReaction to update.
     * 
    **/
    where: RequestReactionWhereUniqueInput
  }


  /**
   * RequestReaction updateMany
   */
  export type RequestReactionUpdateManyArgs = {
    /**
     * The data used to update RequestReactions.
     * 
    **/
    data: XOR<RequestReactionUpdateManyMutationInput, RequestReactionUncheckedUpdateManyInput>
    /**
     * Filter which RequestReactions to update
     * 
    **/
    where?: RequestReactionWhereInput
  }


  /**
   * RequestReaction upsert
   */
  export type RequestReactionUpsertArgs = {
    /**
     * Select specific fields to fetch from the RequestReaction
     * 
    **/
    select?: RequestReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestReactionInclude | null
    /**
     * The filter to search for the RequestReaction to update in case it exists.
     * 
    **/
    where: RequestReactionWhereUniqueInput
    /**
     * In case the RequestReaction found by the `where` argument doesn't exist, create a new RequestReaction with this data.
     * 
    **/
    create: XOR<RequestReactionCreateInput, RequestReactionUncheckedCreateInput>
    /**
     * In case the RequestReaction was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<RequestReactionUpdateInput, RequestReactionUncheckedUpdateInput>
  }


  /**
   * RequestReaction delete
   */
  export type RequestReactionDeleteArgs = {
    /**
     * Select specific fields to fetch from the RequestReaction
     * 
    **/
    select?: RequestReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestReactionInclude | null
    /**
     * Filter which RequestReaction to delete.
     * 
    **/
    where: RequestReactionWhereUniqueInput
  }


  /**
   * RequestReaction deleteMany
   */
  export type RequestReactionDeleteManyArgs = {
    /**
     * Filter which RequestReactions to delete
     * 
    **/
    where?: RequestReactionWhereInput
  }


  /**
   * RequestReaction: findUniqueOrThrow
   */
  export type RequestReactionFindUniqueOrThrowArgs = RequestReactionFindUniqueArgsBase
      

  /**
   * RequestReaction: findFirstOrThrow
   */
  export type RequestReactionFindFirstOrThrowArgs = RequestReactionFindFirstArgsBase
      

  /**
   * RequestReaction without action
   */
  export type RequestReactionArgs = {
    /**
     * Select specific fields to fetch from the RequestReaction
     * 
    **/
    select?: RequestReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestReactionInclude | null
  }



  /**
   * Model RequestComment
   */


  export type AggregateRequestComment = {
    _count: RequestCommentCountAggregateOutputType | null
    _avg: RequestCommentAvgAggregateOutputType | null
    _sum: RequestCommentSumAggregateOutputType | null
    _min: RequestCommentMinAggregateOutputType | null
    _max: RequestCommentMaxAggregateOutputType | null
  }

  export type RequestCommentAvgAggregateOutputType = {
    id: number | null
    requestId: number | null
    parentId: number | null
    rootId: number | null
  }

  export type RequestCommentSumAggregateOutputType = {
    id: bigint | null
    requestId: bigint | null
    parentId: bigint | null
    rootId: bigint | null
  }

  export type RequestCommentMinAggregateOutputType = {
    id: bigint | null
    requestId: bigint | null
    userId: string | null
    parentId: bigint | null
    rootId: bigint | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RequestCommentMaxAggregateOutputType = {
    id: bigint | null
    requestId: bigint | null
    userId: string | null
    parentId: bigint | null
    rootId: bigint | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RequestCommentCountAggregateOutputType = {
    id: number
    requestId: number
    userId: number
    parentId: number
    rootId: number
    content: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RequestCommentAvgAggregateInputType = {
    id?: true
    requestId?: true
    parentId?: true
    rootId?: true
  }

  export type RequestCommentSumAggregateInputType = {
    id?: true
    requestId?: true
    parentId?: true
    rootId?: true
  }

  export type RequestCommentMinAggregateInputType = {
    id?: true
    requestId?: true
    userId?: true
    parentId?: true
    rootId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RequestCommentMaxAggregateInputType = {
    id?: true
    requestId?: true
    userId?: true
    parentId?: true
    rootId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RequestCommentCountAggregateInputType = {
    id?: true
    requestId?: true
    userId?: true
    parentId?: true
    rootId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RequestCommentAggregateArgs = {
    /**
     * Filter which RequestComment to aggregate.
     * 
    **/
    where?: RequestCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestComments to fetch.
     * 
    **/
    orderBy?: Enumerable<RequestCommentOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: RequestCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestComments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestComments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RequestComments
    **/
    _count?: true | RequestCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RequestCommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RequestCommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RequestCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RequestCommentMaxAggregateInputType
  }

  export type GetRequestCommentAggregateType<T extends RequestCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateRequestComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequestComment[P]>
      : GetScalarType<T[P], AggregateRequestComment[P]>
  }




  export type RequestCommentGroupByArgs = {
    where?: RequestCommentWhereInput
    orderBy?: Enumerable<RequestCommentOrderByWithAggregationInput>
    by: Array<RequestCommentScalarFieldEnum>
    having?: RequestCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RequestCommentCountAggregateInputType | true
    _avg?: RequestCommentAvgAggregateInputType
    _sum?: RequestCommentSumAggregateInputType
    _min?: RequestCommentMinAggregateInputType
    _max?: RequestCommentMaxAggregateInputType
  }


  export type RequestCommentGroupByOutputType = {
    id: bigint
    requestId: bigint
    userId: string | null
    parentId: bigint | null
    rootId: bigint | null
    content: string
    createdAt: Date
    updatedAt: Date
    _count: RequestCommentCountAggregateOutputType | null
    _avg: RequestCommentAvgAggregateOutputType | null
    _sum: RequestCommentSumAggregateOutputType | null
    _min: RequestCommentMinAggregateOutputType | null
    _max: RequestCommentMaxAggregateOutputType | null
  }

  type GetRequestCommentGroupByPayload<T extends RequestCommentGroupByArgs> = PrismaPromise<
    Array<
      PickArray<RequestCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RequestCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RequestCommentGroupByOutputType[P]>
            : GetScalarType<T[P], RequestCommentGroupByOutputType[P]>
        }
      >
    >


  export type RequestCommentSelect = {
    id?: boolean
    request?: boolean | RequestPostArgs
    requestId?: boolean
    user?: boolean | UserArgs
    userId?: boolean
    parentId?: boolean
    parentComment?: boolean | RequestCommentArgs
    rootId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hearts?: boolean | RequestCommentHeartFindManyArgs
    childrenComments?: boolean | RequestCommentFindManyArgs
    _count?: boolean | RequestCommentCountOutputTypeArgs
  }

  export type RequestCommentInclude = {
    request?: boolean | RequestPostArgs
    user?: boolean | UserArgs
    parentComment?: boolean | RequestCommentArgs
    hearts?: boolean | RequestCommentHeartFindManyArgs
    childrenComments?: boolean | RequestCommentFindManyArgs
    _count?: boolean | RequestCommentCountOutputTypeArgs
  }

  export type RequestCommentGetPayload<
    S extends boolean | null | undefined | RequestCommentArgs,
    U = keyof S
      > = S extends true
        ? RequestComment
    : S extends undefined
    ? never
    : S extends RequestCommentArgs | RequestCommentFindManyArgs
    ?'include' extends U
    ? RequestComment  & {
    [P in TrueKeys<S['include']>]:
        P extends 'request' ? RequestPostGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'parentComment' ? RequestCommentGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'hearts' ? Array < RequestCommentHeartGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'childrenComments' ? Array < RequestCommentGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? RequestCommentCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'request' ? RequestPostGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'parentComment' ? RequestCommentGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'hearts' ? Array < RequestCommentHeartGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'childrenComments' ? Array < RequestCommentGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? RequestCommentCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof RequestComment ? RequestComment[P] : never
  } 
    : RequestComment
  : RequestComment


  type RequestCommentCountArgs = Merge<
    Omit<RequestCommentFindManyArgs, 'select' | 'include'> & {
      select?: RequestCommentCountAggregateInputType | true
    }
  >

  export interface RequestCommentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one RequestComment that matches the filter.
     * @param {RequestCommentFindUniqueArgs} args - Arguments to find a RequestComment
     * @example
     * // Get one RequestComment
     * const requestComment = await prisma.requestComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RequestCommentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RequestCommentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RequestComment'> extends True ? CheckSelect<T, Prisma__RequestCommentClient<RequestComment>, Prisma__RequestCommentClient<RequestCommentGetPayload<T>>> : CheckSelect<T, Prisma__RequestCommentClient<RequestComment | null, null>, Prisma__RequestCommentClient<RequestCommentGetPayload<T> | null, null>>

    /**
     * Find the first RequestComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestCommentFindFirstArgs} args - Arguments to find a RequestComment
     * @example
     * // Get one RequestComment
     * const requestComment = await prisma.requestComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RequestCommentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RequestCommentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RequestComment'> extends True ? CheckSelect<T, Prisma__RequestCommentClient<RequestComment>, Prisma__RequestCommentClient<RequestCommentGetPayload<T>>> : CheckSelect<T, Prisma__RequestCommentClient<RequestComment | null, null>, Prisma__RequestCommentClient<RequestCommentGetPayload<T> | null, null>>

    /**
     * Find zero or more RequestComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestCommentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RequestComments
     * const requestComments = await prisma.requestComment.findMany()
     * 
     * // Get first 10 RequestComments
     * const requestComments = await prisma.requestComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const requestCommentWithIdOnly = await prisma.requestComment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RequestCommentFindManyArgs>(
      args?: SelectSubset<T, RequestCommentFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<RequestComment>>, PrismaPromise<Array<RequestCommentGetPayload<T>>>>

    /**
     * Create a RequestComment.
     * @param {RequestCommentCreateArgs} args - Arguments to create a RequestComment.
     * @example
     * // Create one RequestComment
     * const RequestComment = await prisma.requestComment.create({
     *   data: {
     *     // ... data to create a RequestComment
     *   }
     * })
     * 
    **/
    create<T extends RequestCommentCreateArgs>(
      args: SelectSubset<T, RequestCommentCreateArgs>
    ): CheckSelect<T, Prisma__RequestCommentClient<RequestComment>, Prisma__RequestCommentClient<RequestCommentGetPayload<T>>>

    /**
     * Create many RequestComments.
     *     @param {RequestCommentCreateManyArgs} args - Arguments to create many RequestComments.
     *     @example
     *     // Create many RequestComments
     *     const requestComment = await prisma.requestComment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RequestCommentCreateManyArgs>(
      args?: SelectSubset<T, RequestCommentCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a RequestComment.
     * @param {RequestCommentDeleteArgs} args - Arguments to delete one RequestComment.
     * @example
     * // Delete one RequestComment
     * const RequestComment = await prisma.requestComment.delete({
     *   where: {
     *     // ... filter to delete one RequestComment
     *   }
     * })
     * 
    **/
    delete<T extends RequestCommentDeleteArgs>(
      args: SelectSubset<T, RequestCommentDeleteArgs>
    ): CheckSelect<T, Prisma__RequestCommentClient<RequestComment>, Prisma__RequestCommentClient<RequestCommentGetPayload<T>>>

    /**
     * Update one RequestComment.
     * @param {RequestCommentUpdateArgs} args - Arguments to update one RequestComment.
     * @example
     * // Update one RequestComment
     * const requestComment = await prisma.requestComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RequestCommentUpdateArgs>(
      args: SelectSubset<T, RequestCommentUpdateArgs>
    ): CheckSelect<T, Prisma__RequestCommentClient<RequestComment>, Prisma__RequestCommentClient<RequestCommentGetPayload<T>>>

    /**
     * Delete zero or more RequestComments.
     * @param {RequestCommentDeleteManyArgs} args - Arguments to filter RequestComments to delete.
     * @example
     * // Delete a few RequestComments
     * const { count } = await prisma.requestComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RequestCommentDeleteManyArgs>(
      args?: SelectSubset<T, RequestCommentDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequestComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RequestComments
     * const requestComment = await prisma.requestComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RequestCommentUpdateManyArgs>(
      args: SelectSubset<T, RequestCommentUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one RequestComment.
     * @param {RequestCommentUpsertArgs} args - Arguments to update or create a RequestComment.
     * @example
     * // Update or create a RequestComment
     * const requestComment = await prisma.requestComment.upsert({
     *   create: {
     *     // ... data to create a RequestComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RequestComment we want to update
     *   }
     * })
    **/
    upsert<T extends RequestCommentUpsertArgs>(
      args: SelectSubset<T, RequestCommentUpsertArgs>
    ): CheckSelect<T, Prisma__RequestCommentClient<RequestComment>, Prisma__RequestCommentClient<RequestCommentGetPayload<T>>>

    /**
     * Find one RequestComment that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {RequestCommentFindUniqueOrThrowArgs} args - Arguments to find a RequestComment
     * @example
     * // Get one RequestComment
     * const requestComment = await prisma.requestComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RequestCommentFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RequestCommentFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__RequestCommentClient<RequestComment>, Prisma__RequestCommentClient<RequestCommentGetPayload<T>>>

    /**
     * Find the first RequestComment that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestCommentFindFirstOrThrowArgs} args - Arguments to find a RequestComment
     * @example
     * // Get one RequestComment
     * const requestComment = await prisma.requestComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RequestCommentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RequestCommentFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__RequestCommentClient<RequestComment>, Prisma__RequestCommentClient<RequestCommentGetPayload<T>>>

    /**
     * Count the number of RequestComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestCommentCountArgs} args - Arguments to filter RequestComments to count.
     * @example
     * // Count the number of RequestComments
     * const count = await prisma.requestComment.count({
     *   where: {
     *     // ... the filter for the RequestComments we want to count
     *   }
     * })
    **/
    count<T extends RequestCommentCountArgs>(
      args?: Subset<T, RequestCommentCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequestCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RequestComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequestCommentAggregateArgs>(args: Subset<T, RequestCommentAggregateArgs>): PrismaPromise<GetRequestCommentAggregateType<T>>

    /**
     * Group by RequestComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RequestCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RequestCommentGroupByArgs['orderBy'] }
        : { orderBy?: RequestCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RequestCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequestCommentGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for RequestComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RequestCommentClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    request<T extends RequestPostArgs = {}>(args?: Subset<T, RequestPostArgs>): CheckSelect<T, Prisma__RequestPostClient<RequestPost | Null>, Prisma__RequestPostClient<RequestPostGetPayload<T> | Null>>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | Null>, Prisma__UserClient<UserGetPayload<T> | Null>>;

    parentComment<T extends RequestCommentArgs = {}>(args?: Subset<T, RequestCommentArgs>): CheckSelect<T, Prisma__RequestCommentClient<RequestComment | Null>, Prisma__RequestCommentClient<RequestCommentGetPayload<T> | Null>>;

    hearts<T extends RequestCommentHeartFindManyArgs = {}>(args?: Subset<T, RequestCommentHeartFindManyArgs>): CheckSelect<T, PrismaPromise<Array<RequestCommentHeart>| Null>, PrismaPromise<Array<RequestCommentHeartGetPayload<T>>| Null>>;

    childrenComments<T extends RequestCommentFindManyArgs = {}>(args?: Subset<T, RequestCommentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<RequestComment>| Null>, PrismaPromise<Array<RequestCommentGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * RequestComment base type for findUnique actions
   */
  export type RequestCommentFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the RequestComment
     * 
    **/
    select?: RequestCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestCommentInclude | null
    /**
     * Filter, which RequestComment to fetch.
     * 
    **/
    where: RequestCommentWhereUniqueInput
  }

  /**
   * RequestComment: findUnique
   */
  export interface RequestCommentFindUniqueArgs extends RequestCommentFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RequestComment base type for findFirst actions
   */
  export type RequestCommentFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the RequestComment
     * 
    **/
    select?: RequestCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestCommentInclude | null
    /**
     * Filter, which RequestComment to fetch.
     * 
    **/
    where?: RequestCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestComments to fetch.
     * 
    **/
    orderBy?: Enumerable<RequestCommentOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RequestComments.
     * 
    **/
    cursor?: RequestCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestComments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestComments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RequestComments.
     * 
    **/
    distinct?: Enumerable<RequestCommentScalarFieldEnum>
  }

  /**
   * RequestComment: findFirst
   */
  export interface RequestCommentFindFirstArgs extends RequestCommentFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RequestComment findMany
   */
  export type RequestCommentFindManyArgs = {
    /**
     * Select specific fields to fetch from the RequestComment
     * 
    **/
    select?: RequestCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestCommentInclude | null
    /**
     * Filter, which RequestComments to fetch.
     * 
    **/
    where?: RequestCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestComments to fetch.
     * 
    **/
    orderBy?: Enumerable<RequestCommentOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RequestComments.
     * 
    **/
    cursor?: RequestCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestComments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestComments.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RequestCommentScalarFieldEnum>
  }


  /**
   * RequestComment create
   */
  export type RequestCommentCreateArgs = {
    /**
     * Select specific fields to fetch from the RequestComment
     * 
    **/
    select?: RequestCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestCommentInclude | null
    /**
     * The data needed to create a RequestComment.
     * 
    **/
    data: XOR<RequestCommentCreateInput, RequestCommentUncheckedCreateInput>
  }


  /**
   * RequestComment createMany
   */
  export type RequestCommentCreateManyArgs = {
    /**
     * The data used to create many RequestComments.
     * 
    **/
    data: Enumerable<RequestCommentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * RequestComment update
   */
  export type RequestCommentUpdateArgs = {
    /**
     * Select specific fields to fetch from the RequestComment
     * 
    **/
    select?: RequestCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestCommentInclude | null
    /**
     * The data needed to update a RequestComment.
     * 
    **/
    data: XOR<RequestCommentUpdateInput, RequestCommentUncheckedUpdateInput>
    /**
     * Choose, which RequestComment to update.
     * 
    **/
    where: RequestCommentWhereUniqueInput
  }


  /**
   * RequestComment updateMany
   */
  export type RequestCommentUpdateManyArgs = {
    /**
     * The data used to update RequestComments.
     * 
    **/
    data: XOR<RequestCommentUpdateManyMutationInput, RequestCommentUncheckedUpdateManyInput>
    /**
     * Filter which RequestComments to update
     * 
    **/
    where?: RequestCommentWhereInput
  }


  /**
   * RequestComment upsert
   */
  export type RequestCommentUpsertArgs = {
    /**
     * Select specific fields to fetch from the RequestComment
     * 
    **/
    select?: RequestCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestCommentInclude | null
    /**
     * The filter to search for the RequestComment to update in case it exists.
     * 
    **/
    where: RequestCommentWhereUniqueInput
    /**
     * In case the RequestComment found by the `where` argument doesn't exist, create a new RequestComment with this data.
     * 
    **/
    create: XOR<RequestCommentCreateInput, RequestCommentUncheckedCreateInput>
    /**
     * In case the RequestComment was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<RequestCommentUpdateInput, RequestCommentUncheckedUpdateInput>
  }


  /**
   * RequestComment delete
   */
  export type RequestCommentDeleteArgs = {
    /**
     * Select specific fields to fetch from the RequestComment
     * 
    **/
    select?: RequestCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestCommentInclude | null
    /**
     * Filter which RequestComment to delete.
     * 
    **/
    where: RequestCommentWhereUniqueInput
  }


  /**
   * RequestComment deleteMany
   */
  export type RequestCommentDeleteManyArgs = {
    /**
     * Filter which RequestComments to delete
     * 
    **/
    where?: RequestCommentWhereInput
  }


  /**
   * RequestComment: findUniqueOrThrow
   */
  export type RequestCommentFindUniqueOrThrowArgs = RequestCommentFindUniqueArgsBase
      

  /**
   * RequestComment: findFirstOrThrow
   */
  export type RequestCommentFindFirstOrThrowArgs = RequestCommentFindFirstArgsBase
      

  /**
   * RequestComment without action
   */
  export type RequestCommentArgs = {
    /**
     * Select specific fields to fetch from the RequestComment
     * 
    **/
    select?: RequestCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestCommentInclude | null
  }



  /**
   * Model RequestCommentHeart
   */


  export type AggregateRequestCommentHeart = {
    _count: RequestCommentHeartCountAggregateOutputType | null
    _avg: RequestCommentHeartAvgAggregateOutputType | null
    _sum: RequestCommentHeartSumAggregateOutputType | null
    _min: RequestCommentHeartMinAggregateOutputType | null
    _max: RequestCommentHeartMaxAggregateOutputType | null
  }

  export type RequestCommentHeartAvgAggregateOutputType = {
    id: number | null
    requestCommentId: number | null
  }

  export type RequestCommentHeartSumAggregateOutputType = {
    id: bigint | null
    requestCommentId: bigint | null
  }

  export type RequestCommentHeartMinAggregateOutputType = {
    id: bigint | null
    requestCommentId: bigint | null
    userId: string | null
    createdAt: Date | null
  }

  export type RequestCommentHeartMaxAggregateOutputType = {
    id: bigint | null
    requestCommentId: bigint | null
    userId: string | null
    createdAt: Date | null
  }

  export type RequestCommentHeartCountAggregateOutputType = {
    id: number
    requestCommentId: number
    userId: number
    createdAt: number
    _all: number
  }


  export type RequestCommentHeartAvgAggregateInputType = {
    id?: true
    requestCommentId?: true
  }

  export type RequestCommentHeartSumAggregateInputType = {
    id?: true
    requestCommentId?: true
  }

  export type RequestCommentHeartMinAggregateInputType = {
    id?: true
    requestCommentId?: true
    userId?: true
    createdAt?: true
  }

  export type RequestCommentHeartMaxAggregateInputType = {
    id?: true
    requestCommentId?: true
    userId?: true
    createdAt?: true
  }

  export type RequestCommentHeartCountAggregateInputType = {
    id?: true
    requestCommentId?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type RequestCommentHeartAggregateArgs = {
    /**
     * Filter which RequestCommentHeart to aggregate.
     * 
    **/
    where?: RequestCommentHeartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestCommentHearts to fetch.
     * 
    **/
    orderBy?: Enumerable<RequestCommentHeartOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: RequestCommentHeartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestCommentHearts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestCommentHearts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RequestCommentHearts
    **/
    _count?: true | RequestCommentHeartCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RequestCommentHeartAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RequestCommentHeartSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RequestCommentHeartMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RequestCommentHeartMaxAggregateInputType
  }

  export type GetRequestCommentHeartAggregateType<T extends RequestCommentHeartAggregateArgs> = {
        [P in keyof T & keyof AggregateRequestCommentHeart]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequestCommentHeart[P]>
      : GetScalarType<T[P], AggregateRequestCommentHeart[P]>
  }




  export type RequestCommentHeartGroupByArgs = {
    where?: RequestCommentHeartWhereInput
    orderBy?: Enumerable<RequestCommentHeartOrderByWithAggregationInput>
    by: Array<RequestCommentHeartScalarFieldEnum>
    having?: RequestCommentHeartScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RequestCommentHeartCountAggregateInputType | true
    _avg?: RequestCommentHeartAvgAggregateInputType
    _sum?: RequestCommentHeartSumAggregateInputType
    _min?: RequestCommentHeartMinAggregateInputType
    _max?: RequestCommentHeartMaxAggregateInputType
  }


  export type RequestCommentHeartGroupByOutputType = {
    id: bigint
    requestCommentId: bigint
    userId: string
    createdAt: Date
    _count: RequestCommentHeartCountAggregateOutputType | null
    _avg: RequestCommentHeartAvgAggregateOutputType | null
    _sum: RequestCommentHeartSumAggregateOutputType | null
    _min: RequestCommentHeartMinAggregateOutputType | null
    _max: RequestCommentHeartMaxAggregateOutputType | null
  }

  type GetRequestCommentHeartGroupByPayload<T extends RequestCommentHeartGroupByArgs> = PrismaPromise<
    Array<
      PickArray<RequestCommentHeartGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RequestCommentHeartGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RequestCommentHeartGroupByOutputType[P]>
            : GetScalarType<T[P], RequestCommentHeartGroupByOutputType[P]>
        }
      >
    >


  export type RequestCommentHeartSelect = {
    id?: boolean
    requestComment?: boolean | RequestCommentArgs
    requestCommentId?: boolean
    user?: boolean | UserArgs
    userId?: boolean
    createdAt?: boolean
  }

  export type RequestCommentHeartInclude = {
    requestComment?: boolean | RequestCommentArgs
    user?: boolean | UserArgs
  }

  export type RequestCommentHeartGetPayload<
    S extends boolean | null | undefined | RequestCommentHeartArgs,
    U = keyof S
      > = S extends true
        ? RequestCommentHeart
    : S extends undefined
    ? never
    : S extends RequestCommentHeartArgs | RequestCommentHeartFindManyArgs
    ?'include' extends U
    ? RequestCommentHeart  & {
    [P in TrueKeys<S['include']>]:
        P extends 'requestComment' ? RequestCommentGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'requestComment' ? RequestCommentGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof RequestCommentHeart ? RequestCommentHeart[P] : never
  } 
    : RequestCommentHeart
  : RequestCommentHeart


  type RequestCommentHeartCountArgs = Merge<
    Omit<RequestCommentHeartFindManyArgs, 'select' | 'include'> & {
      select?: RequestCommentHeartCountAggregateInputType | true
    }
  >

  export interface RequestCommentHeartDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one RequestCommentHeart that matches the filter.
     * @param {RequestCommentHeartFindUniqueArgs} args - Arguments to find a RequestCommentHeart
     * @example
     * // Get one RequestCommentHeart
     * const requestCommentHeart = await prisma.requestCommentHeart.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RequestCommentHeartFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RequestCommentHeartFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RequestCommentHeart'> extends True ? CheckSelect<T, Prisma__RequestCommentHeartClient<RequestCommentHeart>, Prisma__RequestCommentHeartClient<RequestCommentHeartGetPayload<T>>> : CheckSelect<T, Prisma__RequestCommentHeartClient<RequestCommentHeart | null, null>, Prisma__RequestCommentHeartClient<RequestCommentHeartGetPayload<T> | null, null>>

    /**
     * Find the first RequestCommentHeart that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestCommentHeartFindFirstArgs} args - Arguments to find a RequestCommentHeart
     * @example
     * // Get one RequestCommentHeart
     * const requestCommentHeart = await prisma.requestCommentHeart.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RequestCommentHeartFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RequestCommentHeartFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RequestCommentHeart'> extends True ? CheckSelect<T, Prisma__RequestCommentHeartClient<RequestCommentHeart>, Prisma__RequestCommentHeartClient<RequestCommentHeartGetPayload<T>>> : CheckSelect<T, Prisma__RequestCommentHeartClient<RequestCommentHeart | null, null>, Prisma__RequestCommentHeartClient<RequestCommentHeartGetPayload<T> | null, null>>

    /**
     * Find zero or more RequestCommentHearts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestCommentHeartFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RequestCommentHearts
     * const requestCommentHearts = await prisma.requestCommentHeart.findMany()
     * 
     * // Get first 10 RequestCommentHearts
     * const requestCommentHearts = await prisma.requestCommentHeart.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const requestCommentHeartWithIdOnly = await prisma.requestCommentHeart.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RequestCommentHeartFindManyArgs>(
      args?: SelectSubset<T, RequestCommentHeartFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<RequestCommentHeart>>, PrismaPromise<Array<RequestCommentHeartGetPayload<T>>>>

    /**
     * Create a RequestCommentHeart.
     * @param {RequestCommentHeartCreateArgs} args - Arguments to create a RequestCommentHeart.
     * @example
     * // Create one RequestCommentHeart
     * const RequestCommentHeart = await prisma.requestCommentHeart.create({
     *   data: {
     *     // ... data to create a RequestCommentHeart
     *   }
     * })
     * 
    **/
    create<T extends RequestCommentHeartCreateArgs>(
      args: SelectSubset<T, RequestCommentHeartCreateArgs>
    ): CheckSelect<T, Prisma__RequestCommentHeartClient<RequestCommentHeart>, Prisma__RequestCommentHeartClient<RequestCommentHeartGetPayload<T>>>

    /**
     * Create many RequestCommentHearts.
     *     @param {RequestCommentHeartCreateManyArgs} args - Arguments to create many RequestCommentHearts.
     *     @example
     *     // Create many RequestCommentHearts
     *     const requestCommentHeart = await prisma.requestCommentHeart.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RequestCommentHeartCreateManyArgs>(
      args?: SelectSubset<T, RequestCommentHeartCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a RequestCommentHeart.
     * @param {RequestCommentHeartDeleteArgs} args - Arguments to delete one RequestCommentHeart.
     * @example
     * // Delete one RequestCommentHeart
     * const RequestCommentHeart = await prisma.requestCommentHeart.delete({
     *   where: {
     *     // ... filter to delete one RequestCommentHeart
     *   }
     * })
     * 
    **/
    delete<T extends RequestCommentHeartDeleteArgs>(
      args: SelectSubset<T, RequestCommentHeartDeleteArgs>
    ): CheckSelect<T, Prisma__RequestCommentHeartClient<RequestCommentHeart>, Prisma__RequestCommentHeartClient<RequestCommentHeartGetPayload<T>>>

    /**
     * Update one RequestCommentHeart.
     * @param {RequestCommentHeartUpdateArgs} args - Arguments to update one RequestCommentHeart.
     * @example
     * // Update one RequestCommentHeart
     * const requestCommentHeart = await prisma.requestCommentHeart.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RequestCommentHeartUpdateArgs>(
      args: SelectSubset<T, RequestCommentHeartUpdateArgs>
    ): CheckSelect<T, Prisma__RequestCommentHeartClient<RequestCommentHeart>, Prisma__RequestCommentHeartClient<RequestCommentHeartGetPayload<T>>>

    /**
     * Delete zero or more RequestCommentHearts.
     * @param {RequestCommentHeartDeleteManyArgs} args - Arguments to filter RequestCommentHearts to delete.
     * @example
     * // Delete a few RequestCommentHearts
     * const { count } = await prisma.requestCommentHeart.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RequestCommentHeartDeleteManyArgs>(
      args?: SelectSubset<T, RequestCommentHeartDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequestCommentHearts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestCommentHeartUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RequestCommentHearts
     * const requestCommentHeart = await prisma.requestCommentHeart.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RequestCommentHeartUpdateManyArgs>(
      args: SelectSubset<T, RequestCommentHeartUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one RequestCommentHeart.
     * @param {RequestCommentHeartUpsertArgs} args - Arguments to update or create a RequestCommentHeart.
     * @example
     * // Update or create a RequestCommentHeart
     * const requestCommentHeart = await prisma.requestCommentHeart.upsert({
     *   create: {
     *     // ... data to create a RequestCommentHeart
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RequestCommentHeart we want to update
     *   }
     * })
    **/
    upsert<T extends RequestCommentHeartUpsertArgs>(
      args: SelectSubset<T, RequestCommentHeartUpsertArgs>
    ): CheckSelect<T, Prisma__RequestCommentHeartClient<RequestCommentHeart>, Prisma__RequestCommentHeartClient<RequestCommentHeartGetPayload<T>>>

    /**
     * Find one RequestCommentHeart that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {RequestCommentHeartFindUniqueOrThrowArgs} args - Arguments to find a RequestCommentHeart
     * @example
     * // Get one RequestCommentHeart
     * const requestCommentHeart = await prisma.requestCommentHeart.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RequestCommentHeartFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RequestCommentHeartFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__RequestCommentHeartClient<RequestCommentHeart>, Prisma__RequestCommentHeartClient<RequestCommentHeartGetPayload<T>>>

    /**
     * Find the first RequestCommentHeart that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestCommentHeartFindFirstOrThrowArgs} args - Arguments to find a RequestCommentHeart
     * @example
     * // Get one RequestCommentHeart
     * const requestCommentHeart = await prisma.requestCommentHeart.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RequestCommentHeartFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RequestCommentHeartFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__RequestCommentHeartClient<RequestCommentHeart>, Prisma__RequestCommentHeartClient<RequestCommentHeartGetPayload<T>>>

    /**
     * Count the number of RequestCommentHearts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestCommentHeartCountArgs} args - Arguments to filter RequestCommentHearts to count.
     * @example
     * // Count the number of RequestCommentHearts
     * const count = await prisma.requestCommentHeart.count({
     *   where: {
     *     // ... the filter for the RequestCommentHearts we want to count
     *   }
     * })
    **/
    count<T extends RequestCommentHeartCountArgs>(
      args?: Subset<T, RequestCommentHeartCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequestCommentHeartCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RequestCommentHeart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestCommentHeartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequestCommentHeartAggregateArgs>(args: Subset<T, RequestCommentHeartAggregateArgs>): PrismaPromise<GetRequestCommentHeartAggregateType<T>>

    /**
     * Group by RequestCommentHeart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestCommentHeartGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RequestCommentHeartGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RequestCommentHeartGroupByArgs['orderBy'] }
        : { orderBy?: RequestCommentHeartGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RequestCommentHeartGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequestCommentHeartGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for RequestCommentHeart.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RequestCommentHeartClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    requestComment<T extends RequestCommentArgs = {}>(args?: Subset<T, RequestCommentArgs>): CheckSelect<T, Prisma__RequestCommentClient<RequestComment | Null>, Prisma__RequestCommentClient<RequestCommentGetPayload<T> | Null>>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | Null>, Prisma__UserClient<UserGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * RequestCommentHeart base type for findUnique actions
   */
  export type RequestCommentHeartFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the RequestCommentHeart
     * 
    **/
    select?: RequestCommentHeartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestCommentHeartInclude | null
    /**
     * Filter, which RequestCommentHeart to fetch.
     * 
    **/
    where: RequestCommentHeartWhereUniqueInput
  }

  /**
   * RequestCommentHeart: findUnique
   */
  export interface RequestCommentHeartFindUniqueArgs extends RequestCommentHeartFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RequestCommentHeart base type for findFirst actions
   */
  export type RequestCommentHeartFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the RequestCommentHeart
     * 
    **/
    select?: RequestCommentHeartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestCommentHeartInclude | null
    /**
     * Filter, which RequestCommentHeart to fetch.
     * 
    **/
    where?: RequestCommentHeartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestCommentHearts to fetch.
     * 
    **/
    orderBy?: Enumerable<RequestCommentHeartOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RequestCommentHearts.
     * 
    **/
    cursor?: RequestCommentHeartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestCommentHearts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestCommentHearts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RequestCommentHearts.
     * 
    **/
    distinct?: Enumerable<RequestCommentHeartScalarFieldEnum>
  }

  /**
   * RequestCommentHeart: findFirst
   */
  export interface RequestCommentHeartFindFirstArgs extends RequestCommentHeartFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RequestCommentHeart findMany
   */
  export type RequestCommentHeartFindManyArgs = {
    /**
     * Select specific fields to fetch from the RequestCommentHeart
     * 
    **/
    select?: RequestCommentHeartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestCommentHeartInclude | null
    /**
     * Filter, which RequestCommentHearts to fetch.
     * 
    **/
    where?: RequestCommentHeartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestCommentHearts to fetch.
     * 
    **/
    orderBy?: Enumerable<RequestCommentHeartOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RequestCommentHearts.
     * 
    **/
    cursor?: RequestCommentHeartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestCommentHearts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestCommentHearts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RequestCommentHeartScalarFieldEnum>
  }


  /**
   * RequestCommentHeart create
   */
  export type RequestCommentHeartCreateArgs = {
    /**
     * Select specific fields to fetch from the RequestCommentHeart
     * 
    **/
    select?: RequestCommentHeartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestCommentHeartInclude | null
    /**
     * The data needed to create a RequestCommentHeart.
     * 
    **/
    data: XOR<RequestCommentHeartCreateInput, RequestCommentHeartUncheckedCreateInput>
  }


  /**
   * RequestCommentHeart createMany
   */
  export type RequestCommentHeartCreateManyArgs = {
    /**
     * The data used to create many RequestCommentHearts.
     * 
    **/
    data: Enumerable<RequestCommentHeartCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * RequestCommentHeart update
   */
  export type RequestCommentHeartUpdateArgs = {
    /**
     * Select specific fields to fetch from the RequestCommentHeart
     * 
    **/
    select?: RequestCommentHeartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestCommentHeartInclude | null
    /**
     * The data needed to update a RequestCommentHeart.
     * 
    **/
    data: XOR<RequestCommentHeartUpdateInput, RequestCommentHeartUncheckedUpdateInput>
    /**
     * Choose, which RequestCommentHeart to update.
     * 
    **/
    where: RequestCommentHeartWhereUniqueInput
  }


  /**
   * RequestCommentHeart updateMany
   */
  export type RequestCommentHeartUpdateManyArgs = {
    /**
     * The data used to update RequestCommentHearts.
     * 
    **/
    data: XOR<RequestCommentHeartUpdateManyMutationInput, RequestCommentHeartUncheckedUpdateManyInput>
    /**
     * Filter which RequestCommentHearts to update
     * 
    **/
    where?: RequestCommentHeartWhereInput
  }


  /**
   * RequestCommentHeart upsert
   */
  export type RequestCommentHeartUpsertArgs = {
    /**
     * Select specific fields to fetch from the RequestCommentHeart
     * 
    **/
    select?: RequestCommentHeartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestCommentHeartInclude | null
    /**
     * The filter to search for the RequestCommentHeart to update in case it exists.
     * 
    **/
    where: RequestCommentHeartWhereUniqueInput
    /**
     * In case the RequestCommentHeart found by the `where` argument doesn't exist, create a new RequestCommentHeart with this data.
     * 
    **/
    create: XOR<RequestCommentHeartCreateInput, RequestCommentHeartUncheckedCreateInput>
    /**
     * In case the RequestCommentHeart was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<RequestCommentHeartUpdateInput, RequestCommentHeartUncheckedUpdateInput>
  }


  /**
   * RequestCommentHeart delete
   */
  export type RequestCommentHeartDeleteArgs = {
    /**
     * Select specific fields to fetch from the RequestCommentHeart
     * 
    **/
    select?: RequestCommentHeartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestCommentHeartInclude | null
    /**
     * Filter which RequestCommentHeart to delete.
     * 
    **/
    where: RequestCommentHeartWhereUniqueInput
  }


  /**
   * RequestCommentHeart deleteMany
   */
  export type RequestCommentHeartDeleteManyArgs = {
    /**
     * Filter which RequestCommentHearts to delete
     * 
    **/
    where?: RequestCommentHeartWhereInput
  }


  /**
   * RequestCommentHeart: findUniqueOrThrow
   */
  export type RequestCommentHeartFindUniqueOrThrowArgs = RequestCommentHeartFindUniqueArgsBase
      

  /**
   * RequestCommentHeart: findFirstOrThrow
   */
  export type RequestCommentHeartFindFirstOrThrowArgs = RequestCommentHeartFindFirstArgsBase
      

  /**
   * RequestCommentHeart without action
   */
  export type RequestCommentHeartArgs = {
    /**
     * Select specific fields to fetch from the RequestCommentHeart
     * 
    **/
    select?: RequestCommentHeartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestCommentHeartInclude | null
  }



  /**
   * Model RequestBookmark
   */


  export type AggregateRequestBookmark = {
    _count: RequestBookmarkCountAggregateOutputType | null
    _avg: RequestBookmarkAvgAggregateOutputType | null
    _sum: RequestBookmarkSumAggregateOutputType | null
    _min: RequestBookmarkMinAggregateOutputType | null
    _max: RequestBookmarkMaxAggregateOutputType | null
  }

  export type RequestBookmarkAvgAggregateOutputType = {
    id: number | null
    requestId: number | null
  }

  export type RequestBookmarkSumAggregateOutputType = {
    id: bigint | null
    requestId: bigint | null
  }

  export type RequestBookmarkMinAggregateOutputType = {
    id: bigint | null
    requestId: bigint | null
    userId: string | null
    createdAt: Date | null
  }

  export type RequestBookmarkMaxAggregateOutputType = {
    id: bigint | null
    requestId: bigint | null
    userId: string | null
    createdAt: Date | null
  }

  export type RequestBookmarkCountAggregateOutputType = {
    id: number
    requestId: number
    userId: number
    createdAt: number
    _all: number
  }


  export type RequestBookmarkAvgAggregateInputType = {
    id?: true
    requestId?: true
  }

  export type RequestBookmarkSumAggregateInputType = {
    id?: true
    requestId?: true
  }

  export type RequestBookmarkMinAggregateInputType = {
    id?: true
    requestId?: true
    userId?: true
    createdAt?: true
  }

  export type RequestBookmarkMaxAggregateInputType = {
    id?: true
    requestId?: true
    userId?: true
    createdAt?: true
  }

  export type RequestBookmarkCountAggregateInputType = {
    id?: true
    requestId?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type RequestBookmarkAggregateArgs = {
    /**
     * Filter which RequestBookmark to aggregate.
     * 
    **/
    where?: RequestBookmarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestBookmarks to fetch.
     * 
    **/
    orderBy?: Enumerable<RequestBookmarkOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: RequestBookmarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestBookmarks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestBookmarks.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RequestBookmarks
    **/
    _count?: true | RequestBookmarkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RequestBookmarkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RequestBookmarkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RequestBookmarkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RequestBookmarkMaxAggregateInputType
  }

  export type GetRequestBookmarkAggregateType<T extends RequestBookmarkAggregateArgs> = {
        [P in keyof T & keyof AggregateRequestBookmark]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequestBookmark[P]>
      : GetScalarType<T[P], AggregateRequestBookmark[P]>
  }




  export type RequestBookmarkGroupByArgs = {
    where?: RequestBookmarkWhereInput
    orderBy?: Enumerable<RequestBookmarkOrderByWithAggregationInput>
    by: Array<RequestBookmarkScalarFieldEnum>
    having?: RequestBookmarkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RequestBookmarkCountAggregateInputType | true
    _avg?: RequestBookmarkAvgAggregateInputType
    _sum?: RequestBookmarkSumAggregateInputType
    _min?: RequestBookmarkMinAggregateInputType
    _max?: RequestBookmarkMaxAggregateInputType
  }


  export type RequestBookmarkGroupByOutputType = {
    id: bigint
    requestId: bigint | null
    userId: string
    createdAt: Date
    _count: RequestBookmarkCountAggregateOutputType | null
    _avg: RequestBookmarkAvgAggregateOutputType | null
    _sum: RequestBookmarkSumAggregateOutputType | null
    _min: RequestBookmarkMinAggregateOutputType | null
    _max: RequestBookmarkMaxAggregateOutputType | null
  }

  type GetRequestBookmarkGroupByPayload<T extends RequestBookmarkGroupByArgs> = PrismaPromise<
    Array<
      PickArray<RequestBookmarkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RequestBookmarkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RequestBookmarkGroupByOutputType[P]>
            : GetScalarType<T[P], RequestBookmarkGroupByOutputType[P]>
        }
      >
    >


  export type RequestBookmarkSelect = {
    id?: boolean
    request?: boolean | RequestPostArgs
    requestId?: boolean
    user?: boolean | UserArgs
    userId?: boolean
    createdAt?: boolean
  }

  export type RequestBookmarkInclude = {
    request?: boolean | RequestPostArgs
    user?: boolean | UserArgs
  }

  export type RequestBookmarkGetPayload<
    S extends boolean | null | undefined | RequestBookmarkArgs,
    U = keyof S
      > = S extends true
        ? RequestBookmark
    : S extends undefined
    ? never
    : S extends RequestBookmarkArgs | RequestBookmarkFindManyArgs
    ?'include' extends U
    ? RequestBookmark  & {
    [P in TrueKeys<S['include']>]:
        P extends 'request' ? RequestPostGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'request' ? RequestPostGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof RequestBookmark ? RequestBookmark[P] : never
  } 
    : RequestBookmark
  : RequestBookmark


  type RequestBookmarkCountArgs = Merge<
    Omit<RequestBookmarkFindManyArgs, 'select' | 'include'> & {
      select?: RequestBookmarkCountAggregateInputType | true
    }
  >

  export interface RequestBookmarkDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one RequestBookmark that matches the filter.
     * @param {RequestBookmarkFindUniqueArgs} args - Arguments to find a RequestBookmark
     * @example
     * // Get one RequestBookmark
     * const requestBookmark = await prisma.requestBookmark.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RequestBookmarkFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RequestBookmarkFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RequestBookmark'> extends True ? CheckSelect<T, Prisma__RequestBookmarkClient<RequestBookmark>, Prisma__RequestBookmarkClient<RequestBookmarkGetPayload<T>>> : CheckSelect<T, Prisma__RequestBookmarkClient<RequestBookmark | null, null>, Prisma__RequestBookmarkClient<RequestBookmarkGetPayload<T> | null, null>>

    /**
     * Find the first RequestBookmark that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestBookmarkFindFirstArgs} args - Arguments to find a RequestBookmark
     * @example
     * // Get one RequestBookmark
     * const requestBookmark = await prisma.requestBookmark.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RequestBookmarkFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RequestBookmarkFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RequestBookmark'> extends True ? CheckSelect<T, Prisma__RequestBookmarkClient<RequestBookmark>, Prisma__RequestBookmarkClient<RequestBookmarkGetPayload<T>>> : CheckSelect<T, Prisma__RequestBookmarkClient<RequestBookmark | null, null>, Prisma__RequestBookmarkClient<RequestBookmarkGetPayload<T> | null, null>>

    /**
     * Find zero or more RequestBookmarks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestBookmarkFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RequestBookmarks
     * const requestBookmarks = await prisma.requestBookmark.findMany()
     * 
     * // Get first 10 RequestBookmarks
     * const requestBookmarks = await prisma.requestBookmark.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const requestBookmarkWithIdOnly = await prisma.requestBookmark.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RequestBookmarkFindManyArgs>(
      args?: SelectSubset<T, RequestBookmarkFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<RequestBookmark>>, PrismaPromise<Array<RequestBookmarkGetPayload<T>>>>

    /**
     * Create a RequestBookmark.
     * @param {RequestBookmarkCreateArgs} args - Arguments to create a RequestBookmark.
     * @example
     * // Create one RequestBookmark
     * const RequestBookmark = await prisma.requestBookmark.create({
     *   data: {
     *     // ... data to create a RequestBookmark
     *   }
     * })
     * 
    **/
    create<T extends RequestBookmarkCreateArgs>(
      args: SelectSubset<T, RequestBookmarkCreateArgs>
    ): CheckSelect<T, Prisma__RequestBookmarkClient<RequestBookmark>, Prisma__RequestBookmarkClient<RequestBookmarkGetPayload<T>>>

    /**
     * Create many RequestBookmarks.
     *     @param {RequestBookmarkCreateManyArgs} args - Arguments to create many RequestBookmarks.
     *     @example
     *     // Create many RequestBookmarks
     *     const requestBookmark = await prisma.requestBookmark.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RequestBookmarkCreateManyArgs>(
      args?: SelectSubset<T, RequestBookmarkCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a RequestBookmark.
     * @param {RequestBookmarkDeleteArgs} args - Arguments to delete one RequestBookmark.
     * @example
     * // Delete one RequestBookmark
     * const RequestBookmark = await prisma.requestBookmark.delete({
     *   where: {
     *     // ... filter to delete one RequestBookmark
     *   }
     * })
     * 
    **/
    delete<T extends RequestBookmarkDeleteArgs>(
      args: SelectSubset<T, RequestBookmarkDeleteArgs>
    ): CheckSelect<T, Prisma__RequestBookmarkClient<RequestBookmark>, Prisma__RequestBookmarkClient<RequestBookmarkGetPayload<T>>>

    /**
     * Update one RequestBookmark.
     * @param {RequestBookmarkUpdateArgs} args - Arguments to update one RequestBookmark.
     * @example
     * // Update one RequestBookmark
     * const requestBookmark = await prisma.requestBookmark.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RequestBookmarkUpdateArgs>(
      args: SelectSubset<T, RequestBookmarkUpdateArgs>
    ): CheckSelect<T, Prisma__RequestBookmarkClient<RequestBookmark>, Prisma__RequestBookmarkClient<RequestBookmarkGetPayload<T>>>

    /**
     * Delete zero or more RequestBookmarks.
     * @param {RequestBookmarkDeleteManyArgs} args - Arguments to filter RequestBookmarks to delete.
     * @example
     * // Delete a few RequestBookmarks
     * const { count } = await prisma.requestBookmark.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RequestBookmarkDeleteManyArgs>(
      args?: SelectSubset<T, RequestBookmarkDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequestBookmarks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestBookmarkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RequestBookmarks
     * const requestBookmark = await prisma.requestBookmark.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RequestBookmarkUpdateManyArgs>(
      args: SelectSubset<T, RequestBookmarkUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one RequestBookmark.
     * @param {RequestBookmarkUpsertArgs} args - Arguments to update or create a RequestBookmark.
     * @example
     * // Update or create a RequestBookmark
     * const requestBookmark = await prisma.requestBookmark.upsert({
     *   create: {
     *     // ... data to create a RequestBookmark
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RequestBookmark we want to update
     *   }
     * })
    **/
    upsert<T extends RequestBookmarkUpsertArgs>(
      args: SelectSubset<T, RequestBookmarkUpsertArgs>
    ): CheckSelect<T, Prisma__RequestBookmarkClient<RequestBookmark>, Prisma__RequestBookmarkClient<RequestBookmarkGetPayload<T>>>

    /**
     * Find one RequestBookmark that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {RequestBookmarkFindUniqueOrThrowArgs} args - Arguments to find a RequestBookmark
     * @example
     * // Get one RequestBookmark
     * const requestBookmark = await prisma.requestBookmark.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RequestBookmarkFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RequestBookmarkFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__RequestBookmarkClient<RequestBookmark>, Prisma__RequestBookmarkClient<RequestBookmarkGetPayload<T>>>

    /**
     * Find the first RequestBookmark that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestBookmarkFindFirstOrThrowArgs} args - Arguments to find a RequestBookmark
     * @example
     * // Get one RequestBookmark
     * const requestBookmark = await prisma.requestBookmark.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RequestBookmarkFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RequestBookmarkFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__RequestBookmarkClient<RequestBookmark>, Prisma__RequestBookmarkClient<RequestBookmarkGetPayload<T>>>

    /**
     * Count the number of RequestBookmarks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestBookmarkCountArgs} args - Arguments to filter RequestBookmarks to count.
     * @example
     * // Count the number of RequestBookmarks
     * const count = await prisma.requestBookmark.count({
     *   where: {
     *     // ... the filter for the RequestBookmarks we want to count
     *   }
     * })
    **/
    count<T extends RequestBookmarkCountArgs>(
      args?: Subset<T, RequestBookmarkCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequestBookmarkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RequestBookmark.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestBookmarkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequestBookmarkAggregateArgs>(args: Subset<T, RequestBookmarkAggregateArgs>): PrismaPromise<GetRequestBookmarkAggregateType<T>>

    /**
     * Group by RequestBookmark.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestBookmarkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RequestBookmarkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RequestBookmarkGroupByArgs['orderBy'] }
        : { orderBy?: RequestBookmarkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RequestBookmarkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequestBookmarkGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for RequestBookmark.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RequestBookmarkClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    request<T extends RequestPostArgs = {}>(args?: Subset<T, RequestPostArgs>): CheckSelect<T, Prisma__RequestPostClient<RequestPost | Null>, Prisma__RequestPostClient<RequestPostGetPayload<T> | Null>>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | Null>, Prisma__UserClient<UserGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * RequestBookmark base type for findUnique actions
   */
  export type RequestBookmarkFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the RequestBookmark
     * 
    **/
    select?: RequestBookmarkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestBookmarkInclude | null
    /**
     * Filter, which RequestBookmark to fetch.
     * 
    **/
    where: RequestBookmarkWhereUniqueInput
  }

  /**
   * RequestBookmark: findUnique
   */
  export interface RequestBookmarkFindUniqueArgs extends RequestBookmarkFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RequestBookmark base type for findFirst actions
   */
  export type RequestBookmarkFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the RequestBookmark
     * 
    **/
    select?: RequestBookmarkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestBookmarkInclude | null
    /**
     * Filter, which RequestBookmark to fetch.
     * 
    **/
    where?: RequestBookmarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestBookmarks to fetch.
     * 
    **/
    orderBy?: Enumerable<RequestBookmarkOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RequestBookmarks.
     * 
    **/
    cursor?: RequestBookmarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestBookmarks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestBookmarks.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RequestBookmarks.
     * 
    **/
    distinct?: Enumerable<RequestBookmarkScalarFieldEnum>
  }

  /**
   * RequestBookmark: findFirst
   */
  export interface RequestBookmarkFindFirstArgs extends RequestBookmarkFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RequestBookmark findMany
   */
  export type RequestBookmarkFindManyArgs = {
    /**
     * Select specific fields to fetch from the RequestBookmark
     * 
    **/
    select?: RequestBookmarkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestBookmarkInclude | null
    /**
     * Filter, which RequestBookmarks to fetch.
     * 
    **/
    where?: RequestBookmarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestBookmarks to fetch.
     * 
    **/
    orderBy?: Enumerable<RequestBookmarkOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RequestBookmarks.
     * 
    **/
    cursor?: RequestBookmarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestBookmarks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestBookmarks.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RequestBookmarkScalarFieldEnum>
  }


  /**
   * RequestBookmark create
   */
  export type RequestBookmarkCreateArgs = {
    /**
     * Select specific fields to fetch from the RequestBookmark
     * 
    **/
    select?: RequestBookmarkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestBookmarkInclude | null
    /**
     * The data needed to create a RequestBookmark.
     * 
    **/
    data: XOR<RequestBookmarkCreateInput, RequestBookmarkUncheckedCreateInput>
  }


  /**
   * RequestBookmark createMany
   */
  export type RequestBookmarkCreateManyArgs = {
    /**
     * The data used to create many RequestBookmarks.
     * 
    **/
    data: Enumerable<RequestBookmarkCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * RequestBookmark update
   */
  export type RequestBookmarkUpdateArgs = {
    /**
     * Select specific fields to fetch from the RequestBookmark
     * 
    **/
    select?: RequestBookmarkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestBookmarkInclude | null
    /**
     * The data needed to update a RequestBookmark.
     * 
    **/
    data: XOR<RequestBookmarkUpdateInput, RequestBookmarkUncheckedUpdateInput>
    /**
     * Choose, which RequestBookmark to update.
     * 
    **/
    where: RequestBookmarkWhereUniqueInput
  }


  /**
   * RequestBookmark updateMany
   */
  export type RequestBookmarkUpdateManyArgs = {
    /**
     * The data used to update RequestBookmarks.
     * 
    **/
    data: XOR<RequestBookmarkUpdateManyMutationInput, RequestBookmarkUncheckedUpdateManyInput>
    /**
     * Filter which RequestBookmarks to update
     * 
    **/
    where?: RequestBookmarkWhereInput
  }


  /**
   * RequestBookmark upsert
   */
  export type RequestBookmarkUpsertArgs = {
    /**
     * Select specific fields to fetch from the RequestBookmark
     * 
    **/
    select?: RequestBookmarkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestBookmarkInclude | null
    /**
     * The filter to search for the RequestBookmark to update in case it exists.
     * 
    **/
    where: RequestBookmarkWhereUniqueInput
    /**
     * In case the RequestBookmark found by the `where` argument doesn't exist, create a new RequestBookmark with this data.
     * 
    **/
    create: XOR<RequestBookmarkCreateInput, RequestBookmarkUncheckedCreateInput>
    /**
     * In case the RequestBookmark was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<RequestBookmarkUpdateInput, RequestBookmarkUncheckedUpdateInput>
  }


  /**
   * RequestBookmark delete
   */
  export type RequestBookmarkDeleteArgs = {
    /**
     * Select specific fields to fetch from the RequestBookmark
     * 
    **/
    select?: RequestBookmarkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestBookmarkInclude | null
    /**
     * Filter which RequestBookmark to delete.
     * 
    **/
    where: RequestBookmarkWhereUniqueInput
  }


  /**
   * RequestBookmark deleteMany
   */
  export type RequestBookmarkDeleteManyArgs = {
    /**
     * Filter which RequestBookmarks to delete
     * 
    **/
    where?: RequestBookmarkWhereInput
  }


  /**
   * RequestBookmark: findUniqueOrThrow
   */
  export type RequestBookmarkFindUniqueOrThrowArgs = RequestBookmarkFindUniqueArgsBase
      

  /**
   * RequestBookmark: findFirstOrThrow
   */
  export type RequestBookmarkFindFirstOrThrowArgs = RequestBookmarkFindFirstArgsBase
      

  /**
   * RequestBookmark without action
   */
  export type RequestBookmarkArgs = {
    /**
     * Select specific fields to fetch from the RequestBookmark
     * 
    **/
    select?: RequestBookmarkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestBookmarkInclude | null
  }



  /**
   * Model RequestPlatform
   */


  export type AggregateRequestPlatform = {
    _count: RequestPlatformCountAggregateOutputType | null
    _avg: RequestPlatformAvgAggregateOutputType | null
    _sum: RequestPlatformSumAggregateOutputType | null
    _min: RequestPlatformMinAggregateOutputType | null
    _max: RequestPlatformMaxAggregateOutputType | null
  }

  export type RequestPlatformAvgAggregateOutputType = {
    id: number | null
    requestId: number | null
  }

  export type RequestPlatformSumAggregateOutputType = {
    id: bigint | null
    requestId: bigint | null
  }

  export type RequestPlatformMinAggregateOutputType = {
    id: bigint | null
    requestId: bigint | null
    name: RequestPlatformType | null
  }

  export type RequestPlatformMaxAggregateOutputType = {
    id: bigint | null
    requestId: bigint | null
    name: RequestPlatformType | null
  }

  export type RequestPlatformCountAggregateOutputType = {
    id: number
    requestId: number
    name: number
    _all: number
  }


  export type RequestPlatformAvgAggregateInputType = {
    id?: true
    requestId?: true
  }

  export type RequestPlatformSumAggregateInputType = {
    id?: true
    requestId?: true
  }

  export type RequestPlatformMinAggregateInputType = {
    id?: true
    requestId?: true
    name?: true
  }

  export type RequestPlatformMaxAggregateInputType = {
    id?: true
    requestId?: true
    name?: true
  }

  export type RequestPlatformCountAggregateInputType = {
    id?: true
    requestId?: true
    name?: true
    _all?: true
  }

  export type RequestPlatformAggregateArgs = {
    /**
     * Filter which RequestPlatform to aggregate.
     * 
    **/
    where?: RequestPlatformWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestPlatforms to fetch.
     * 
    **/
    orderBy?: Enumerable<RequestPlatformOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: RequestPlatformWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestPlatforms from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestPlatforms.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RequestPlatforms
    **/
    _count?: true | RequestPlatformCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RequestPlatformAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RequestPlatformSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RequestPlatformMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RequestPlatformMaxAggregateInputType
  }

  export type GetRequestPlatformAggregateType<T extends RequestPlatformAggregateArgs> = {
        [P in keyof T & keyof AggregateRequestPlatform]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequestPlatform[P]>
      : GetScalarType<T[P], AggregateRequestPlatform[P]>
  }




  export type RequestPlatformGroupByArgs = {
    where?: RequestPlatformWhereInput
    orderBy?: Enumerable<RequestPlatformOrderByWithAggregationInput>
    by: Array<RequestPlatformScalarFieldEnum>
    having?: RequestPlatformScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RequestPlatformCountAggregateInputType | true
    _avg?: RequestPlatformAvgAggregateInputType
    _sum?: RequestPlatformSumAggregateInputType
    _min?: RequestPlatformMinAggregateInputType
    _max?: RequestPlatformMaxAggregateInputType
  }


  export type RequestPlatformGroupByOutputType = {
    id: bigint
    requestId: bigint
    name: RequestPlatformType
    _count: RequestPlatformCountAggregateOutputType | null
    _avg: RequestPlatformAvgAggregateOutputType | null
    _sum: RequestPlatformSumAggregateOutputType | null
    _min: RequestPlatformMinAggregateOutputType | null
    _max: RequestPlatformMaxAggregateOutputType | null
  }

  type GetRequestPlatformGroupByPayload<T extends RequestPlatformGroupByArgs> = PrismaPromise<
    Array<
      PickArray<RequestPlatformGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RequestPlatformGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RequestPlatformGroupByOutputType[P]>
            : GetScalarType<T[P], RequestPlatformGroupByOutputType[P]>
        }
      >
    >


  export type RequestPlatformSelect = {
    id?: boolean
    request?: boolean | RequestPostArgs
    requestId?: boolean
    name?: boolean
  }

  export type RequestPlatformInclude = {
    request?: boolean | RequestPostArgs
  }

  export type RequestPlatformGetPayload<
    S extends boolean | null | undefined | RequestPlatformArgs,
    U = keyof S
      > = S extends true
        ? RequestPlatform
    : S extends undefined
    ? never
    : S extends RequestPlatformArgs | RequestPlatformFindManyArgs
    ?'include' extends U
    ? RequestPlatform  & {
    [P in TrueKeys<S['include']>]:
        P extends 'request' ? RequestPostGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'request' ? RequestPostGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof RequestPlatform ? RequestPlatform[P] : never
  } 
    : RequestPlatform
  : RequestPlatform


  type RequestPlatformCountArgs = Merge<
    Omit<RequestPlatformFindManyArgs, 'select' | 'include'> & {
      select?: RequestPlatformCountAggregateInputType | true
    }
  >

  export interface RequestPlatformDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one RequestPlatform that matches the filter.
     * @param {RequestPlatformFindUniqueArgs} args - Arguments to find a RequestPlatform
     * @example
     * // Get one RequestPlatform
     * const requestPlatform = await prisma.requestPlatform.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RequestPlatformFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RequestPlatformFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RequestPlatform'> extends True ? CheckSelect<T, Prisma__RequestPlatformClient<RequestPlatform>, Prisma__RequestPlatformClient<RequestPlatformGetPayload<T>>> : CheckSelect<T, Prisma__RequestPlatformClient<RequestPlatform | null, null>, Prisma__RequestPlatformClient<RequestPlatformGetPayload<T> | null, null>>

    /**
     * Find the first RequestPlatform that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestPlatformFindFirstArgs} args - Arguments to find a RequestPlatform
     * @example
     * // Get one RequestPlatform
     * const requestPlatform = await prisma.requestPlatform.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RequestPlatformFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RequestPlatformFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RequestPlatform'> extends True ? CheckSelect<T, Prisma__RequestPlatformClient<RequestPlatform>, Prisma__RequestPlatformClient<RequestPlatformGetPayload<T>>> : CheckSelect<T, Prisma__RequestPlatformClient<RequestPlatform | null, null>, Prisma__RequestPlatformClient<RequestPlatformGetPayload<T> | null, null>>

    /**
     * Find zero or more RequestPlatforms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestPlatformFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RequestPlatforms
     * const requestPlatforms = await prisma.requestPlatform.findMany()
     * 
     * // Get first 10 RequestPlatforms
     * const requestPlatforms = await prisma.requestPlatform.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const requestPlatformWithIdOnly = await prisma.requestPlatform.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RequestPlatformFindManyArgs>(
      args?: SelectSubset<T, RequestPlatformFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<RequestPlatform>>, PrismaPromise<Array<RequestPlatformGetPayload<T>>>>

    /**
     * Create a RequestPlatform.
     * @param {RequestPlatformCreateArgs} args - Arguments to create a RequestPlatform.
     * @example
     * // Create one RequestPlatform
     * const RequestPlatform = await prisma.requestPlatform.create({
     *   data: {
     *     // ... data to create a RequestPlatform
     *   }
     * })
     * 
    **/
    create<T extends RequestPlatformCreateArgs>(
      args: SelectSubset<T, RequestPlatformCreateArgs>
    ): CheckSelect<T, Prisma__RequestPlatformClient<RequestPlatform>, Prisma__RequestPlatformClient<RequestPlatformGetPayload<T>>>

    /**
     * Create many RequestPlatforms.
     *     @param {RequestPlatformCreateManyArgs} args - Arguments to create many RequestPlatforms.
     *     @example
     *     // Create many RequestPlatforms
     *     const requestPlatform = await prisma.requestPlatform.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RequestPlatformCreateManyArgs>(
      args?: SelectSubset<T, RequestPlatformCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a RequestPlatform.
     * @param {RequestPlatformDeleteArgs} args - Arguments to delete one RequestPlatform.
     * @example
     * // Delete one RequestPlatform
     * const RequestPlatform = await prisma.requestPlatform.delete({
     *   where: {
     *     // ... filter to delete one RequestPlatform
     *   }
     * })
     * 
    **/
    delete<T extends RequestPlatformDeleteArgs>(
      args: SelectSubset<T, RequestPlatformDeleteArgs>
    ): CheckSelect<T, Prisma__RequestPlatformClient<RequestPlatform>, Prisma__RequestPlatformClient<RequestPlatformGetPayload<T>>>

    /**
     * Update one RequestPlatform.
     * @param {RequestPlatformUpdateArgs} args - Arguments to update one RequestPlatform.
     * @example
     * // Update one RequestPlatform
     * const requestPlatform = await prisma.requestPlatform.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RequestPlatformUpdateArgs>(
      args: SelectSubset<T, RequestPlatformUpdateArgs>
    ): CheckSelect<T, Prisma__RequestPlatformClient<RequestPlatform>, Prisma__RequestPlatformClient<RequestPlatformGetPayload<T>>>

    /**
     * Delete zero or more RequestPlatforms.
     * @param {RequestPlatformDeleteManyArgs} args - Arguments to filter RequestPlatforms to delete.
     * @example
     * // Delete a few RequestPlatforms
     * const { count } = await prisma.requestPlatform.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RequestPlatformDeleteManyArgs>(
      args?: SelectSubset<T, RequestPlatformDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequestPlatforms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestPlatformUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RequestPlatforms
     * const requestPlatform = await prisma.requestPlatform.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RequestPlatformUpdateManyArgs>(
      args: SelectSubset<T, RequestPlatformUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one RequestPlatform.
     * @param {RequestPlatformUpsertArgs} args - Arguments to update or create a RequestPlatform.
     * @example
     * // Update or create a RequestPlatform
     * const requestPlatform = await prisma.requestPlatform.upsert({
     *   create: {
     *     // ... data to create a RequestPlatform
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RequestPlatform we want to update
     *   }
     * })
    **/
    upsert<T extends RequestPlatformUpsertArgs>(
      args: SelectSubset<T, RequestPlatformUpsertArgs>
    ): CheckSelect<T, Prisma__RequestPlatformClient<RequestPlatform>, Prisma__RequestPlatformClient<RequestPlatformGetPayload<T>>>

    /**
     * Find one RequestPlatform that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {RequestPlatformFindUniqueOrThrowArgs} args - Arguments to find a RequestPlatform
     * @example
     * // Get one RequestPlatform
     * const requestPlatform = await prisma.requestPlatform.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RequestPlatformFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RequestPlatformFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__RequestPlatformClient<RequestPlatform>, Prisma__RequestPlatformClient<RequestPlatformGetPayload<T>>>

    /**
     * Find the first RequestPlatform that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestPlatformFindFirstOrThrowArgs} args - Arguments to find a RequestPlatform
     * @example
     * // Get one RequestPlatform
     * const requestPlatform = await prisma.requestPlatform.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RequestPlatformFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RequestPlatformFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__RequestPlatformClient<RequestPlatform>, Prisma__RequestPlatformClient<RequestPlatformGetPayload<T>>>

    /**
     * Count the number of RequestPlatforms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestPlatformCountArgs} args - Arguments to filter RequestPlatforms to count.
     * @example
     * // Count the number of RequestPlatforms
     * const count = await prisma.requestPlatform.count({
     *   where: {
     *     // ... the filter for the RequestPlatforms we want to count
     *   }
     * })
    **/
    count<T extends RequestPlatformCountArgs>(
      args?: Subset<T, RequestPlatformCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequestPlatformCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RequestPlatform.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestPlatformAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequestPlatformAggregateArgs>(args: Subset<T, RequestPlatformAggregateArgs>): PrismaPromise<GetRequestPlatformAggregateType<T>>

    /**
     * Group by RequestPlatform.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestPlatformGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RequestPlatformGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RequestPlatformGroupByArgs['orderBy'] }
        : { orderBy?: RequestPlatformGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RequestPlatformGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequestPlatformGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for RequestPlatform.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RequestPlatformClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    request<T extends RequestPostArgs = {}>(args?: Subset<T, RequestPostArgs>): CheckSelect<T, Prisma__RequestPostClient<RequestPost | Null>, Prisma__RequestPostClient<RequestPostGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * RequestPlatform base type for findUnique actions
   */
  export type RequestPlatformFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the RequestPlatform
     * 
    **/
    select?: RequestPlatformSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestPlatformInclude | null
    /**
     * Filter, which RequestPlatform to fetch.
     * 
    **/
    where: RequestPlatformWhereUniqueInput
  }

  /**
   * RequestPlatform: findUnique
   */
  export interface RequestPlatformFindUniqueArgs extends RequestPlatformFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RequestPlatform base type for findFirst actions
   */
  export type RequestPlatformFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the RequestPlatform
     * 
    **/
    select?: RequestPlatformSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestPlatformInclude | null
    /**
     * Filter, which RequestPlatform to fetch.
     * 
    **/
    where?: RequestPlatformWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestPlatforms to fetch.
     * 
    **/
    orderBy?: Enumerable<RequestPlatformOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RequestPlatforms.
     * 
    **/
    cursor?: RequestPlatformWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestPlatforms from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestPlatforms.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RequestPlatforms.
     * 
    **/
    distinct?: Enumerable<RequestPlatformScalarFieldEnum>
  }

  /**
   * RequestPlatform: findFirst
   */
  export interface RequestPlatformFindFirstArgs extends RequestPlatformFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RequestPlatform findMany
   */
  export type RequestPlatformFindManyArgs = {
    /**
     * Select specific fields to fetch from the RequestPlatform
     * 
    **/
    select?: RequestPlatformSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestPlatformInclude | null
    /**
     * Filter, which RequestPlatforms to fetch.
     * 
    **/
    where?: RequestPlatformWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestPlatforms to fetch.
     * 
    **/
    orderBy?: Enumerable<RequestPlatformOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RequestPlatforms.
     * 
    **/
    cursor?: RequestPlatformWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestPlatforms from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestPlatforms.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RequestPlatformScalarFieldEnum>
  }


  /**
   * RequestPlatform create
   */
  export type RequestPlatformCreateArgs = {
    /**
     * Select specific fields to fetch from the RequestPlatform
     * 
    **/
    select?: RequestPlatformSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestPlatformInclude | null
    /**
     * The data needed to create a RequestPlatform.
     * 
    **/
    data: XOR<RequestPlatformCreateInput, RequestPlatformUncheckedCreateInput>
  }


  /**
   * RequestPlatform createMany
   */
  export type RequestPlatformCreateManyArgs = {
    /**
     * The data used to create many RequestPlatforms.
     * 
    **/
    data: Enumerable<RequestPlatformCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * RequestPlatform update
   */
  export type RequestPlatformUpdateArgs = {
    /**
     * Select specific fields to fetch from the RequestPlatform
     * 
    **/
    select?: RequestPlatformSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestPlatformInclude | null
    /**
     * The data needed to update a RequestPlatform.
     * 
    **/
    data: XOR<RequestPlatformUpdateInput, RequestPlatformUncheckedUpdateInput>
    /**
     * Choose, which RequestPlatform to update.
     * 
    **/
    where: RequestPlatformWhereUniqueInput
  }


  /**
   * RequestPlatform updateMany
   */
  export type RequestPlatformUpdateManyArgs = {
    /**
     * The data used to update RequestPlatforms.
     * 
    **/
    data: XOR<RequestPlatformUpdateManyMutationInput, RequestPlatformUncheckedUpdateManyInput>
    /**
     * Filter which RequestPlatforms to update
     * 
    **/
    where?: RequestPlatformWhereInput
  }


  /**
   * RequestPlatform upsert
   */
  export type RequestPlatformUpsertArgs = {
    /**
     * Select specific fields to fetch from the RequestPlatform
     * 
    **/
    select?: RequestPlatformSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestPlatformInclude | null
    /**
     * The filter to search for the RequestPlatform to update in case it exists.
     * 
    **/
    where: RequestPlatformWhereUniqueInput
    /**
     * In case the RequestPlatform found by the `where` argument doesn't exist, create a new RequestPlatform with this data.
     * 
    **/
    create: XOR<RequestPlatformCreateInput, RequestPlatformUncheckedCreateInput>
    /**
     * In case the RequestPlatform was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<RequestPlatformUpdateInput, RequestPlatformUncheckedUpdateInput>
  }


  /**
   * RequestPlatform delete
   */
  export type RequestPlatformDeleteArgs = {
    /**
     * Select specific fields to fetch from the RequestPlatform
     * 
    **/
    select?: RequestPlatformSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestPlatformInclude | null
    /**
     * Filter which RequestPlatform to delete.
     * 
    **/
    where: RequestPlatformWhereUniqueInput
  }


  /**
   * RequestPlatform deleteMany
   */
  export type RequestPlatformDeleteManyArgs = {
    /**
     * Filter which RequestPlatforms to delete
     * 
    **/
    where?: RequestPlatformWhereInput
  }


  /**
   * RequestPlatform: findUniqueOrThrow
   */
  export type RequestPlatformFindUniqueOrThrowArgs = RequestPlatformFindUniqueArgsBase
      

  /**
   * RequestPlatform: findFirstOrThrow
   */
  export type RequestPlatformFindFirstOrThrowArgs = RequestPlatformFindFirstArgsBase
      

  /**
   * RequestPlatform without action
   */
  export type RequestPlatformArgs = {
    /**
     * Select specific fields to fetch from the RequestPlatform
     * 
    **/
    select?: RequestPlatformSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestPlatformInclude | null
  }



  /**
   * Model RequestApplyCreator
   */


  export type AggregateRequestApplyCreator = {
    _count: RequestApplyCreatorCountAggregateOutputType | null
    _avg: RequestApplyCreatorAvgAggregateOutputType | null
    _sum: RequestApplyCreatorSumAggregateOutputType | null
    _min: RequestApplyCreatorMinAggregateOutputType | null
    _max: RequestApplyCreatorMaxAggregateOutputType | null
  }

  export type RequestApplyCreatorAvgAggregateOutputType = {
    id: number | null
    requestId: number | null
    creatorId: number | null
  }

  export type RequestApplyCreatorSumAggregateOutputType = {
    id: bigint | null
    requestId: bigint | null
    creatorId: bigint | null
  }

  export type RequestApplyCreatorMinAggregateOutputType = {
    id: bigint | null
    requestId: bigint | null
    creatorId: bigint | null
  }

  export type RequestApplyCreatorMaxAggregateOutputType = {
    id: bigint | null
    requestId: bigint | null
    creatorId: bigint | null
  }

  export type RequestApplyCreatorCountAggregateOutputType = {
    id: number
    requestId: number
    creatorId: number
    _all: number
  }


  export type RequestApplyCreatorAvgAggregateInputType = {
    id?: true
    requestId?: true
    creatorId?: true
  }

  export type RequestApplyCreatorSumAggregateInputType = {
    id?: true
    requestId?: true
    creatorId?: true
  }

  export type RequestApplyCreatorMinAggregateInputType = {
    id?: true
    requestId?: true
    creatorId?: true
  }

  export type RequestApplyCreatorMaxAggregateInputType = {
    id?: true
    requestId?: true
    creatorId?: true
  }

  export type RequestApplyCreatorCountAggregateInputType = {
    id?: true
    requestId?: true
    creatorId?: true
    _all?: true
  }

  export type RequestApplyCreatorAggregateArgs = {
    /**
     * Filter which RequestApplyCreator to aggregate.
     * 
    **/
    where?: RequestApplyCreatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestApplyCreators to fetch.
     * 
    **/
    orderBy?: Enumerable<RequestApplyCreatorOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: RequestApplyCreatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestApplyCreators from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestApplyCreators.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RequestApplyCreators
    **/
    _count?: true | RequestApplyCreatorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RequestApplyCreatorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RequestApplyCreatorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RequestApplyCreatorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RequestApplyCreatorMaxAggregateInputType
  }

  export type GetRequestApplyCreatorAggregateType<T extends RequestApplyCreatorAggregateArgs> = {
        [P in keyof T & keyof AggregateRequestApplyCreator]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequestApplyCreator[P]>
      : GetScalarType<T[P], AggregateRequestApplyCreator[P]>
  }




  export type RequestApplyCreatorGroupByArgs = {
    where?: RequestApplyCreatorWhereInput
    orderBy?: Enumerable<RequestApplyCreatorOrderByWithAggregationInput>
    by: Array<RequestApplyCreatorScalarFieldEnum>
    having?: RequestApplyCreatorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RequestApplyCreatorCountAggregateInputType | true
    _avg?: RequestApplyCreatorAvgAggregateInputType
    _sum?: RequestApplyCreatorSumAggregateInputType
    _min?: RequestApplyCreatorMinAggregateInputType
    _max?: RequestApplyCreatorMaxAggregateInputType
  }


  export type RequestApplyCreatorGroupByOutputType = {
    id: bigint
    requestId: bigint
    creatorId: bigint | null
    _count: RequestApplyCreatorCountAggregateOutputType | null
    _avg: RequestApplyCreatorAvgAggregateOutputType | null
    _sum: RequestApplyCreatorSumAggregateOutputType | null
    _min: RequestApplyCreatorMinAggregateOutputType | null
    _max: RequestApplyCreatorMaxAggregateOutputType | null
  }

  type GetRequestApplyCreatorGroupByPayload<T extends RequestApplyCreatorGroupByArgs> = PrismaPromise<
    Array<
      PickArray<RequestApplyCreatorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RequestApplyCreatorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RequestApplyCreatorGroupByOutputType[P]>
            : GetScalarType<T[P], RequestApplyCreatorGroupByOutputType[P]>
        }
      >
    >


  export type RequestApplyCreatorSelect = {
    id?: boolean
    request?: boolean | RequestPostArgs
    requestId?: boolean
    creator?: boolean | CreatorArgs
    creatorId?: boolean
  }

  export type RequestApplyCreatorInclude = {
    request?: boolean | RequestPostArgs
    creator?: boolean | CreatorArgs
  }

  export type RequestApplyCreatorGetPayload<
    S extends boolean | null | undefined | RequestApplyCreatorArgs,
    U = keyof S
      > = S extends true
        ? RequestApplyCreator
    : S extends undefined
    ? never
    : S extends RequestApplyCreatorArgs | RequestApplyCreatorFindManyArgs
    ?'include' extends U
    ? RequestApplyCreator  & {
    [P in TrueKeys<S['include']>]:
        P extends 'request' ? RequestPostGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'creator' ? CreatorGetPayload<Exclude<S['include'], undefined | null>[P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'request' ? RequestPostGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'creator' ? CreatorGetPayload<Exclude<S['select'], undefined | null>[P]> | null :  P extends keyof RequestApplyCreator ? RequestApplyCreator[P] : never
  } 
    : RequestApplyCreator
  : RequestApplyCreator


  type RequestApplyCreatorCountArgs = Merge<
    Omit<RequestApplyCreatorFindManyArgs, 'select' | 'include'> & {
      select?: RequestApplyCreatorCountAggregateInputType | true
    }
  >

  export interface RequestApplyCreatorDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one RequestApplyCreator that matches the filter.
     * @param {RequestApplyCreatorFindUniqueArgs} args - Arguments to find a RequestApplyCreator
     * @example
     * // Get one RequestApplyCreator
     * const requestApplyCreator = await prisma.requestApplyCreator.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RequestApplyCreatorFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RequestApplyCreatorFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RequestApplyCreator'> extends True ? CheckSelect<T, Prisma__RequestApplyCreatorClient<RequestApplyCreator>, Prisma__RequestApplyCreatorClient<RequestApplyCreatorGetPayload<T>>> : CheckSelect<T, Prisma__RequestApplyCreatorClient<RequestApplyCreator | null, null>, Prisma__RequestApplyCreatorClient<RequestApplyCreatorGetPayload<T> | null, null>>

    /**
     * Find the first RequestApplyCreator that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestApplyCreatorFindFirstArgs} args - Arguments to find a RequestApplyCreator
     * @example
     * // Get one RequestApplyCreator
     * const requestApplyCreator = await prisma.requestApplyCreator.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RequestApplyCreatorFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RequestApplyCreatorFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RequestApplyCreator'> extends True ? CheckSelect<T, Prisma__RequestApplyCreatorClient<RequestApplyCreator>, Prisma__RequestApplyCreatorClient<RequestApplyCreatorGetPayload<T>>> : CheckSelect<T, Prisma__RequestApplyCreatorClient<RequestApplyCreator | null, null>, Prisma__RequestApplyCreatorClient<RequestApplyCreatorGetPayload<T> | null, null>>

    /**
     * Find zero or more RequestApplyCreators that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestApplyCreatorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RequestApplyCreators
     * const requestApplyCreators = await prisma.requestApplyCreator.findMany()
     * 
     * // Get first 10 RequestApplyCreators
     * const requestApplyCreators = await prisma.requestApplyCreator.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const requestApplyCreatorWithIdOnly = await prisma.requestApplyCreator.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RequestApplyCreatorFindManyArgs>(
      args?: SelectSubset<T, RequestApplyCreatorFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<RequestApplyCreator>>, PrismaPromise<Array<RequestApplyCreatorGetPayload<T>>>>

    /**
     * Create a RequestApplyCreator.
     * @param {RequestApplyCreatorCreateArgs} args - Arguments to create a RequestApplyCreator.
     * @example
     * // Create one RequestApplyCreator
     * const RequestApplyCreator = await prisma.requestApplyCreator.create({
     *   data: {
     *     // ... data to create a RequestApplyCreator
     *   }
     * })
     * 
    **/
    create<T extends RequestApplyCreatorCreateArgs>(
      args: SelectSubset<T, RequestApplyCreatorCreateArgs>
    ): CheckSelect<T, Prisma__RequestApplyCreatorClient<RequestApplyCreator>, Prisma__RequestApplyCreatorClient<RequestApplyCreatorGetPayload<T>>>

    /**
     * Create many RequestApplyCreators.
     *     @param {RequestApplyCreatorCreateManyArgs} args - Arguments to create many RequestApplyCreators.
     *     @example
     *     // Create many RequestApplyCreators
     *     const requestApplyCreator = await prisma.requestApplyCreator.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RequestApplyCreatorCreateManyArgs>(
      args?: SelectSubset<T, RequestApplyCreatorCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a RequestApplyCreator.
     * @param {RequestApplyCreatorDeleteArgs} args - Arguments to delete one RequestApplyCreator.
     * @example
     * // Delete one RequestApplyCreator
     * const RequestApplyCreator = await prisma.requestApplyCreator.delete({
     *   where: {
     *     // ... filter to delete one RequestApplyCreator
     *   }
     * })
     * 
    **/
    delete<T extends RequestApplyCreatorDeleteArgs>(
      args: SelectSubset<T, RequestApplyCreatorDeleteArgs>
    ): CheckSelect<T, Prisma__RequestApplyCreatorClient<RequestApplyCreator>, Prisma__RequestApplyCreatorClient<RequestApplyCreatorGetPayload<T>>>

    /**
     * Update one RequestApplyCreator.
     * @param {RequestApplyCreatorUpdateArgs} args - Arguments to update one RequestApplyCreator.
     * @example
     * // Update one RequestApplyCreator
     * const requestApplyCreator = await prisma.requestApplyCreator.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RequestApplyCreatorUpdateArgs>(
      args: SelectSubset<T, RequestApplyCreatorUpdateArgs>
    ): CheckSelect<T, Prisma__RequestApplyCreatorClient<RequestApplyCreator>, Prisma__RequestApplyCreatorClient<RequestApplyCreatorGetPayload<T>>>

    /**
     * Delete zero or more RequestApplyCreators.
     * @param {RequestApplyCreatorDeleteManyArgs} args - Arguments to filter RequestApplyCreators to delete.
     * @example
     * // Delete a few RequestApplyCreators
     * const { count } = await prisma.requestApplyCreator.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RequestApplyCreatorDeleteManyArgs>(
      args?: SelectSubset<T, RequestApplyCreatorDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequestApplyCreators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestApplyCreatorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RequestApplyCreators
     * const requestApplyCreator = await prisma.requestApplyCreator.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RequestApplyCreatorUpdateManyArgs>(
      args: SelectSubset<T, RequestApplyCreatorUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one RequestApplyCreator.
     * @param {RequestApplyCreatorUpsertArgs} args - Arguments to update or create a RequestApplyCreator.
     * @example
     * // Update or create a RequestApplyCreator
     * const requestApplyCreator = await prisma.requestApplyCreator.upsert({
     *   create: {
     *     // ... data to create a RequestApplyCreator
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RequestApplyCreator we want to update
     *   }
     * })
    **/
    upsert<T extends RequestApplyCreatorUpsertArgs>(
      args: SelectSubset<T, RequestApplyCreatorUpsertArgs>
    ): CheckSelect<T, Prisma__RequestApplyCreatorClient<RequestApplyCreator>, Prisma__RequestApplyCreatorClient<RequestApplyCreatorGetPayload<T>>>

    /**
     * Find one RequestApplyCreator that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {RequestApplyCreatorFindUniqueOrThrowArgs} args - Arguments to find a RequestApplyCreator
     * @example
     * // Get one RequestApplyCreator
     * const requestApplyCreator = await prisma.requestApplyCreator.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RequestApplyCreatorFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RequestApplyCreatorFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__RequestApplyCreatorClient<RequestApplyCreator>, Prisma__RequestApplyCreatorClient<RequestApplyCreatorGetPayload<T>>>

    /**
     * Find the first RequestApplyCreator that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestApplyCreatorFindFirstOrThrowArgs} args - Arguments to find a RequestApplyCreator
     * @example
     * // Get one RequestApplyCreator
     * const requestApplyCreator = await prisma.requestApplyCreator.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RequestApplyCreatorFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RequestApplyCreatorFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__RequestApplyCreatorClient<RequestApplyCreator>, Prisma__RequestApplyCreatorClient<RequestApplyCreatorGetPayload<T>>>

    /**
     * Count the number of RequestApplyCreators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestApplyCreatorCountArgs} args - Arguments to filter RequestApplyCreators to count.
     * @example
     * // Count the number of RequestApplyCreators
     * const count = await prisma.requestApplyCreator.count({
     *   where: {
     *     // ... the filter for the RequestApplyCreators we want to count
     *   }
     * })
    **/
    count<T extends RequestApplyCreatorCountArgs>(
      args?: Subset<T, RequestApplyCreatorCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequestApplyCreatorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RequestApplyCreator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestApplyCreatorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequestApplyCreatorAggregateArgs>(args: Subset<T, RequestApplyCreatorAggregateArgs>): PrismaPromise<GetRequestApplyCreatorAggregateType<T>>

    /**
     * Group by RequestApplyCreator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestApplyCreatorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RequestApplyCreatorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RequestApplyCreatorGroupByArgs['orderBy'] }
        : { orderBy?: RequestApplyCreatorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RequestApplyCreatorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequestApplyCreatorGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for RequestApplyCreator.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RequestApplyCreatorClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    request<T extends RequestPostArgs = {}>(args?: Subset<T, RequestPostArgs>): CheckSelect<T, Prisma__RequestPostClient<RequestPost | Null>, Prisma__RequestPostClient<RequestPostGetPayload<T> | Null>>;

    creator<T extends CreatorArgs = {}>(args?: Subset<T, CreatorArgs>): CheckSelect<T, Prisma__CreatorClient<Creator | Null>, Prisma__CreatorClient<CreatorGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * RequestApplyCreator base type for findUnique actions
   */
  export type RequestApplyCreatorFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the RequestApplyCreator
     * 
    **/
    select?: RequestApplyCreatorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestApplyCreatorInclude | null
    /**
     * Filter, which RequestApplyCreator to fetch.
     * 
    **/
    where: RequestApplyCreatorWhereUniqueInput
  }

  /**
   * RequestApplyCreator: findUnique
   */
  export interface RequestApplyCreatorFindUniqueArgs extends RequestApplyCreatorFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RequestApplyCreator base type for findFirst actions
   */
  export type RequestApplyCreatorFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the RequestApplyCreator
     * 
    **/
    select?: RequestApplyCreatorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestApplyCreatorInclude | null
    /**
     * Filter, which RequestApplyCreator to fetch.
     * 
    **/
    where?: RequestApplyCreatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestApplyCreators to fetch.
     * 
    **/
    orderBy?: Enumerable<RequestApplyCreatorOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RequestApplyCreators.
     * 
    **/
    cursor?: RequestApplyCreatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestApplyCreators from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestApplyCreators.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RequestApplyCreators.
     * 
    **/
    distinct?: Enumerable<RequestApplyCreatorScalarFieldEnum>
  }

  /**
   * RequestApplyCreator: findFirst
   */
  export interface RequestApplyCreatorFindFirstArgs extends RequestApplyCreatorFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RequestApplyCreator findMany
   */
  export type RequestApplyCreatorFindManyArgs = {
    /**
     * Select specific fields to fetch from the RequestApplyCreator
     * 
    **/
    select?: RequestApplyCreatorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestApplyCreatorInclude | null
    /**
     * Filter, which RequestApplyCreators to fetch.
     * 
    **/
    where?: RequestApplyCreatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestApplyCreators to fetch.
     * 
    **/
    orderBy?: Enumerable<RequestApplyCreatorOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RequestApplyCreators.
     * 
    **/
    cursor?: RequestApplyCreatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestApplyCreators from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestApplyCreators.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RequestApplyCreatorScalarFieldEnum>
  }


  /**
   * RequestApplyCreator create
   */
  export type RequestApplyCreatorCreateArgs = {
    /**
     * Select specific fields to fetch from the RequestApplyCreator
     * 
    **/
    select?: RequestApplyCreatorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestApplyCreatorInclude | null
    /**
     * The data needed to create a RequestApplyCreator.
     * 
    **/
    data: XOR<RequestApplyCreatorCreateInput, RequestApplyCreatorUncheckedCreateInput>
  }


  /**
   * RequestApplyCreator createMany
   */
  export type RequestApplyCreatorCreateManyArgs = {
    /**
     * The data used to create many RequestApplyCreators.
     * 
    **/
    data: Enumerable<RequestApplyCreatorCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * RequestApplyCreator update
   */
  export type RequestApplyCreatorUpdateArgs = {
    /**
     * Select specific fields to fetch from the RequestApplyCreator
     * 
    **/
    select?: RequestApplyCreatorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestApplyCreatorInclude | null
    /**
     * The data needed to update a RequestApplyCreator.
     * 
    **/
    data: XOR<RequestApplyCreatorUpdateInput, RequestApplyCreatorUncheckedUpdateInput>
    /**
     * Choose, which RequestApplyCreator to update.
     * 
    **/
    where: RequestApplyCreatorWhereUniqueInput
  }


  /**
   * RequestApplyCreator updateMany
   */
  export type RequestApplyCreatorUpdateManyArgs = {
    /**
     * The data used to update RequestApplyCreators.
     * 
    **/
    data: XOR<RequestApplyCreatorUpdateManyMutationInput, RequestApplyCreatorUncheckedUpdateManyInput>
    /**
     * Filter which RequestApplyCreators to update
     * 
    **/
    where?: RequestApplyCreatorWhereInput
  }


  /**
   * RequestApplyCreator upsert
   */
  export type RequestApplyCreatorUpsertArgs = {
    /**
     * Select specific fields to fetch from the RequestApplyCreator
     * 
    **/
    select?: RequestApplyCreatorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestApplyCreatorInclude | null
    /**
     * The filter to search for the RequestApplyCreator to update in case it exists.
     * 
    **/
    where: RequestApplyCreatorWhereUniqueInput
    /**
     * In case the RequestApplyCreator found by the `where` argument doesn't exist, create a new RequestApplyCreator with this data.
     * 
    **/
    create: XOR<RequestApplyCreatorCreateInput, RequestApplyCreatorUncheckedCreateInput>
    /**
     * In case the RequestApplyCreator was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<RequestApplyCreatorUpdateInput, RequestApplyCreatorUncheckedUpdateInput>
  }


  /**
   * RequestApplyCreator delete
   */
  export type RequestApplyCreatorDeleteArgs = {
    /**
     * Select specific fields to fetch from the RequestApplyCreator
     * 
    **/
    select?: RequestApplyCreatorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestApplyCreatorInclude | null
    /**
     * Filter which RequestApplyCreator to delete.
     * 
    **/
    where: RequestApplyCreatorWhereUniqueInput
  }


  /**
   * RequestApplyCreator deleteMany
   */
  export type RequestApplyCreatorDeleteManyArgs = {
    /**
     * Filter which RequestApplyCreators to delete
     * 
    **/
    where?: RequestApplyCreatorWhereInput
  }


  /**
   * RequestApplyCreator: findUniqueOrThrow
   */
  export type RequestApplyCreatorFindUniqueOrThrowArgs = RequestApplyCreatorFindUniqueArgsBase
      

  /**
   * RequestApplyCreator: findFirstOrThrow
   */
  export type RequestApplyCreatorFindFirstOrThrowArgs = RequestApplyCreatorFindFirstArgsBase
      

  /**
   * RequestApplyCreator without action
   */
  export type RequestApplyCreatorArgs = {
    /**
     * Select specific fields to fetch from the RequestApplyCreator
     * 
    **/
    select?: RequestApplyCreatorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestApplyCreatorInclude | null
  }



  /**
   * Model RequestReport
   */


  export type AggregateRequestReport = {
    _count: RequestReportCountAggregateOutputType | null
    _avg: RequestReportAvgAggregateOutputType | null
    _sum: RequestReportSumAggregateOutputType | null
    _min: RequestReportMinAggregateOutputType | null
    _max: RequestReportMaxAggregateOutputType | null
  }

  export type RequestReportAvgAggregateOutputType = {
    id: number | null
    requestId: number | null
  }

  export type RequestReportSumAggregateOutputType = {
    id: bigint | null
    requestId: bigint | null
  }

  export type RequestReportMinAggregateOutputType = {
    id: bigint | null
    requestId: bigint | null
    userId: string | null
    content: string | null
    type: RequestReportType | null
    status: RequestReportStatus | null
    createdAt: Date | null
  }

  export type RequestReportMaxAggregateOutputType = {
    id: bigint | null
    requestId: bigint | null
    userId: string | null
    content: string | null
    type: RequestReportType | null
    status: RequestReportStatus | null
    createdAt: Date | null
  }

  export type RequestReportCountAggregateOutputType = {
    id: number
    requestId: number
    userId: number
    content: number
    type: number
    status: number
    createdAt: number
    _all: number
  }


  export type RequestReportAvgAggregateInputType = {
    id?: true
    requestId?: true
  }

  export type RequestReportSumAggregateInputType = {
    id?: true
    requestId?: true
  }

  export type RequestReportMinAggregateInputType = {
    id?: true
    requestId?: true
    userId?: true
    content?: true
    type?: true
    status?: true
    createdAt?: true
  }

  export type RequestReportMaxAggregateInputType = {
    id?: true
    requestId?: true
    userId?: true
    content?: true
    type?: true
    status?: true
    createdAt?: true
  }

  export type RequestReportCountAggregateInputType = {
    id?: true
    requestId?: true
    userId?: true
    content?: true
    type?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type RequestReportAggregateArgs = {
    /**
     * Filter which RequestReport to aggregate.
     * 
    **/
    where?: RequestReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestReports to fetch.
     * 
    **/
    orderBy?: Enumerable<RequestReportOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: RequestReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestReports from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestReports.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RequestReports
    **/
    _count?: true | RequestReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RequestReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RequestReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RequestReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RequestReportMaxAggregateInputType
  }

  export type GetRequestReportAggregateType<T extends RequestReportAggregateArgs> = {
        [P in keyof T & keyof AggregateRequestReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequestReport[P]>
      : GetScalarType<T[P], AggregateRequestReport[P]>
  }




  export type RequestReportGroupByArgs = {
    where?: RequestReportWhereInput
    orderBy?: Enumerable<RequestReportOrderByWithAggregationInput>
    by: Array<RequestReportScalarFieldEnum>
    having?: RequestReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RequestReportCountAggregateInputType | true
    _avg?: RequestReportAvgAggregateInputType
    _sum?: RequestReportSumAggregateInputType
    _min?: RequestReportMinAggregateInputType
    _max?: RequestReportMaxAggregateInputType
  }


  export type RequestReportGroupByOutputType = {
    id: bigint
    requestId: bigint
    userId: string | null
    content: string
    type: RequestReportType
    status: RequestReportStatus
    createdAt: Date
    _count: RequestReportCountAggregateOutputType | null
    _avg: RequestReportAvgAggregateOutputType | null
    _sum: RequestReportSumAggregateOutputType | null
    _min: RequestReportMinAggregateOutputType | null
    _max: RequestReportMaxAggregateOutputType | null
  }

  type GetRequestReportGroupByPayload<T extends RequestReportGroupByArgs> = PrismaPromise<
    Array<
      PickArray<RequestReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RequestReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RequestReportGroupByOutputType[P]>
            : GetScalarType<T[P], RequestReportGroupByOutputType[P]>
        }
      >
    >


  export type RequestReportSelect = {
    id?: boolean
    request?: boolean | RequestPostArgs
    requestId?: boolean
    user?: boolean | UserArgs
    userId?: boolean
    content?: boolean
    type?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type RequestReportInclude = {
    request?: boolean | RequestPostArgs
    user?: boolean | UserArgs
  }

  export type RequestReportGetPayload<
    S extends boolean | null | undefined | RequestReportArgs,
    U = keyof S
      > = S extends true
        ? RequestReport
    : S extends undefined
    ? never
    : S extends RequestReportArgs | RequestReportFindManyArgs
    ?'include' extends U
    ? RequestReport  & {
    [P in TrueKeys<S['include']>]:
        P extends 'request' ? RequestPostGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'request' ? RequestPostGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> | null :  P extends keyof RequestReport ? RequestReport[P] : never
  } 
    : RequestReport
  : RequestReport


  type RequestReportCountArgs = Merge<
    Omit<RequestReportFindManyArgs, 'select' | 'include'> & {
      select?: RequestReportCountAggregateInputType | true
    }
  >

  export interface RequestReportDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one RequestReport that matches the filter.
     * @param {RequestReportFindUniqueArgs} args - Arguments to find a RequestReport
     * @example
     * // Get one RequestReport
     * const requestReport = await prisma.requestReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RequestReportFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RequestReportFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RequestReport'> extends True ? CheckSelect<T, Prisma__RequestReportClient<RequestReport>, Prisma__RequestReportClient<RequestReportGetPayload<T>>> : CheckSelect<T, Prisma__RequestReportClient<RequestReport | null, null>, Prisma__RequestReportClient<RequestReportGetPayload<T> | null, null>>

    /**
     * Find the first RequestReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestReportFindFirstArgs} args - Arguments to find a RequestReport
     * @example
     * // Get one RequestReport
     * const requestReport = await prisma.requestReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RequestReportFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RequestReportFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RequestReport'> extends True ? CheckSelect<T, Prisma__RequestReportClient<RequestReport>, Prisma__RequestReportClient<RequestReportGetPayload<T>>> : CheckSelect<T, Prisma__RequestReportClient<RequestReport | null, null>, Prisma__RequestReportClient<RequestReportGetPayload<T> | null, null>>

    /**
     * Find zero or more RequestReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestReportFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RequestReports
     * const requestReports = await prisma.requestReport.findMany()
     * 
     * // Get first 10 RequestReports
     * const requestReports = await prisma.requestReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const requestReportWithIdOnly = await prisma.requestReport.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RequestReportFindManyArgs>(
      args?: SelectSubset<T, RequestReportFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<RequestReport>>, PrismaPromise<Array<RequestReportGetPayload<T>>>>

    /**
     * Create a RequestReport.
     * @param {RequestReportCreateArgs} args - Arguments to create a RequestReport.
     * @example
     * // Create one RequestReport
     * const RequestReport = await prisma.requestReport.create({
     *   data: {
     *     // ... data to create a RequestReport
     *   }
     * })
     * 
    **/
    create<T extends RequestReportCreateArgs>(
      args: SelectSubset<T, RequestReportCreateArgs>
    ): CheckSelect<T, Prisma__RequestReportClient<RequestReport>, Prisma__RequestReportClient<RequestReportGetPayload<T>>>

    /**
     * Create many RequestReports.
     *     @param {RequestReportCreateManyArgs} args - Arguments to create many RequestReports.
     *     @example
     *     // Create many RequestReports
     *     const requestReport = await prisma.requestReport.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RequestReportCreateManyArgs>(
      args?: SelectSubset<T, RequestReportCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a RequestReport.
     * @param {RequestReportDeleteArgs} args - Arguments to delete one RequestReport.
     * @example
     * // Delete one RequestReport
     * const RequestReport = await prisma.requestReport.delete({
     *   where: {
     *     // ... filter to delete one RequestReport
     *   }
     * })
     * 
    **/
    delete<T extends RequestReportDeleteArgs>(
      args: SelectSubset<T, RequestReportDeleteArgs>
    ): CheckSelect<T, Prisma__RequestReportClient<RequestReport>, Prisma__RequestReportClient<RequestReportGetPayload<T>>>

    /**
     * Update one RequestReport.
     * @param {RequestReportUpdateArgs} args - Arguments to update one RequestReport.
     * @example
     * // Update one RequestReport
     * const requestReport = await prisma.requestReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RequestReportUpdateArgs>(
      args: SelectSubset<T, RequestReportUpdateArgs>
    ): CheckSelect<T, Prisma__RequestReportClient<RequestReport>, Prisma__RequestReportClient<RequestReportGetPayload<T>>>

    /**
     * Delete zero or more RequestReports.
     * @param {RequestReportDeleteManyArgs} args - Arguments to filter RequestReports to delete.
     * @example
     * // Delete a few RequestReports
     * const { count } = await prisma.requestReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RequestReportDeleteManyArgs>(
      args?: SelectSubset<T, RequestReportDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequestReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RequestReports
     * const requestReport = await prisma.requestReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RequestReportUpdateManyArgs>(
      args: SelectSubset<T, RequestReportUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one RequestReport.
     * @param {RequestReportUpsertArgs} args - Arguments to update or create a RequestReport.
     * @example
     * // Update or create a RequestReport
     * const requestReport = await prisma.requestReport.upsert({
     *   create: {
     *     // ... data to create a RequestReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RequestReport we want to update
     *   }
     * })
    **/
    upsert<T extends RequestReportUpsertArgs>(
      args: SelectSubset<T, RequestReportUpsertArgs>
    ): CheckSelect<T, Prisma__RequestReportClient<RequestReport>, Prisma__RequestReportClient<RequestReportGetPayload<T>>>

    /**
     * Find one RequestReport that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {RequestReportFindUniqueOrThrowArgs} args - Arguments to find a RequestReport
     * @example
     * // Get one RequestReport
     * const requestReport = await prisma.requestReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RequestReportFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RequestReportFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__RequestReportClient<RequestReport>, Prisma__RequestReportClient<RequestReportGetPayload<T>>>

    /**
     * Find the first RequestReport that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestReportFindFirstOrThrowArgs} args - Arguments to find a RequestReport
     * @example
     * // Get one RequestReport
     * const requestReport = await prisma.requestReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RequestReportFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RequestReportFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__RequestReportClient<RequestReport>, Prisma__RequestReportClient<RequestReportGetPayload<T>>>

    /**
     * Count the number of RequestReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestReportCountArgs} args - Arguments to filter RequestReports to count.
     * @example
     * // Count the number of RequestReports
     * const count = await prisma.requestReport.count({
     *   where: {
     *     // ... the filter for the RequestReports we want to count
     *   }
     * })
    **/
    count<T extends RequestReportCountArgs>(
      args?: Subset<T, RequestReportCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequestReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RequestReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequestReportAggregateArgs>(args: Subset<T, RequestReportAggregateArgs>): PrismaPromise<GetRequestReportAggregateType<T>>

    /**
     * Group by RequestReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RequestReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RequestReportGroupByArgs['orderBy'] }
        : { orderBy?: RequestReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RequestReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequestReportGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for RequestReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RequestReportClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    request<T extends RequestPostArgs = {}>(args?: Subset<T, RequestPostArgs>): CheckSelect<T, Prisma__RequestPostClient<RequestPost | Null>, Prisma__RequestPostClient<RequestPostGetPayload<T> | Null>>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | Null>, Prisma__UserClient<UserGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * RequestReport base type for findUnique actions
   */
  export type RequestReportFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the RequestReport
     * 
    **/
    select?: RequestReportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestReportInclude | null
    /**
     * Filter, which RequestReport to fetch.
     * 
    **/
    where: RequestReportWhereUniqueInput
  }

  /**
   * RequestReport: findUnique
   */
  export interface RequestReportFindUniqueArgs extends RequestReportFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RequestReport base type for findFirst actions
   */
  export type RequestReportFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the RequestReport
     * 
    **/
    select?: RequestReportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestReportInclude | null
    /**
     * Filter, which RequestReport to fetch.
     * 
    **/
    where?: RequestReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestReports to fetch.
     * 
    **/
    orderBy?: Enumerable<RequestReportOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RequestReports.
     * 
    **/
    cursor?: RequestReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestReports from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestReports.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RequestReports.
     * 
    **/
    distinct?: Enumerable<RequestReportScalarFieldEnum>
  }

  /**
   * RequestReport: findFirst
   */
  export interface RequestReportFindFirstArgs extends RequestReportFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RequestReport findMany
   */
  export type RequestReportFindManyArgs = {
    /**
     * Select specific fields to fetch from the RequestReport
     * 
    **/
    select?: RequestReportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestReportInclude | null
    /**
     * Filter, which RequestReports to fetch.
     * 
    **/
    where?: RequestReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestReports to fetch.
     * 
    **/
    orderBy?: Enumerable<RequestReportOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RequestReports.
     * 
    **/
    cursor?: RequestReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestReports from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestReports.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RequestReportScalarFieldEnum>
  }


  /**
   * RequestReport create
   */
  export type RequestReportCreateArgs = {
    /**
     * Select specific fields to fetch from the RequestReport
     * 
    **/
    select?: RequestReportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestReportInclude | null
    /**
     * The data needed to create a RequestReport.
     * 
    **/
    data: XOR<RequestReportCreateInput, RequestReportUncheckedCreateInput>
  }


  /**
   * RequestReport createMany
   */
  export type RequestReportCreateManyArgs = {
    /**
     * The data used to create many RequestReports.
     * 
    **/
    data: Enumerable<RequestReportCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * RequestReport update
   */
  export type RequestReportUpdateArgs = {
    /**
     * Select specific fields to fetch from the RequestReport
     * 
    **/
    select?: RequestReportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestReportInclude | null
    /**
     * The data needed to update a RequestReport.
     * 
    **/
    data: XOR<RequestReportUpdateInput, RequestReportUncheckedUpdateInput>
    /**
     * Choose, which RequestReport to update.
     * 
    **/
    where: RequestReportWhereUniqueInput
  }


  /**
   * RequestReport updateMany
   */
  export type RequestReportUpdateManyArgs = {
    /**
     * The data used to update RequestReports.
     * 
    **/
    data: XOR<RequestReportUpdateManyMutationInput, RequestReportUncheckedUpdateManyInput>
    /**
     * Filter which RequestReports to update
     * 
    **/
    where?: RequestReportWhereInput
  }


  /**
   * RequestReport upsert
   */
  export type RequestReportUpsertArgs = {
    /**
     * Select specific fields to fetch from the RequestReport
     * 
    **/
    select?: RequestReportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestReportInclude | null
    /**
     * The filter to search for the RequestReport to update in case it exists.
     * 
    **/
    where: RequestReportWhereUniqueInput
    /**
     * In case the RequestReport found by the `where` argument doesn't exist, create a new RequestReport with this data.
     * 
    **/
    create: XOR<RequestReportCreateInput, RequestReportUncheckedCreateInput>
    /**
     * In case the RequestReport was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<RequestReportUpdateInput, RequestReportUncheckedUpdateInput>
  }


  /**
   * RequestReport delete
   */
  export type RequestReportDeleteArgs = {
    /**
     * Select specific fields to fetch from the RequestReport
     * 
    **/
    select?: RequestReportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestReportInclude | null
    /**
     * Filter which RequestReport to delete.
     * 
    **/
    where: RequestReportWhereUniqueInput
  }


  /**
   * RequestReport deleteMany
   */
  export type RequestReportDeleteManyArgs = {
    /**
     * Filter which RequestReports to delete
     * 
    **/
    where?: RequestReportWhereInput
  }


  /**
   * RequestReport: findUniqueOrThrow
   */
  export type RequestReportFindUniqueOrThrowArgs = RequestReportFindUniqueArgsBase
      

  /**
   * RequestReport: findFirstOrThrow
   */
  export type RequestReportFindFirstOrThrowArgs = RequestReportFindFirstArgsBase
      

  /**
   * RequestReport without action
   */
  export type RequestReportArgs = {
    /**
     * Select specific fields to fetch from the RequestReport
     * 
    **/
    select?: RequestReportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestReportInclude | null
  }



  /**
   * Model RequestInquiry
   */


  export type AggregateRequestInquiry = {
    _count: RequestInquiryCountAggregateOutputType | null
    _avg: RequestInquiryAvgAggregateOutputType | null
    _sum: RequestInquirySumAggregateOutputType | null
    _min: RequestInquiryMinAggregateOutputType | null
    _max: RequestInquiryMaxAggregateOutputType | null
  }

  export type RequestInquiryAvgAggregateOutputType = {
    id: number | null
    requestId: number | null
    creatorId: number | null
  }

  export type RequestInquirySumAggregateOutputType = {
    id: bigint | null
    requestId: bigint | null
    creatorId: bigint | null
  }

  export type RequestInquiryMinAggregateOutputType = {
    id: bigint | null
    requestId: bigint | null
    creatorId: bigint | null
    userId: string | null
    createdAt: Date | null
  }

  export type RequestInquiryMaxAggregateOutputType = {
    id: bigint | null
    requestId: bigint | null
    creatorId: bigint | null
    userId: string | null
    createdAt: Date | null
  }

  export type RequestInquiryCountAggregateOutputType = {
    id: number
    requestId: number
    creatorId: number
    userId: number
    createdAt: number
    _all: number
  }


  export type RequestInquiryAvgAggregateInputType = {
    id?: true
    requestId?: true
    creatorId?: true
  }

  export type RequestInquirySumAggregateInputType = {
    id?: true
    requestId?: true
    creatorId?: true
  }

  export type RequestInquiryMinAggregateInputType = {
    id?: true
    requestId?: true
    creatorId?: true
    userId?: true
    createdAt?: true
  }

  export type RequestInquiryMaxAggregateInputType = {
    id?: true
    requestId?: true
    creatorId?: true
    userId?: true
    createdAt?: true
  }

  export type RequestInquiryCountAggregateInputType = {
    id?: true
    requestId?: true
    creatorId?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type RequestInquiryAggregateArgs = {
    /**
     * Filter which RequestInquiry to aggregate.
     * 
    **/
    where?: RequestInquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestInquiries to fetch.
     * 
    **/
    orderBy?: Enumerable<RequestInquiryOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: RequestInquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestInquiries from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestInquiries.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RequestInquiries
    **/
    _count?: true | RequestInquiryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RequestInquiryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RequestInquirySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RequestInquiryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RequestInquiryMaxAggregateInputType
  }

  export type GetRequestInquiryAggregateType<T extends RequestInquiryAggregateArgs> = {
        [P in keyof T & keyof AggregateRequestInquiry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequestInquiry[P]>
      : GetScalarType<T[P], AggregateRequestInquiry[P]>
  }




  export type RequestInquiryGroupByArgs = {
    where?: RequestInquiryWhereInput
    orderBy?: Enumerable<RequestInquiryOrderByWithAggregationInput>
    by: Array<RequestInquiryScalarFieldEnum>
    having?: RequestInquiryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RequestInquiryCountAggregateInputType | true
    _avg?: RequestInquiryAvgAggregateInputType
    _sum?: RequestInquirySumAggregateInputType
    _min?: RequestInquiryMinAggregateInputType
    _max?: RequestInquiryMaxAggregateInputType
  }


  export type RequestInquiryGroupByOutputType = {
    id: bigint
    requestId: bigint
    creatorId: bigint | null
    userId: string | null
    createdAt: Date
    _count: RequestInquiryCountAggregateOutputType | null
    _avg: RequestInquiryAvgAggregateOutputType | null
    _sum: RequestInquirySumAggregateOutputType | null
    _min: RequestInquiryMinAggregateOutputType | null
    _max: RequestInquiryMaxAggregateOutputType | null
  }

  type GetRequestInquiryGroupByPayload<T extends RequestInquiryGroupByArgs> = PrismaPromise<
    Array<
      PickArray<RequestInquiryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RequestInquiryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RequestInquiryGroupByOutputType[P]>
            : GetScalarType<T[P], RequestInquiryGroupByOutputType[P]>
        }
      >
    >


  export type RequestInquirySelect = {
    id?: boolean
    request?: boolean | RequestPostArgs
    requestId?: boolean
    creator?: boolean | CreatorArgs
    creatorId?: boolean
    user?: boolean | UserArgs
    userId?: boolean
    requestInquiryMessages?: boolean | RequestInquiryMessageFindManyArgs
    createdAt?: boolean
    _count?: boolean | RequestInquiryCountOutputTypeArgs
  }

  export type RequestInquiryInclude = {
    request?: boolean | RequestPostArgs
    creator?: boolean | CreatorArgs
    user?: boolean | UserArgs
    requestInquiryMessages?: boolean | RequestInquiryMessageFindManyArgs
    _count?: boolean | RequestInquiryCountOutputTypeArgs
  }

  export type RequestInquiryGetPayload<
    S extends boolean | null | undefined | RequestInquiryArgs,
    U = keyof S
      > = S extends true
        ? RequestInquiry
    : S extends undefined
    ? never
    : S extends RequestInquiryArgs | RequestInquiryFindManyArgs
    ?'include' extends U
    ? RequestInquiry  & {
    [P in TrueKeys<S['include']>]:
        P extends 'request' ? RequestPostGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'creator' ? CreatorGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'requestInquiryMessages' ? Array < RequestInquiryMessageGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? RequestInquiryCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'request' ? RequestPostGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'creator' ? CreatorGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'requestInquiryMessages' ? Array < RequestInquiryMessageGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? RequestInquiryCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof RequestInquiry ? RequestInquiry[P] : never
  } 
    : RequestInquiry
  : RequestInquiry


  type RequestInquiryCountArgs = Merge<
    Omit<RequestInquiryFindManyArgs, 'select' | 'include'> & {
      select?: RequestInquiryCountAggregateInputType | true
    }
  >

  export interface RequestInquiryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one RequestInquiry that matches the filter.
     * @param {RequestInquiryFindUniqueArgs} args - Arguments to find a RequestInquiry
     * @example
     * // Get one RequestInquiry
     * const requestInquiry = await prisma.requestInquiry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RequestInquiryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RequestInquiryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RequestInquiry'> extends True ? CheckSelect<T, Prisma__RequestInquiryClient<RequestInquiry>, Prisma__RequestInquiryClient<RequestInquiryGetPayload<T>>> : CheckSelect<T, Prisma__RequestInquiryClient<RequestInquiry | null, null>, Prisma__RequestInquiryClient<RequestInquiryGetPayload<T> | null, null>>

    /**
     * Find the first RequestInquiry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestInquiryFindFirstArgs} args - Arguments to find a RequestInquiry
     * @example
     * // Get one RequestInquiry
     * const requestInquiry = await prisma.requestInquiry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RequestInquiryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RequestInquiryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RequestInquiry'> extends True ? CheckSelect<T, Prisma__RequestInquiryClient<RequestInquiry>, Prisma__RequestInquiryClient<RequestInquiryGetPayload<T>>> : CheckSelect<T, Prisma__RequestInquiryClient<RequestInquiry | null, null>, Prisma__RequestInquiryClient<RequestInquiryGetPayload<T> | null, null>>

    /**
     * Find zero or more RequestInquiries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestInquiryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RequestInquiries
     * const requestInquiries = await prisma.requestInquiry.findMany()
     * 
     * // Get first 10 RequestInquiries
     * const requestInquiries = await prisma.requestInquiry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const requestInquiryWithIdOnly = await prisma.requestInquiry.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RequestInquiryFindManyArgs>(
      args?: SelectSubset<T, RequestInquiryFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<RequestInquiry>>, PrismaPromise<Array<RequestInquiryGetPayload<T>>>>

    /**
     * Create a RequestInquiry.
     * @param {RequestInquiryCreateArgs} args - Arguments to create a RequestInquiry.
     * @example
     * // Create one RequestInquiry
     * const RequestInquiry = await prisma.requestInquiry.create({
     *   data: {
     *     // ... data to create a RequestInquiry
     *   }
     * })
     * 
    **/
    create<T extends RequestInquiryCreateArgs>(
      args: SelectSubset<T, RequestInquiryCreateArgs>
    ): CheckSelect<T, Prisma__RequestInquiryClient<RequestInquiry>, Prisma__RequestInquiryClient<RequestInquiryGetPayload<T>>>

    /**
     * Create many RequestInquiries.
     *     @param {RequestInquiryCreateManyArgs} args - Arguments to create many RequestInquiries.
     *     @example
     *     // Create many RequestInquiries
     *     const requestInquiry = await prisma.requestInquiry.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RequestInquiryCreateManyArgs>(
      args?: SelectSubset<T, RequestInquiryCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a RequestInquiry.
     * @param {RequestInquiryDeleteArgs} args - Arguments to delete one RequestInquiry.
     * @example
     * // Delete one RequestInquiry
     * const RequestInquiry = await prisma.requestInquiry.delete({
     *   where: {
     *     // ... filter to delete one RequestInquiry
     *   }
     * })
     * 
    **/
    delete<T extends RequestInquiryDeleteArgs>(
      args: SelectSubset<T, RequestInquiryDeleteArgs>
    ): CheckSelect<T, Prisma__RequestInquiryClient<RequestInquiry>, Prisma__RequestInquiryClient<RequestInquiryGetPayload<T>>>

    /**
     * Update one RequestInquiry.
     * @param {RequestInquiryUpdateArgs} args - Arguments to update one RequestInquiry.
     * @example
     * // Update one RequestInquiry
     * const requestInquiry = await prisma.requestInquiry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RequestInquiryUpdateArgs>(
      args: SelectSubset<T, RequestInquiryUpdateArgs>
    ): CheckSelect<T, Prisma__RequestInquiryClient<RequestInquiry>, Prisma__RequestInquiryClient<RequestInquiryGetPayload<T>>>

    /**
     * Delete zero or more RequestInquiries.
     * @param {RequestInquiryDeleteManyArgs} args - Arguments to filter RequestInquiries to delete.
     * @example
     * // Delete a few RequestInquiries
     * const { count } = await prisma.requestInquiry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RequestInquiryDeleteManyArgs>(
      args?: SelectSubset<T, RequestInquiryDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequestInquiries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestInquiryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RequestInquiries
     * const requestInquiry = await prisma.requestInquiry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RequestInquiryUpdateManyArgs>(
      args: SelectSubset<T, RequestInquiryUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one RequestInquiry.
     * @param {RequestInquiryUpsertArgs} args - Arguments to update or create a RequestInquiry.
     * @example
     * // Update or create a RequestInquiry
     * const requestInquiry = await prisma.requestInquiry.upsert({
     *   create: {
     *     // ... data to create a RequestInquiry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RequestInquiry we want to update
     *   }
     * })
    **/
    upsert<T extends RequestInquiryUpsertArgs>(
      args: SelectSubset<T, RequestInquiryUpsertArgs>
    ): CheckSelect<T, Prisma__RequestInquiryClient<RequestInquiry>, Prisma__RequestInquiryClient<RequestInquiryGetPayload<T>>>

    /**
     * Find one RequestInquiry that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {RequestInquiryFindUniqueOrThrowArgs} args - Arguments to find a RequestInquiry
     * @example
     * // Get one RequestInquiry
     * const requestInquiry = await prisma.requestInquiry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RequestInquiryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RequestInquiryFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__RequestInquiryClient<RequestInquiry>, Prisma__RequestInquiryClient<RequestInquiryGetPayload<T>>>

    /**
     * Find the first RequestInquiry that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestInquiryFindFirstOrThrowArgs} args - Arguments to find a RequestInquiry
     * @example
     * // Get one RequestInquiry
     * const requestInquiry = await prisma.requestInquiry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RequestInquiryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RequestInquiryFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__RequestInquiryClient<RequestInquiry>, Prisma__RequestInquiryClient<RequestInquiryGetPayload<T>>>

    /**
     * Count the number of RequestInquiries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestInquiryCountArgs} args - Arguments to filter RequestInquiries to count.
     * @example
     * // Count the number of RequestInquiries
     * const count = await prisma.requestInquiry.count({
     *   where: {
     *     // ... the filter for the RequestInquiries we want to count
     *   }
     * })
    **/
    count<T extends RequestInquiryCountArgs>(
      args?: Subset<T, RequestInquiryCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequestInquiryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RequestInquiry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestInquiryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequestInquiryAggregateArgs>(args: Subset<T, RequestInquiryAggregateArgs>): PrismaPromise<GetRequestInquiryAggregateType<T>>

    /**
     * Group by RequestInquiry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestInquiryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RequestInquiryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RequestInquiryGroupByArgs['orderBy'] }
        : { orderBy?: RequestInquiryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RequestInquiryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequestInquiryGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for RequestInquiry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RequestInquiryClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    request<T extends RequestPostArgs = {}>(args?: Subset<T, RequestPostArgs>): CheckSelect<T, Prisma__RequestPostClient<RequestPost | Null>, Prisma__RequestPostClient<RequestPostGetPayload<T> | Null>>;

    creator<T extends CreatorArgs = {}>(args?: Subset<T, CreatorArgs>): CheckSelect<T, Prisma__CreatorClient<Creator | Null>, Prisma__CreatorClient<CreatorGetPayload<T> | Null>>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | Null>, Prisma__UserClient<UserGetPayload<T> | Null>>;

    requestInquiryMessages<T extends RequestInquiryMessageFindManyArgs = {}>(args?: Subset<T, RequestInquiryMessageFindManyArgs>): CheckSelect<T, PrismaPromise<Array<RequestInquiryMessage>| Null>, PrismaPromise<Array<RequestInquiryMessageGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * RequestInquiry base type for findUnique actions
   */
  export type RequestInquiryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the RequestInquiry
     * 
    **/
    select?: RequestInquirySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestInquiryInclude | null
    /**
     * Filter, which RequestInquiry to fetch.
     * 
    **/
    where: RequestInquiryWhereUniqueInput
  }

  /**
   * RequestInquiry: findUnique
   */
  export interface RequestInquiryFindUniqueArgs extends RequestInquiryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RequestInquiry base type for findFirst actions
   */
  export type RequestInquiryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the RequestInquiry
     * 
    **/
    select?: RequestInquirySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestInquiryInclude | null
    /**
     * Filter, which RequestInquiry to fetch.
     * 
    **/
    where?: RequestInquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestInquiries to fetch.
     * 
    **/
    orderBy?: Enumerable<RequestInquiryOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RequestInquiries.
     * 
    **/
    cursor?: RequestInquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestInquiries from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestInquiries.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RequestInquiries.
     * 
    **/
    distinct?: Enumerable<RequestInquiryScalarFieldEnum>
  }

  /**
   * RequestInquiry: findFirst
   */
  export interface RequestInquiryFindFirstArgs extends RequestInquiryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RequestInquiry findMany
   */
  export type RequestInquiryFindManyArgs = {
    /**
     * Select specific fields to fetch from the RequestInquiry
     * 
    **/
    select?: RequestInquirySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestInquiryInclude | null
    /**
     * Filter, which RequestInquiries to fetch.
     * 
    **/
    where?: RequestInquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestInquiries to fetch.
     * 
    **/
    orderBy?: Enumerable<RequestInquiryOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RequestInquiries.
     * 
    **/
    cursor?: RequestInquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestInquiries from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestInquiries.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RequestInquiryScalarFieldEnum>
  }


  /**
   * RequestInquiry create
   */
  export type RequestInquiryCreateArgs = {
    /**
     * Select specific fields to fetch from the RequestInquiry
     * 
    **/
    select?: RequestInquirySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestInquiryInclude | null
    /**
     * The data needed to create a RequestInquiry.
     * 
    **/
    data: XOR<RequestInquiryCreateInput, RequestInquiryUncheckedCreateInput>
  }


  /**
   * RequestInquiry createMany
   */
  export type RequestInquiryCreateManyArgs = {
    /**
     * The data used to create many RequestInquiries.
     * 
    **/
    data: Enumerable<RequestInquiryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * RequestInquiry update
   */
  export type RequestInquiryUpdateArgs = {
    /**
     * Select specific fields to fetch from the RequestInquiry
     * 
    **/
    select?: RequestInquirySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestInquiryInclude | null
    /**
     * The data needed to update a RequestInquiry.
     * 
    **/
    data: XOR<RequestInquiryUpdateInput, RequestInquiryUncheckedUpdateInput>
    /**
     * Choose, which RequestInquiry to update.
     * 
    **/
    where: RequestInquiryWhereUniqueInput
  }


  /**
   * RequestInquiry updateMany
   */
  export type RequestInquiryUpdateManyArgs = {
    /**
     * The data used to update RequestInquiries.
     * 
    **/
    data: XOR<RequestInquiryUpdateManyMutationInput, RequestInquiryUncheckedUpdateManyInput>
    /**
     * Filter which RequestInquiries to update
     * 
    **/
    where?: RequestInquiryWhereInput
  }


  /**
   * RequestInquiry upsert
   */
  export type RequestInquiryUpsertArgs = {
    /**
     * Select specific fields to fetch from the RequestInquiry
     * 
    **/
    select?: RequestInquirySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestInquiryInclude | null
    /**
     * The filter to search for the RequestInquiry to update in case it exists.
     * 
    **/
    where: RequestInquiryWhereUniqueInput
    /**
     * In case the RequestInquiry found by the `where` argument doesn't exist, create a new RequestInquiry with this data.
     * 
    **/
    create: XOR<RequestInquiryCreateInput, RequestInquiryUncheckedCreateInput>
    /**
     * In case the RequestInquiry was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<RequestInquiryUpdateInput, RequestInquiryUncheckedUpdateInput>
  }


  /**
   * RequestInquiry delete
   */
  export type RequestInquiryDeleteArgs = {
    /**
     * Select specific fields to fetch from the RequestInquiry
     * 
    **/
    select?: RequestInquirySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestInquiryInclude | null
    /**
     * Filter which RequestInquiry to delete.
     * 
    **/
    where: RequestInquiryWhereUniqueInput
  }


  /**
   * RequestInquiry deleteMany
   */
  export type RequestInquiryDeleteManyArgs = {
    /**
     * Filter which RequestInquiries to delete
     * 
    **/
    where?: RequestInquiryWhereInput
  }


  /**
   * RequestInquiry: findUniqueOrThrow
   */
  export type RequestInquiryFindUniqueOrThrowArgs = RequestInquiryFindUniqueArgsBase
      

  /**
   * RequestInquiry: findFirstOrThrow
   */
  export type RequestInquiryFindFirstOrThrowArgs = RequestInquiryFindFirstArgsBase
      

  /**
   * RequestInquiry without action
   */
  export type RequestInquiryArgs = {
    /**
     * Select specific fields to fetch from the RequestInquiry
     * 
    **/
    select?: RequestInquirySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestInquiryInclude | null
  }



  /**
   * Model RequestInquiryMessage
   */


  export type AggregateRequestInquiryMessage = {
    _count: RequestInquiryMessageCountAggregateOutputType | null
    _avg: RequestInquiryMessageAvgAggregateOutputType | null
    _sum: RequestInquiryMessageSumAggregateOutputType | null
    _min: RequestInquiryMessageMinAggregateOutputType | null
    _max: RequestInquiryMessageMaxAggregateOutputType | null
  }

  export type RequestInquiryMessageAvgAggregateOutputType = {
    id: number | null
    roomId: number | null
  }

  export type RequestInquiryMessageSumAggregateOutputType = {
    id: bigint | null
    roomId: bigint | null
  }

  export type RequestInquiryMessageMinAggregateOutputType = {
    id: bigint | null
    roomId: bigint | null
    fromId: string | null
    text: string | null
    fileUrl: string | null
    type: MessageType | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type RequestInquiryMessageMaxAggregateOutputType = {
    id: bigint | null
    roomId: bigint | null
    fromId: string | null
    text: string | null
    fileUrl: string | null
    type: MessageType | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type RequestInquiryMessageCountAggregateOutputType = {
    id: number
    roomId: number
    fromId: number
    text: number
    fileUrl: number
    type: number
    isRead: number
    createdAt: number
    _all: number
  }


  export type RequestInquiryMessageAvgAggregateInputType = {
    id?: true
    roomId?: true
  }

  export type RequestInquiryMessageSumAggregateInputType = {
    id?: true
    roomId?: true
  }

  export type RequestInquiryMessageMinAggregateInputType = {
    id?: true
    roomId?: true
    fromId?: true
    text?: true
    fileUrl?: true
    type?: true
    isRead?: true
    createdAt?: true
  }

  export type RequestInquiryMessageMaxAggregateInputType = {
    id?: true
    roomId?: true
    fromId?: true
    text?: true
    fileUrl?: true
    type?: true
    isRead?: true
    createdAt?: true
  }

  export type RequestInquiryMessageCountAggregateInputType = {
    id?: true
    roomId?: true
    fromId?: true
    text?: true
    fileUrl?: true
    type?: true
    isRead?: true
    createdAt?: true
    _all?: true
  }

  export type RequestInquiryMessageAggregateArgs = {
    /**
     * Filter which RequestInquiryMessage to aggregate.
     * 
    **/
    where?: RequestInquiryMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestInquiryMessages to fetch.
     * 
    **/
    orderBy?: Enumerable<RequestInquiryMessageOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: RequestInquiryMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestInquiryMessages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestInquiryMessages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RequestInquiryMessages
    **/
    _count?: true | RequestInquiryMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RequestInquiryMessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RequestInquiryMessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RequestInquiryMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RequestInquiryMessageMaxAggregateInputType
  }

  export type GetRequestInquiryMessageAggregateType<T extends RequestInquiryMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateRequestInquiryMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequestInquiryMessage[P]>
      : GetScalarType<T[P], AggregateRequestInquiryMessage[P]>
  }




  export type RequestInquiryMessageGroupByArgs = {
    where?: RequestInquiryMessageWhereInput
    orderBy?: Enumerable<RequestInquiryMessageOrderByWithAggregationInput>
    by: Array<RequestInquiryMessageScalarFieldEnum>
    having?: RequestInquiryMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RequestInquiryMessageCountAggregateInputType | true
    _avg?: RequestInquiryMessageAvgAggregateInputType
    _sum?: RequestInquiryMessageSumAggregateInputType
    _min?: RequestInquiryMessageMinAggregateInputType
    _max?: RequestInquiryMessageMaxAggregateInputType
  }


  export type RequestInquiryMessageGroupByOutputType = {
    id: bigint
    roomId: bigint
    fromId: string
    text: string
    fileUrl: string | null
    type: MessageType
    isRead: boolean | null
    createdAt: Date
    _count: RequestInquiryMessageCountAggregateOutputType | null
    _avg: RequestInquiryMessageAvgAggregateOutputType | null
    _sum: RequestInquiryMessageSumAggregateOutputType | null
    _min: RequestInquiryMessageMinAggregateOutputType | null
    _max: RequestInquiryMessageMaxAggregateOutputType | null
  }

  type GetRequestInquiryMessageGroupByPayload<T extends RequestInquiryMessageGroupByArgs> = PrismaPromise<
    Array<
      PickArray<RequestInquiryMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RequestInquiryMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RequestInquiryMessageGroupByOutputType[P]>
            : GetScalarType<T[P], RequestInquiryMessageGroupByOutputType[P]>
        }
      >
    >


  export type RequestInquiryMessageSelect = {
    id?: boolean
    room?: boolean | RequestInquiryArgs
    roomId?: boolean
    from?: boolean | UserArgs
    fromId?: boolean
    text?: boolean
    fileUrl?: boolean
    type?: boolean
    isRead?: boolean
    createdAt?: boolean
  }

  export type RequestInquiryMessageInclude = {
    room?: boolean | RequestInquiryArgs
    from?: boolean | UserArgs
  }

  export type RequestInquiryMessageGetPayload<
    S extends boolean | null | undefined | RequestInquiryMessageArgs,
    U = keyof S
      > = S extends true
        ? RequestInquiryMessage
    : S extends undefined
    ? never
    : S extends RequestInquiryMessageArgs | RequestInquiryMessageFindManyArgs
    ?'include' extends U
    ? RequestInquiryMessage  & {
    [P in TrueKeys<S['include']>]:
        P extends 'room' ? RequestInquiryGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'from' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'room' ? RequestInquiryGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'from' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof RequestInquiryMessage ? RequestInquiryMessage[P] : never
  } 
    : RequestInquiryMessage
  : RequestInquiryMessage


  type RequestInquiryMessageCountArgs = Merge<
    Omit<RequestInquiryMessageFindManyArgs, 'select' | 'include'> & {
      select?: RequestInquiryMessageCountAggregateInputType | true
    }
  >

  export interface RequestInquiryMessageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one RequestInquiryMessage that matches the filter.
     * @param {RequestInquiryMessageFindUniqueArgs} args - Arguments to find a RequestInquiryMessage
     * @example
     * // Get one RequestInquiryMessage
     * const requestInquiryMessage = await prisma.requestInquiryMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RequestInquiryMessageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RequestInquiryMessageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RequestInquiryMessage'> extends True ? CheckSelect<T, Prisma__RequestInquiryMessageClient<RequestInquiryMessage>, Prisma__RequestInquiryMessageClient<RequestInquiryMessageGetPayload<T>>> : CheckSelect<T, Prisma__RequestInquiryMessageClient<RequestInquiryMessage | null, null>, Prisma__RequestInquiryMessageClient<RequestInquiryMessageGetPayload<T> | null, null>>

    /**
     * Find the first RequestInquiryMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestInquiryMessageFindFirstArgs} args - Arguments to find a RequestInquiryMessage
     * @example
     * // Get one RequestInquiryMessage
     * const requestInquiryMessage = await prisma.requestInquiryMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RequestInquiryMessageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RequestInquiryMessageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RequestInquiryMessage'> extends True ? CheckSelect<T, Prisma__RequestInquiryMessageClient<RequestInquiryMessage>, Prisma__RequestInquiryMessageClient<RequestInquiryMessageGetPayload<T>>> : CheckSelect<T, Prisma__RequestInquiryMessageClient<RequestInquiryMessage | null, null>, Prisma__RequestInquiryMessageClient<RequestInquiryMessageGetPayload<T> | null, null>>

    /**
     * Find zero or more RequestInquiryMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestInquiryMessageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RequestInquiryMessages
     * const requestInquiryMessages = await prisma.requestInquiryMessage.findMany()
     * 
     * // Get first 10 RequestInquiryMessages
     * const requestInquiryMessages = await prisma.requestInquiryMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const requestInquiryMessageWithIdOnly = await prisma.requestInquiryMessage.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RequestInquiryMessageFindManyArgs>(
      args?: SelectSubset<T, RequestInquiryMessageFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<RequestInquiryMessage>>, PrismaPromise<Array<RequestInquiryMessageGetPayload<T>>>>

    /**
     * Create a RequestInquiryMessage.
     * @param {RequestInquiryMessageCreateArgs} args - Arguments to create a RequestInquiryMessage.
     * @example
     * // Create one RequestInquiryMessage
     * const RequestInquiryMessage = await prisma.requestInquiryMessage.create({
     *   data: {
     *     // ... data to create a RequestInquiryMessage
     *   }
     * })
     * 
    **/
    create<T extends RequestInquiryMessageCreateArgs>(
      args: SelectSubset<T, RequestInquiryMessageCreateArgs>
    ): CheckSelect<T, Prisma__RequestInquiryMessageClient<RequestInquiryMessage>, Prisma__RequestInquiryMessageClient<RequestInquiryMessageGetPayload<T>>>

    /**
     * Create many RequestInquiryMessages.
     *     @param {RequestInquiryMessageCreateManyArgs} args - Arguments to create many RequestInquiryMessages.
     *     @example
     *     // Create many RequestInquiryMessages
     *     const requestInquiryMessage = await prisma.requestInquiryMessage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RequestInquiryMessageCreateManyArgs>(
      args?: SelectSubset<T, RequestInquiryMessageCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a RequestInquiryMessage.
     * @param {RequestInquiryMessageDeleteArgs} args - Arguments to delete one RequestInquiryMessage.
     * @example
     * // Delete one RequestInquiryMessage
     * const RequestInquiryMessage = await prisma.requestInquiryMessage.delete({
     *   where: {
     *     // ... filter to delete one RequestInquiryMessage
     *   }
     * })
     * 
    **/
    delete<T extends RequestInquiryMessageDeleteArgs>(
      args: SelectSubset<T, RequestInquiryMessageDeleteArgs>
    ): CheckSelect<T, Prisma__RequestInquiryMessageClient<RequestInquiryMessage>, Prisma__RequestInquiryMessageClient<RequestInquiryMessageGetPayload<T>>>

    /**
     * Update one RequestInquiryMessage.
     * @param {RequestInquiryMessageUpdateArgs} args - Arguments to update one RequestInquiryMessage.
     * @example
     * // Update one RequestInquiryMessage
     * const requestInquiryMessage = await prisma.requestInquiryMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RequestInquiryMessageUpdateArgs>(
      args: SelectSubset<T, RequestInquiryMessageUpdateArgs>
    ): CheckSelect<T, Prisma__RequestInquiryMessageClient<RequestInquiryMessage>, Prisma__RequestInquiryMessageClient<RequestInquiryMessageGetPayload<T>>>

    /**
     * Delete zero or more RequestInquiryMessages.
     * @param {RequestInquiryMessageDeleteManyArgs} args - Arguments to filter RequestInquiryMessages to delete.
     * @example
     * // Delete a few RequestInquiryMessages
     * const { count } = await prisma.requestInquiryMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RequestInquiryMessageDeleteManyArgs>(
      args?: SelectSubset<T, RequestInquiryMessageDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequestInquiryMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestInquiryMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RequestInquiryMessages
     * const requestInquiryMessage = await prisma.requestInquiryMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RequestInquiryMessageUpdateManyArgs>(
      args: SelectSubset<T, RequestInquiryMessageUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one RequestInquiryMessage.
     * @param {RequestInquiryMessageUpsertArgs} args - Arguments to update or create a RequestInquiryMessage.
     * @example
     * // Update or create a RequestInquiryMessage
     * const requestInquiryMessage = await prisma.requestInquiryMessage.upsert({
     *   create: {
     *     // ... data to create a RequestInquiryMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RequestInquiryMessage we want to update
     *   }
     * })
    **/
    upsert<T extends RequestInquiryMessageUpsertArgs>(
      args: SelectSubset<T, RequestInquiryMessageUpsertArgs>
    ): CheckSelect<T, Prisma__RequestInquiryMessageClient<RequestInquiryMessage>, Prisma__RequestInquiryMessageClient<RequestInquiryMessageGetPayload<T>>>

    /**
     * Find one RequestInquiryMessage that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {RequestInquiryMessageFindUniqueOrThrowArgs} args - Arguments to find a RequestInquiryMessage
     * @example
     * // Get one RequestInquiryMessage
     * const requestInquiryMessage = await prisma.requestInquiryMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RequestInquiryMessageFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RequestInquiryMessageFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__RequestInquiryMessageClient<RequestInquiryMessage>, Prisma__RequestInquiryMessageClient<RequestInquiryMessageGetPayload<T>>>

    /**
     * Find the first RequestInquiryMessage that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestInquiryMessageFindFirstOrThrowArgs} args - Arguments to find a RequestInquiryMessage
     * @example
     * // Get one RequestInquiryMessage
     * const requestInquiryMessage = await prisma.requestInquiryMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RequestInquiryMessageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RequestInquiryMessageFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__RequestInquiryMessageClient<RequestInquiryMessage>, Prisma__RequestInquiryMessageClient<RequestInquiryMessageGetPayload<T>>>

    /**
     * Count the number of RequestInquiryMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestInquiryMessageCountArgs} args - Arguments to filter RequestInquiryMessages to count.
     * @example
     * // Count the number of RequestInquiryMessages
     * const count = await prisma.requestInquiryMessage.count({
     *   where: {
     *     // ... the filter for the RequestInquiryMessages we want to count
     *   }
     * })
    **/
    count<T extends RequestInquiryMessageCountArgs>(
      args?: Subset<T, RequestInquiryMessageCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequestInquiryMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RequestInquiryMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestInquiryMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequestInquiryMessageAggregateArgs>(args: Subset<T, RequestInquiryMessageAggregateArgs>): PrismaPromise<GetRequestInquiryMessageAggregateType<T>>

    /**
     * Group by RequestInquiryMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestInquiryMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RequestInquiryMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RequestInquiryMessageGroupByArgs['orderBy'] }
        : { orderBy?: RequestInquiryMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RequestInquiryMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequestInquiryMessageGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for RequestInquiryMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RequestInquiryMessageClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    room<T extends RequestInquiryArgs = {}>(args?: Subset<T, RequestInquiryArgs>): CheckSelect<T, Prisma__RequestInquiryClient<RequestInquiry | Null>, Prisma__RequestInquiryClient<RequestInquiryGetPayload<T> | Null>>;

    from<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | Null>, Prisma__UserClient<UserGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * RequestInquiryMessage base type for findUnique actions
   */
  export type RequestInquiryMessageFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the RequestInquiryMessage
     * 
    **/
    select?: RequestInquiryMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestInquiryMessageInclude | null
    /**
     * Filter, which RequestInquiryMessage to fetch.
     * 
    **/
    where: RequestInquiryMessageWhereUniqueInput
  }

  /**
   * RequestInquiryMessage: findUnique
   */
  export interface RequestInquiryMessageFindUniqueArgs extends RequestInquiryMessageFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RequestInquiryMessage base type for findFirst actions
   */
  export type RequestInquiryMessageFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the RequestInquiryMessage
     * 
    **/
    select?: RequestInquiryMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestInquiryMessageInclude | null
    /**
     * Filter, which RequestInquiryMessage to fetch.
     * 
    **/
    where?: RequestInquiryMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestInquiryMessages to fetch.
     * 
    **/
    orderBy?: Enumerable<RequestInquiryMessageOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RequestInquiryMessages.
     * 
    **/
    cursor?: RequestInquiryMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestInquiryMessages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestInquiryMessages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RequestInquiryMessages.
     * 
    **/
    distinct?: Enumerable<RequestInquiryMessageScalarFieldEnum>
  }

  /**
   * RequestInquiryMessage: findFirst
   */
  export interface RequestInquiryMessageFindFirstArgs extends RequestInquiryMessageFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RequestInquiryMessage findMany
   */
  export type RequestInquiryMessageFindManyArgs = {
    /**
     * Select specific fields to fetch from the RequestInquiryMessage
     * 
    **/
    select?: RequestInquiryMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestInquiryMessageInclude | null
    /**
     * Filter, which RequestInquiryMessages to fetch.
     * 
    **/
    where?: RequestInquiryMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestInquiryMessages to fetch.
     * 
    **/
    orderBy?: Enumerable<RequestInquiryMessageOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RequestInquiryMessages.
     * 
    **/
    cursor?: RequestInquiryMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestInquiryMessages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestInquiryMessages.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RequestInquiryMessageScalarFieldEnum>
  }


  /**
   * RequestInquiryMessage create
   */
  export type RequestInquiryMessageCreateArgs = {
    /**
     * Select specific fields to fetch from the RequestInquiryMessage
     * 
    **/
    select?: RequestInquiryMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestInquiryMessageInclude | null
    /**
     * The data needed to create a RequestInquiryMessage.
     * 
    **/
    data: XOR<RequestInquiryMessageCreateInput, RequestInquiryMessageUncheckedCreateInput>
  }


  /**
   * RequestInquiryMessage createMany
   */
  export type RequestInquiryMessageCreateManyArgs = {
    /**
     * The data used to create many RequestInquiryMessages.
     * 
    **/
    data: Enumerable<RequestInquiryMessageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * RequestInquiryMessage update
   */
  export type RequestInquiryMessageUpdateArgs = {
    /**
     * Select specific fields to fetch from the RequestInquiryMessage
     * 
    **/
    select?: RequestInquiryMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestInquiryMessageInclude | null
    /**
     * The data needed to update a RequestInquiryMessage.
     * 
    **/
    data: XOR<RequestInquiryMessageUpdateInput, RequestInquiryMessageUncheckedUpdateInput>
    /**
     * Choose, which RequestInquiryMessage to update.
     * 
    **/
    where: RequestInquiryMessageWhereUniqueInput
  }


  /**
   * RequestInquiryMessage updateMany
   */
  export type RequestInquiryMessageUpdateManyArgs = {
    /**
     * The data used to update RequestInquiryMessages.
     * 
    **/
    data: XOR<RequestInquiryMessageUpdateManyMutationInput, RequestInquiryMessageUncheckedUpdateManyInput>
    /**
     * Filter which RequestInquiryMessages to update
     * 
    **/
    where?: RequestInquiryMessageWhereInput
  }


  /**
   * RequestInquiryMessage upsert
   */
  export type RequestInquiryMessageUpsertArgs = {
    /**
     * Select specific fields to fetch from the RequestInquiryMessage
     * 
    **/
    select?: RequestInquiryMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestInquiryMessageInclude | null
    /**
     * The filter to search for the RequestInquiryMessage to update in case it exists.
     * 
    **/
    where: RequestInquiryMessageWhereUniqueInput
    /**
     * In case the RequestInquiryMessage found by the `where` argument doesn't exist, create a new RequestInquiryMessage with this data.
     * 
    **/
    create: XOR<RequestInquiryMessageCreateInput, RequestInquiryMessageUncheckedCreateInput>
    /**
     * In case the RequestInquiryMessage was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<RequestInquiryMessageUpdateInput, RequestInquiryMessageUncheckedUpdateInput>
  }


  /**
   * RequestInquiryMessage delete
   */
  export type RequestInquiryMessageDeleteArgs = {
    /**
     * Select specific fields to fetch from the RequestInquiryMessage
     * 
    **/
    select?: RequestInquiryMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestInquiryMessageInclude | null
    /**
     * Filter which RequestInquiryMessage to delete.
     * 
    **/
    where: RequestInquiryMessageWhereUniqueInput
  }


  /**
   * RequestInquiryMessage deleteMany
   */
  export type RequestInquiryMessageDeleteManyArgs = {
    /**
     * Filter which RequestInquiryMessages to delete
     * 
    **/
    where?: RequestInquiryMessageWhereInput
  }


  /**
   * RequestInquiryMessage: findUniqueOrThrow
   */
  export type RequestInquiryMessageFindUniqueOrThrowArgs = RequestInquiryMessageFindUniqueArgsBase
      

  /**
   * RequestInquiryMessage: findFirstOrThrow
   */
  export type RequestInquiryMessageFindFirstOrThrowArgs = RequestInquiryMessageFindFirstArgsBase
      

  /**
   * RequestInquiryMessage without action
   */
  export type RequestInquiryMessageArgs = {
    /**
     * Select specific fields to fetch from the RequestInquiryMessage
     * 
    **/
    select?: RequestInquiryMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestInquiryMessageInclude | null
  }



  /**
   * Model Point
   */


  export type AggregatePoint = {
    _count: PointCountAggregateOutputType | null
    _avg: PointAvgAggregateOutputType | null
    _sum: PointSumAggregateOutputType | null
    _min: PointMinAggregateOutputType | null
    _max: PointMaxAggregateOutputType | null
  }

  export type PointAvgAggregateOutputType = {
    id: number | null
    quantity: number | null
  }

  export type PointSumAggregateOutputType = {
    id: bigint | null
    quantity: number | null
  }

  export type PointMinAggregateOutputType = {
    id: bigint | null
    userId: string | null
    quantity: number | null
    type: PoinType | null
    createdAt: Date | null
  }

  export type PointMaxAggregateOutputType = {
    id: bigint | null
    userId: string | null
    quantity: number | null
    type: PoinType | null
    createdAt: Date | null
  }

  export type PointCountAggregateOutputType = {
    id: number
    userId: number
    quantity: number
    type: number
    createdAt: number
    _all: number
  }


  export type PointAvgAggregateInputType = {
    id?: true
    quantity?: true
  }

  export type PointSumAggregateInputType = {
    id?: true
    quantity?: true
  }

  export type PointMinAggregateInputType = {
    id?: true
    userId?: true
    quantity?: true
    type?: true
    createdAt?: true
  }

  export type PointMaxAggregateInputType = {
    id?: true
    userId?: true
    quantity?: true
    type?: true
    createdAt?: true
  }

  export type PointCountAggregateInputType = {
    id?: true
    userId?: true
    quantity?: true
    type?: true
    createdAt?: true
    _all?: true
  }

  export type PointAggregateArgs = {
    /**
     * Filter which Point to aggregate.
     * 
    **/
    where?: PointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Points to fetch.
     * 
    **/
    orderBy?: Enumerable<PointOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Points from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Points.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Points
    **/
    _count?: true | PointCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PointAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PointSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PointMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PointMaxAggregateInputType
  }

  export type GetPointAggregateType<T extends PointAggregateArgs> = {
        [P in keyof T & keyof AggregatePoint]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePoint[P]>
      : GetScalarType<T[P], AggregatePoint[P]>
  }




  export type PointGroupByArgs = {
    where?: PointWhereInput
    orderBy?: Enumerable<PointOrderByWithAggregationInput>
    by: Array<PointScalarFieldEnum>
    having?: PointScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PointCountAggregateInputType | true
    _avg?: PointAvgAggregateInputType
    _sum?: PointSumAggregateInputType
    _min?: PointMinAggregateInputType
    _max?: PointMaxAggregateInputType
  }


  export type PointGroupByOutputType = {
    id: bigint
    userId: string
    quantity: number
    type: PoinType
    createdAt: Date
    _count: PointCountAggregateOutputType | null
    _avg: PointAvgAggregateOutputType | null
    _sum: PointSumAggregateOutputType | null
    _min: PointMinAggregateOutputType | null
    _max: PointMaxAggregateOutputType | null
  }

  type GetPointGroupByPayload<T extends PointGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PointGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PointGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PointGroupByOutputType[P]>
            : GetScalarType<T[P], PointGroupByOutputType[P]>
        }
      >
    >


  export type PointSelect = {
    id?: boolean
    user?: boolean | UserArgs
    userId?: boolean
    quantity?: boolean
    type?: boolean
    createdAt?: boolean
  }

  export type PointInclude = {
    user?: boolean | UserArgs
  }

  export type PointGetPayload<
    S extends boolean | null | undefined | PointArgs,
    U = keyof S
      > = S extends true
        ? Point
    : S extends undefined
    ? never
    : S extends PointArgs | PointFindManyArgs
    ?'include' extends U
    ? Point  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Point ? Point[P] : never
  } 
    : Point
  : Point


  type PointCountArgs = Merge<
    Omit<PointFindManyArgs, 'select' | 'include'> & {
      select?: PointCountAggregateInputType | true
    }
  >

  export interface PointDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Point that matches the filter.
     * @param {PointFindUniqueArgs} args - Arguments to find a Point
     * @example
     * // Get one Point
     * const point = await prisma.point.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PointFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PointFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Point'> extends True ? CheckSelect<T, Prisma__PointClient<Point>, Prisma__PointClient<PointGetPayload<T>>> : CheckSelect<T, Prisma__PointClient<Point | null, null>, Prisma__PointClient<PointGetPayload<T> | null, null>>

    /**
     * Find the first Point that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointFindFirstArgs} args - Arguments to find a Point
     * @example
     * // Get one Point
     * const point = await prisma.point.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PointFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PointFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Point'> extends True ? CheckSelect<T, Prisma__PointClient<Point>, Prisma__PointClient<PointGetPayload<T>>> : CheckSelect<T, Prisma__PointClient<Point | null, null>, Prisma__PointClient<PointGetPayload<T> | null, null>>

    /**
     * Find zero or more Points that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Points
     * const points = await prisma.point.findMany()
     * 
     * // Get first 10 Points
     * const points = await prisma.point.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pointWithIdOnly = await prisma.point.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PointFindManyArgs>(
      args?: SelectSubset<T, PointFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Point>>, PrismaPromise<Array<PointGetPayload<T>>>>

    /**
     * Create a Point.
     * @param {PointCreateArgs} args - Arguments to create a Point.
     * @example
     * // Create one Point
     * const Point = await prisma.point.create({
     *   data: {
     *     // ... data to create a Point
     *   }
     * })
     * 
    **/
    create<T extends PointCreateArgs>(
      args: SelectSubset<T, PointCreateArgs>
    ): CheckSelect<T, Prisma__PointClient<Point>, Prisma__PointClient<PointGetPayload<T>>>

    /**
     * Create many Points.
     *     @param {PointCreateManyArgs} args - Arguments to create many Points.
     *     @example
     *     // Create many Points
     *     const point = await prisma.point.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PointCreateManyArgs>(
      args?: SelectSubset<T, PointCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Point.
     * @param {PointDeleteArgs} args - Arguments to delete one Point.
     * @example
     * // Delete one Point
     * const Point = await prisma.point.delete({
     *   where: {
     *     // ... filter to delete one Point
     *   }
     * })
     * 
    **/
    delete<T extends PointDeleteArgs>(
      args: SelectSubset<T, PointDeleteArgs>
    ): CheckSelect<T, Prisma__PointClient<Point>, Prisma__PointClient<PointGetPayload<T>>>

    /**
     * Update one Point.
     * @param {PointUpdateArgs} args - Arguments to update one Point.
     * @example
     * // Update one Point
     * const point = await prisma.point.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PointUpdateArgs>(
      args: SelectSubset<T, PointUpdateArgs>
    ): CheckSelect<T, Prisma__PointClient<Point>, Prisma__PointClient<PointGetPayload<T>>>

    /**
     * Delete zero or more Points.
     * @param {PointDeleteManyArgs} args - Arguments to filter Points to delete.
     * @example
     * // Delete a few Points
     * const { count } = await prisma.point.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PointDeleteManyArgs>(
      args?: SelectSubset<T, PointDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Points.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Points
     * const point = await prisma.point.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PointUpdateManyArgs>(
      args: SelectSubset<T, PointUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Point.
     * @param {PointUpsertArgs} args - Arguments to update or create a Point.
     * @example
     * // Update or create a Point
     * const point = await prisma.point.upsert({
     *   create: {
     *     // ... data to create a Point
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Point we want to update
     *   }
     * })
    **/
    upsert<T extends PointUpsertArgs>(
      args: SelectSubset<T, PointUpsertArgs>
    ): CheckSelect<T, Prisma__PointClient<Point>, Prisma__PointClient<PointGetPayload<T>>>

    /**
     * Find one Point that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {PointFindUniqueOrThrowArgs} args - Arguments to find a Point
     * @example
     * // Get one Point
     * const point = await prisma.point.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PointFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PointFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__PointClient<Point>, Prisma__PointClient<PointGetPayload<T>>>

    /**
     * Find the first Point that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointFindFirstOrThrowArgs} args - Arguments to find a Point
     * @example
     * // Get one Point
     * const point = await prisma.point.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PointFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PointFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__PointClient<Point>, Prisma__PointClient<PointGetPayload<T>>>

    /**
     * Count the number of Points.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointCountArgs} args - Arguments to filter Points to count.
     * @example
     * // Count the number of Points
     * const count = await prisma.point.count({
     *   where: {
     *     // ... the filter for the Points we want to count
     *   }
     * })
    **/
    count<T extends PointCountArgs>(
      args?: Subset<T, PointCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PointCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Point.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PointAggregateArgs>(args: Subset<T, PointAggregateArgs>): PrismaPromise<GetPointAggregateType<T>>

    /**
     * Group by Point.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PointGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PointGroupByArgs['orderBy'] }
        : { orderBy?: PointGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PointGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPointGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Point.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PointClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | Null>, Prisma__UserClient<UserGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Point base type for findUnique actions
   */
  export type PointFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Point
     * 
    **/
    select?: PointSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PointInclude | null
    /**
     * Filter, which Point to fetch.
     * 
    **/
    where: PointWhereUniqueInput
  }

  /**
   * Point: findUnique
   */
  export interface PointFindUniqueArgs extends PointFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Point base type for findFirst actions
   */
  export type PointFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Point
     * 
    **/
    select?: PointSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PointInclude | null
    /**
     * Filter, which Point to fetch.
     * 
    **/
    where?: PointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Points to fetch.
     * 
    **/
    orderBy?: Enumerable<PointOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Points.
     * 
    **/
    cursor?: PointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Points from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Points.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Points.
     * 
    **/
    distinct?: Enumerable<PointScalarFieldEnum>
  }

  /**
   * Point: findFirst
   */
  export interface PointFindFirstArgs extends PointFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Point findMany
   */
  export type PointFindManyArgs = {
    /**
     * Select specific fields to fetch from the Point
     * 
    **/
    select?: PointSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PointInclude | null
    /**
     * Filter, which Points to fetch.
     * 
    **/
    where?: PointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Points to fetch.
     * 
    **/
    orderBy?: Enumerable<PointOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Points.
     * 
    **/
    cursor?: PointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Points from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Points.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PointScalarFieldEnum>
  }


  /**
   * Point create
   */
  export type PointCreateArgs = {
    /**
     * Select specific fields to fetch from the Point
     * 
    **/
    select?: PointSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PointInclude | null
    /**
     * The data needed to create a Point.
     * 
    **/
    data: XOR<PointCreateInput, PointUncheckedCreateInput>
  }


  /**
   * Point createMany
   */
  export type PointCreateManyArgs = {
    /**
     * The data used to create many Points.
     * 
    **/
    data: Enumerable<PointCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Point update
   */
  export type PointUpdateArgs = {
    /**
     * Select specific fields to fetch from the Point
     * 
    **/
    select?: PointSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PointInclude | null
    /**
     * The data needed to update a Point.
     * 
    **/
    data: XOR<PointUpdateInput, PointUncheckedUpdateInput>
    /**
     * Choose, which Point to update.
     * 
    **/
    where: PointWhereUniqueInput
  }


  /**
   * Point updateMany
   */
  export type PointUpdateManyArgs = {
    /**
     * The data used to update Points.
     * 
    **/
    data: XOR<PointUpdateManyMutationInput, PointUncheckedUpdateManyInput>
    /**
     * Filter which Points to update
     * 
    **/
    where?: PointWhereInput
  }


  /**
   * Point upsert
   */
  export type PointUpsertArgs = {
    /**
     * Select specific fields to fetch from the Point
     * 
    **/
    select?: PointSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PointInclude | null
    /**
     * The filter to search for the Point to update in case it exists.
     * 
    **/
    where: PointWhereUniqueInput
    /**
     * In case the Point found by the `where` argument doesn't exist, create a new Point with this data.
     * 
    **/
    create: XOR<PointCreateInput, PointUncheckedCreateInput>
    /**
     * In case the Point was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PointUpdateInput, PointUncheckedUpdateInput>
  }


  /**
   * Point delete
   */
  export type PointDeleteArgs = {
    /**
     * Select specific fields to fetch from the Point
     * 
    **/
    select?: PointSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PointInclude | null
    /**
     * Filter which Point to delete.
     * 
    **/
    where: PointWhereUniqueInput
  }


  /**
   * Point deleteMany
   */
  export type PointDeleteManyArgs = {
    /**
     * Filter which Points to delete
     * 
    **/
    where?: PointWhereInput
  }


  /**
   * Point: findUniqueOrThrow
   */
  export type PointFindUniqueOrThrowArgs = PointFindUniqueArgsBase
      

  /**
   * Point: findFirstOrThrow
   */
  export type PointFindFirstOrThrowArgs = PointFindFirstArgsBase
      

  /**
   * Point without action
   */
  export type PointArgs = {
    /**
     * Select specific fields to fetch from the Point
     * 
    **/
    select?: PointSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PointInclude | null
  }



  /**
   * Model Ranking
   */


  export type AggregateRanking = {
    _count: RankingCountAggregateOutputType | null
    _avg: RankingAvgAggregateOutputType | null
    _sum: RankingSumAggregateOutputType | null
    _min: RankingMinAggregateOutputType | null
    _max: RankingMaxAggregateOutputType | null
  }

  export type RankingAvgAggregateOutputType = {
    id: number | null
    ranking: number | null
    score: number | null
    change: number | null
  }

  export type RankingSumAggregateOutputType = {
    id: number | null
    ranking: number | null
    score: bigint | null
    change: number | null
  }

  export type RankingMinAggregateOutputType = {
    id: number | null
    userId: string | null
    ranking: number | null
    type: RankingType | null
    score: bigint | null
    change: number | null
    createdAt: Date | null
  }

  export type RankingMaxAggregateOutputType = {
    id: number | null
    userId: string | null
    ranking: number | null
    type: RankingType | null
    score: bigint | null
    change: number | null
    createdAt: Date | null
  }

  export type RankingCountAggregateOutputType = {
    id: number
    userId: number
    ranking: number
    type: number
    score: number
    change: number
    createdAt: number
    _all: number
  }


  export type RankingAvgAggregateInputType = {
    id?: true
    ranking?: true
    score?: true
    change?: true
  }

  export type RankingSumAggregateInputType = {
    id?: true
    ranking?: true
    score?: true
    change?: true
  }

  export type RankingMinAggregateInputType = {
    id?: true
    userId?: true
    ranking?: true
    type?: true
    score?: true
    change?: true
    createdAt?: true
  }

  export type RankingMaxAggregateInputType = {
    id?: true
    userId?: true
    ranking?: true
    type?: true
    score?: true
    change?: true
    createdAt?: true
  }

  export type RankingCountAggregateInputType = {
    id?: true
    userId?: true
    ranking?: true
    type?: true
    score?: true
    change?: true
    createdAt?: true
    _all?: true
  }

  export type RankingAggregateArgs = {
    /**
     * Filter which Ranking to aggregate.
     * 
    **/
    where?: RankingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rankings to fetch.
     * 
    **/
    orderBy?: Enumerable<RankingOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: RankingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rankings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rankings.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rankings
    **/
    _count?: true | RankingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RankingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RankingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RankingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RankingMaxAggregateInputType
  }

  export type GetRankingAggregateType<T extends RankingAggregateArgs> = {
        [P in keyof T & keyof AggregateRanking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRanking[P]>
      : GetScalarType<T[P], AggregateRanking[P]>
  }




  export type RankingGroupByArgs = {
    where?: RankingWhereInput
    orderBy?: Enumerable<RankingOrderByWithAggregationInput>
    by: Array<RankingScalarFieldEnum>
    having?: RankingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RankingCountAggregateInputType | true
    _avg?: RankingAvgAggregateInputType
    _sum?: RankingSumAggregateInputType
    _min?: RankingMinAggregateInputType
    _max?: RankingMaxAggregateInputType
  }


  export type RankingGroupByOutputType = {
    id: number
    userId: string | null
    ranking: number
    type: RankingType
    score: bigint
    change: number
    createdAt: Date
    _count: RankingCountAggregateOutputType | null
    _avg: RankingAvgAggregateOutputType | null
    _sum: RankingSumAggregateOutputType | null
    _min: RankingMinAggregateOutputType | null
    _max: RankingMaxAggregateOutputType | null
  }

  type GetRankingGroupByPayload<T extends RankingGroupByArgs> = PrismaPromise<
    Array<
      PickArray<RankingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RankingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RankingGroupByOutputType[P]>
            : GetScalarType<T[P], RankingGroupByOutputType[P]>
        }
      >
    >


  export type RankingSelect = {
    id?: boolean
    user?: boolean | UserArgs
    userId?: boolean
    ranking?: boolean
    type?: boolean
    score?: boolean
    change?: boolean
    createdAt?: boolean
  }

  export type RankingInclude = {
    user?: boolean | UserArgs
  }

  export type RankingGetPayload<
    S extends boolean | null | undefined | RankingArgs,
    U = keyof S
      > = S extends true
        ? Ranking
    : S extends undefined
    ? never
    : S extends RankingArgs | RankingFindManyArgs
    ?'include' extends U
    ? Ranking  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> | null :  P extends keyof Ranking ? Ranking[P] : never
  } 
    : Ranking
  : Ranking


  type RankingCountArgs = Merge<
    Omit<RankingFindManyArgs, 'select' | 'include'> & {
      select?: RankingCountAggregateInputType | true
    }
  >

  export interface RankingDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Ranking that matches the filter.
     * @param {RankingFindUniqueArgs} args - Arguments to find a Ranking
     * @example
     * // Get one Ranking
     * const ranking = await prisma.ranking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RankingFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RankingFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Ranking'> extends True ? CheckSelect<T, Prisma__RankingClient<Ranking>, Prisma__RankingClient<RankingGetPayload<T>>> : CheckSelect<T, Prisma__RankingClient<Ranking | null, null>, Prisma__RankingClient<RankingGetPayload<T> | null, null>>

    /**
     * Find the first Ranking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankingFindFirstArgs} args - Arguments to find a Ranking
     * @example
     * // Get one Ranking
     * const ranking = await prisma.ranking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RankingFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RankingFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Ranking'> extends True ? CheckSelect<T, Prisma__RankingClient<Ranking>, Prisma__RankingClient<RankingGetPayload<T>>> : CheckSelect<T, Prisma__RankingClient<Ranking | null, null>, Prisma__RankingClient<RankingGetPayload<T> | null, null>>

    /**
     * Find zero or more Rankings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rankings
     * const rankings = await prisma.ranking.findMany()
     * 
     * // Get first 10 Rankings
     * const rankings = await prisma.ranking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rankingWithIdOnly = await prisma.ranking.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RankingFindManyArgs>(
      args?: SelectSubset<T, RankingFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Ranking>>, PrismaPromise<Array<RankingGetPayload<T>>>>

    /**
     * Create a Ranking.
     * @param {RankingCreateArgs} args - Arguments to create a Ranking.
     * @example
     * // Create one Ranking
     * const Ranking = await prisma.ranking.create({
     *   data: {
     *     // ... data to create a Ranking
     *   }
     * })
     * 
    **/
    create<T extends RankingCreateArgs>(
      args: SelectSubset<T, RankingCreateArgs>
    ): CheckSelect<T, Prisma__RankingClient<Ranking>, Prisma__RankingClient<RankingGetPayload<T>>>

    /**
     * Create many Rankings.
     *     @param {RankingCreateManyArgs} args - Arguments to create many Rankings.
     *     @example
     *     // Create many Rankings
     *     const ranking = await prisma.ranking.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RankingCreateManyArgs>(
      args?: SelectSubset<T, RankingCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Ranking.
     * @param {RankingDeleteArgs} args - Arguments to delete one Ranking.
     * @example
     * // Delete one Ranking
     * const Ranking = await prisma.ranking.delete({
     *   where: {
     *     // ... filter to delete one Ranking
     *   }
     * })
     * 
    **/
    delete<T extends RankingDeleteArgs>(
      args: SelectSubset<T, RankingDeleteArgs>
    ): CheckSelect<T, Prisma__RankingClient<Ranking>, Prisma__RankingClient<RankingGetPayload<T>>>

    /**
     * Update one Ranking.
     * @param {RankingUpdateArgs} args - Arguments to update one Ranking.
     * @example
     * // Update one Ranking
     * const ranking = await prisma.ranking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RankingUpdateArgs>(
      args: SelectSubset<T, RankingUpdateArgs>
    ): CheckSelect<T, Prisma__RankingClient<Ranking>, Prisma__RankingClient<RankingGetPayload<T>>>

    /**
     * Delete zero or more Rankings.
     * @param {RankingDeleteManyArgs} args - Arguments to filter Rankings to delete.
     * @example
     * // Delete a few Rankings
     * const { count } = await prisma.ranking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RankingDeleteManyArgs>(
      args?: SelectSubset<T, RankingDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rankings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rankings
     * const ranking = await prisma.ranking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RankingUpdateManyArgs>(
      args: SelectSubset<T, RankingUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Ranking.
     * @param {RankingUpsertArgs} args - Arguments to update or create a Ranking.
     * @example
     * // Update or create a Ranking
     * const ranking = await prisma.ranking.upsert({
     *   create: {
     *     // ... data to create a Ranking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ranking we want to update
     *   }
     * })
    **/
    upsert<T extends RankingUpsertArgs>(
      args: SelectSubset<T, RankingUpsertArgs>
    ): CheckSelect<T, Prisma__RankingClient<Ranking>, Prisma__RankingClient<RankingGetPayload<T>>>

    /**
     * Find one Ranking that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {RankingFindUniqueOrThrowArgs} args - Arguments to find a Ranking
     * @example
     * // Get one Ranking
     * const ranking = await prisma.ranking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RankingFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RankingFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__RankingClient<Ranking>, Prisma__RankingClient<RankingGetPayload<T>>>

    /**
     * Find the first Ranking that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankingFindFirstOrThrowArgs} args - Arguments to find a Ranking
     * @example
     * // Get one Ranking
     * const ranking = await prisma.ranking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RankingFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RankingFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__RankingClient<Ranking>, Prisma__RankingClient<RankingGetPayload<T>>>

    /**
     * Count the number of Rankings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankingCountArgs} args - Arguments to filter Rankings to count.
     * @example
     * // Count the number of Rankings
     * const count = await prisma.ranking.count({
     *   where: {
     *     // ... the filter for the Rankings we want to count
     *   }
     * })
    **/
    count<T extends RankingCountArgs>(
      args?: Subset<T, RankingCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RankingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ranking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RankingAggregateArgs>(args: Subset<T, RankingAggregateArgs>): PrismaPromise<GetRankingAggregateType<T>>

    /**
     * Group by Ranking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RankingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RankingGroupByArgs['orderBy'] }
        : { orderBy?: RankingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RankingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRankingGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Ranking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RankingClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | Null>, Prisma__UserClient<UserGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Ranking base type for findUnique actions
   */
  export type RankingFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Ranking
     * 
    **/
    select?: RankingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RankingInclude | null
    /**
     * Filter, which Ranking to fetch.
     * 
    **/
    where: RankingWhereUniqueInput
  }

  /**
   * Ranking: findUnique
   */
  export interface RankingFindUniqueArgs extends RankingFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Ranking base type for findFirst actions
   */
  export type RankingFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Ranking
     * 
    **/
    select?: RankingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RankingInclude | null
    /**
     * Filter, which Ranking to fetch.
     * 
    **/
    where?: RankingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rankings to fetch.
     * 
    **/
    orderBy?: Enumerable<RankingOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rankings.
     * 
    **/
    cursor?: RankingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rankings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rankings.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rankings.
     * 
    **/
    distinct?: Enumerable<RankingScalarFieldEnum>
  }

  /**
   * Ranking: findFirst
   */
  export interface RankingFindFirstArgs extends RankingFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Ranking findMany
   */
  export type RankingFindManyArgs = {
    /**
     * Select specific fields to fetch from the Ranking
     * 
    **/
    select?: RankingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RankingInclude | null
    /**
     * Filter, which Rankings to fetch.
     * 
    **/
    where?: RankingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rankings to fetch.
     * 
    **/
    orderBy?: Enumerable<RankingOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rankings.
     * 
    **/
    cursor?: RankingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rankings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rankings.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RankingScalarFieldEnum>
  }


  /**
   * Ranking create
   */
  export type RankingCreateArgs = {
    /**
     * Select specific fields to fetch from the Ranking
     * 
    **/
    select?: RankingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RankingInclude | null
    /**
     * The data needed to create a Ranking.
     * 
    **/
    data: XOR<RankingCreateInput, RankingUncheckedCreateInput>
  }


  /**
   * Ranking createMany
   */
  export type RankingCreateManyArgs = {
    /**
     * The data used to create many Rankings.
     * 
    **/
    data: Enumerable<RankingCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Ranking update
   */
  export type RankingUpdateArgs = {
    /**
     * Select specific fields to fetch from the Ranking
     * 
    **/
    select?: RankingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RankingInclude | null
    /**
     * The data needed to update a Ranking.
     * 
    **/
    data: XOR<RankingUpdateInput, RankingUncheckedUpdateInput>
    /**
     * Choose, which Ranking to update.
     * 
    **/
    where: RankingWhereUniqueInput
  }


  /**
   * Ranking updateMany
   */
  export type RankingUpdateManyArgs = {
    /**
     * The data used to update Rankings.
     * 
    **/
    data: XOR<RankingUpdateManyMutationInput, RankingUncheckedUpdateManyInput>
    /**
     * Filter which Rankings to update
     * 
    **/
    where?: RankingWhereInput
  }


  /**
   * Ranking upsert
   */
  export type RankingUpsertArgs = {
    /**
     * Select specific fields to fetch from the Ranking
     * 
    **/
    select?: RankingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RankingInclude | null
    /**
     * The filter to search for the Ranking to update in case it exists.
     * 
    **/
    where: RankingWhereUniqueInput
    /**
     * In case the Ranking found by the `where` argument doesn't exist, create a new Ranking with this data.
     * 
    **/
    create: XOR<RankingCreateInput, RankingUncheckedCreateInput>
    /**
     * In case the Ranking was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<RankingUpdateInput, RankingUncheckedUpdateInput>
  }


  /**
   * Ranking delete
   */
  export type RankingDeleteArgs = {
    /**
     * Select specific fields to fetch from the Ranking
     * 
    **/
    select?: RankingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RankingInclude | null
    /**
     * Filter which Ranking to delete.
     * 
    **/
    where: RankingWhereUniqueInput
  }


  /**
   * Ranking deleteMany
   */
  export type RankingDeleteManyArgs = {
    /**
     * Filter which Rankings to delete
     * 
    **/
    where?: RankingWhereInput
  }


  /**
   * Ranking: findUniqueOrThrow
   */
  export type RankingFindUniqueOrThrowArgs = RankingFindUniqueArgsBase
      

  /**
   * Ranking: findFirstOrThrow
   */
  export type RankingFindFirstOrThrowArgs = RankingFindFirstArgsBase
      

  /**
   * Ranking without action
   */
  export type RankingArgs = {
    /**
     * Select specific fields to fetch from the Ranking
     * 
    **/
    select?: RankingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RankingInclude | null
  }



  /**
   * Model Faq
   */


  export type AggregateFaq = {
    _count: FaqCountAggregateOutputType | null
    _avg: FaqAvgAggregateOutputType | null
    _sum: FaqSumAggregateOutputType | null
    _min: FaqMinAggregateOutputType | null
    _max: FaqMaxAggregateOutputType | null
  }

  export type FaqAvgAggregateOutputType = {
    id: number | null
  }

  export type FaqSumAggregateOutputType = {
    id: number | null
  }

  export type FaqMinAggregateOutputType = {
    id: number | null
    type: FaqType | null
    title: string | null
    content: string | null
    createdAt: Date | null
  }

  export type FaqMaxAggregateOutputType = {
    id: number | null
    type: FaqType | null
    title: string | null
    content: string | null
    createdAt: Date | null
  }

  export type FaqCountAggregateOutputType = {
    id: number
    type: number
    title: number
    content: number
    createdAt: number
    _all: number
  }


  export type FaqAvgAggregateInputType = {
    id?: true
  }

  export type FaqSumAggregateInputType = {
    id?: true
  }

  export type FaqMinAggregateInputType = {
    id?: true
    type?: true
    title?: true
    content?: true
    createdAt?: true
  }

  export type FaqMaxAggregateInputType = {
    id?: true
    type?: true
    title?: true
    content?: true
    createdAt?: true
  }

  export type FaqCountAggregateInputType = {
    id?: true
    type?: true
    title?: true
    content?: true
    createdAt?: true
    _all?: true
  }

  export type FaqAggregateArgs = {
    /**
     * Filter which Faq to aggregate.
     * 
    **/
    where?: FaqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Faqs to fetch.
     * 
    **/
    orderBy?: Enumerable<FaqOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: FaqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Faqs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Faqs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Faqs
    **/
    _count?: true | FaqCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FaqAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FaqSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FaqMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FaqMaxAggregateInputType
  }

  export type GetFaqAggregateType<T extends FaqAggregateArgs> = {
        [P in keyof T & keyof AggregateFaq]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFaq[P]>
      : GetScalarType<T[P], AggregateFaq[P]>
  }




  export type FaqGroupByArgs = {
    where?: FaqWhereInput
    orderBy?: Enumerable<FaqOrderByWithAggregationInput>
    by: Array<FaqScalarFieldEnum>
    having?: FaqScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FaqCountAggregateInputType | true
    _avg?: FaqAvgAggregateInputType
    _sum?: FaqSumAggregateInputType
    _min?: FaqMinAggregateInputType
    _max?: FaqMaxAggregateInputType
  }


  export type FaqGroupByOutputType = {
    id: number
    type: FaqType
    title: string
    content: string
    createdAt: Date
    _count: FaqCountAggregateOutputType | null
    _avg: FaqAvgAggregateOutputType | null
    _sum: FaqSumAggregateOutputType | null
    _min: FaqMinAggregateOutputType | null
    _max: FaqMaxAggregateOutputType | null
  }

  type GetFaqGroupByPayload<T extends FaqGroupByArgs> = PrismaPromise<
    Array<
      PickArray<FaqGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FaqGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FaqGroupByOutputType[P]>
            : GetScalarType<T[P], FaqGroupByOutputType[P]>
        }
      >
    >


  export type FaqSelect = {
    id?: boolean
    type?: boolean
    title?: boolean
    content?: boolean
    createdAt?: boolean
  }

  export type FaqGetPayload<
    S extends boolean | null | undefined | FaqArgs,
    U = keyof S
      > = S extends true
        ? Faq
    : S extends undefined
    ? never
    : S extends FaqArgs | FaqFindManyArgs
    ?'include' extends U
    ? Faq 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Faq ? Faq[P] : never
  } 
    : Faq
  : Faq


  type FaqCountArgs = Merge<
    Omit<FaqFindManyArgs, 'select' | 'include'> & {
      select?: FaqCountAggregateInputType | true
    }
  >

  export interface FaqDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Faq that matches the filter.
     * @param {FaqFindUniqueArgs} args - Arguments to find a Faq
     * @example
     * // Get one Faq
     * const faq = await prisma.faq.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FaqFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FaqFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Faq'> extends True ? CheckSelect<T, Prisma__FaqClient<Faq>, Prisma__FaqClient<FaqGetPayload<T>>> : CheckSelect<T, Prisma__FaqClient<Faq | null, null>, Prisma__FaqClient<FaqGetPayload<T> | null, null>>

    /**
     * Find the first Faq that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaqFindFirstArgs} args - Arguments to find a Faq
     * @example
     * // Get one Faq
     * const faq = await prisma.faq.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FaqFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FaqFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Faq'> extends True ? CheckSelect<T, Prisma__FaqClient<Faq>, Prisma__FaqClient<FaqGetPayload<T>>> : CheckSelect<T, Prisma__FaqClient<Faq | null, null>, Prisma__FaqClient<FaqGetPayload<T> | null, null>>

    /**
     * Find zero or more Faqs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaqFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Faqs
     * const faqs = await prisma.faq.findMany()
     * 
     * // Get first 10 Faqs
     * const faqs = await prisma.faq.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const faqWithIdOnly = await prisma.faq.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FaqFindManyArgs>(
      args?: SelectSubset<T, FaqFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Faq>>, PrismaPromise<Array<FaqGetPayload<T>>>>

    /**
     * Create a Faq.
     * @param {FaqCreateArgs} args - Arguments to create a Faq.
     * @example
     * // Create one Faq
     * const Faq = await prisma.faq.create({
     *   data: {
     *     // ... data to create a Faq
     *   }
     * })
     * 
    **/
    create<T extends FaqCreateArgs>(
      args: SelectSubset<T, FaqCreateArgs>
    ): CheckSelect<T, Prisma__FaqClient<Faq>, Prisma__FaqClient<FaqGetPayload<T>>>

    /**
     * Create many Faqs.
     *     @param {FaqCreateManyArgs} args - Arguments to create many Faqs.
     *     @example
     *     // Create many Faqs
     *     const faq = await prisma.faq.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FaqCreateManyArgs>(
      args?: SelectSubset<T, FaqCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Faq.
     * @param {FaqDeleteArgs} args - Arguments to delete one Faq.
     * @example
     * // Delete one Faq
     * const Faq = await prisma.faq.delete({
     *   where: {
     *     // ... filter to delete one Faq
     *   }
     * })
     * 
    **/
    delete<T extends FaqDeleteArgs>(
      args: SelectSubset<T, FaqDeleteArgs>
    ): CheckSelect<T, Prisma__FaqClient<Faq>, Prisma__FaqClient<FaqGetPayload<T>>>

    /**
     * Update one Faq.
     * @param {FaqUpdateArgs} args - Arguments to update one Faq.
     * @example
     * // Update one Faq
     * const faq = await prisma.faq.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FaqUpdateArgs>(
      args: SelectSubset<T, FaqUpdateArgs>
    ): CheckSelect<T, Prisma__FaqClient<Faq>, Prisma__FaqClient<FaqGetPayload<T>>>

    /**
     * Delete zero or more Faqs.
     * @param {FaqDeleteManyArgs} args - Arguments to filter Faqs to delete.
     * @example
     * // Delete a few Faqs
     * const { count } = await prisma.faq.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FaqDeleteManyArgs>(
      args?: SelectSubset<T, FaqDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Faqs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaqUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Faqs
     * const faq = await prisma.faq.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FaqUpdateManyArgs>(
      args: SelectSubset<T, FaqUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Faq.
     * @param {FaqUpsertArgs} args - Arguments to update or create a Faq.
     * @example
     * // Update or create a Faq
     * const faq = await prisma.faq.upsert({
     *   create: {
     *     // ... data to create a Faq
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Faq we want to update
     *   }
     * })
    **/
    upsert<T extends FaqUpsertArgs>(
      args: SelectSubset<T, FaqUpsertArgs>
    ): CheckSelect<T, Prisma__FaqClient<Faq>, Prisma__FaqClient<FaqGetPayload<T>>>

    /**
     * Find one Faq that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {FaqFindUniqueOrThrowArgs} args - Arguments to find a Faq
     * @example
     * // Get one Faq
     * const faq = await prisma.faq.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FaqFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, FaqFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__FaqClient<Faq>, Prisma__FaqClient<FaqGetPayload<T>>>

    /**
     * Find the first Faq that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaqFindFirstOrThrowArgs} args - Arguments to find a Faq
     * @example
     * // Get one Faq
     * const faq = await prisma.faq.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FaqFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FaqFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__FaqClient<Faq>, Prisma__FaqClient<FaqGetPayload<T>>>

    /**
     * Count the number of Faqs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaqCountArgs} args - Arguments to filter Faqs to count.
     * @example
     * // Count the number of Faqs
     * const count = await prisma.faq.count({
     *   where: {
     *     // ... the filter for the Faqs we want to count
     *   }
     * })
    **/
    count<T extends FaqCountArgs>(
      args?: Subset<T, FaqCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FaqCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Faq.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaqAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FaqAggregateArgs>(args: Subset<T, FaqAggregateArgs>): PrismaPromise<GetFaqAggregateType<T>>

    /**
     * Group by Faq.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaqGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FaqGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FaqGroupByArgs['orderBy'] }
        : { orderBy?: FaqGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FaqGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFaqGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Faq.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FaqClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Faq base type for findUnique actions
   */
  export type FaqFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Faq
     * 
    **/
    select?: FaqSelect | null
    /**
     * Filter, which Faq to fetch.
     * 
    **/
    where: FaqWhereUniqueInput
  }

  /**
   * Faq: findUnique
   */
  export interface FaqFindUniqueArgs extends FaqFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Faq base type for findFirst actions
   */
  export type FaqFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Faq
     * 
    **/
    select?: FaqSelect | null
    /**
     * Filter, which Faq to fetch.
     * 
    **/
    where?: FaqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Faqs to fetch.
     * 
    **/
    orderBy?: Enumerable<FaqOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Faqs.
     * 
    **/
    cursor?: FaqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Faqs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Faqs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Faqs.
     * 
    **/
    distinct?: Enumerable<FaqScalarFieldEnum>
  }

  /**
   * Faq: findFirst
   */
  export interface FaqFindFirstArgs extends FaqFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Faq findMany
   */
  export type FaqFindManyArgs = {
    /**
     * Select specific fields to fetch from the Faq
     * 
    **/
    select?: FaqSelect | null
    /**
     * Filter, which Faqs to fetch.
     * 
    **/
    where?: FaqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Faqs to fetch.
     * 
    **/
    orderBy?: Enumerable<FaqOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Faqs.
     * 
    **/
    cursor?: FaqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Faqs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Faqs.
     * 
    **/
    skip?: number
    distinct?: Enumerable<FaqScalarFieldEnum>
  }


  /**
   * Faq create
   */
  export type FaqCreateArgs = {
    /**
     * Select specific fields to fetch from the Faq
     * 
    **/
    select?: FaqSelect | null
    /**
     * The data needed to create a Faq.
     * 
    **/
    data: XOR<FaqCreateInput, FaqUncheckedCreateInput>
  }


  /**
   * Faq createMany
   */
  export type FaqCreateManyArgs = {
    /**
     * The data used to create many Faqs.
     * 
    **/
    data: Enumerable<FaqCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Faq update
   */
  export type FaqUpdateArgs = {
    /**
     * Select specific fields to fetch from the Faq
     * 
    **/
    select?: FaqSelect | null
    /**
     * The data needed to update a Faq.
     * 
    **/
    data: XOR<FaqUpdateInput, FaqUncheckedUpdateInput>
    /**
     * Choose, which Faq to update.
     * 
    **/
    where: FaqWhereUniqueInput
  }


  /**
   * Faq updateMany
   */
  export type FaqUpdateManyArgs = {
    /**
     * The data used to update Faqs.
     * 
    **/
    data: XOR<FaqUpdateManyMutationInput, FaqUncheckedUpdateManyInput>
    /**
     * Filter which Faqs to update
     * 
    **/
    where?: FaqWhereInput
  }


  /**
   * Faq upsert
   */
  export type FaqUpsertArgs = {
    /**
     * Select specific fields to fetch from the Faq
     * 
    **/
    select?: FaqSelect | null
    /**
     * The filter to search for the Faq to update in case it exists.
     * 
    **/
    where: FaqWhereUniqueInput
    /**
     * In case the Faq found by the `where` argument doesn't exist, create a new Faq with this data.
     * 
    **/
    create: XOR<FaqCreateInput, FaqUncheckedCreateInput>
    /**
     * In case the Faq was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<FaqUpdateInput, FaqUncheckedUpdateInput>
  }


  /**
   * Faq delete
   */
  export type FaqDeleteArgs = {
    /**
     * Select specific fields to fetch from the Faq
     * 
    **/
    select?: FaqSelect | null
    /**
     * Filter which Faq to delete.
     * 
    **/
    where: FaqWhereUniqueInput
  }


  /**
   * Faq deleteMany
   */
  export type FaqDeleteManyArgs = {
    /**
     * Filter which Faqs to delete
     * 
    **/
    where?: FaqWhereInput
  }


  /**
   * Faq: findUniqueOrThrow
   */
  export type FaqFindUniqueOrThrowArgs = FaqFindUniqueArgsBase
      

  /**
   * Faq: findFirstOrThrow
   */
  export type FaqFindFirstOrThrowArgs = FaqFindFirstArgsBase
      

  /**
   * Faq without action
   */
  export type FaqArgs = {
    /**
     * Select specific fields to fetch from the Faq
     * 
    **/
    select?: FaqSelect | null
  }



  /**
   * Model Notice
   */


  export type AggregateNotice = {
    _count: NoticeCountAggregateOutputType | null
    _avg: NoticeAvgAggregateOutputType | null
    _sum: NoticeSumAggregateOutputType | null
    _min: NoticeMinAggregateOutputType | null
    _max: NoticeMaxAggregateOutputType | null
  }

  export type NoticeAvgAggregateOutputType = {
    id: number | null
  }

  export type NoticeSumAggregateOutputType = {
    id: number | null
  }

  export type NoticeMinAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    createdAt: Date | null
  }

  export type NoticeMaxAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    createdAt: Date | null
  }

  export type NoticeCountAggregateOutputType = {
    id: number
    title: number
    content: number
    createdAt: number
    _all: number
  }


  export type NoticeAvgAggregateInputType = {
    id?: true
  }

  export type NoticeSumAggregateInputType = {
    id?: true
  }

  export type NoticeMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    createdAt?: true
  }

  export type NoticeMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    createdAt?: true
  }

  export type NoticeCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    createdAt?: true
    _all?: true
  }

  export type NoticeAggregateArgs = {
    /**
     * Filter which Notice to aggregate.
     * 
    **/
    where?: NoticeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notices to fetch.
     * 
    **/
    orderBy?: Enumerable<NoticeOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: NoticeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notices from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notices.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notices
    **/
    _count?: true | NoticeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NoticeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NoticeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NoticeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NoticeMaxAggregateInputType
  }

  export type GetNoticeAggregateType<T extends NoticeAggregateArgs> = {
        [P in keyof T & keyof AggregateNotice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotice[P]>
      : GetScalarType<T[P], AggregateNotice[P]>
  }




  export type NoticeGroupByArgs = {
    where?: NoticeWhereInput
    orderBy?: Enumerable<NoticeOrderByWithAggregationInput>
    by: Array<NoticeScalarFieldEnum>
    having?: NoticeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NoticeCountAggregateInputType | true
    _avg?: NoticeAvgAggregateInputType
    _sum?: NoticeSumAggregateInputType
    _min?: NoticeMinAggregateInputType
    _max?: NoticeMaxAggregateInputType
  }


  export type NoticeGroupByOutputType = {
    id: number
    title: string
    content: string
    createdAt: Date
    _count: NoticeCountAggregateOutputType | null
    _avg: NoticeAvgAggregateOutputType | null
    _sum: NoticeSumAggregateOutputType | null
    _min: NoticeMinAggregateOutputType | null
    _max: NoticeMaxAggregateOutputType | null
  }

  type GetNoticeGroupByPayload<T extends NoticeGroupByArgs> = PrismaPromise<
    Array<
      PickArray<NoticeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NoticeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NoticeGroupByOutputType[P]>
            : GetScalarType<T[P], NoticeGroupByOutputType[P]>
        }
      >
    >


  export type NoticeSelect = {
    id?: boolean
    title?: boolean
    content?: boolean
    createdAt?: boolean
  }

  export type NoticeGetPayload<
    S extends boolean | null | undefined | NoticeArgs,
    U = keyof S
      > = S extends true
        ? Notice
    : S extends undefined
    ? never
    : S extends NoticeArgs | NoticeFindManyArgs
    ?'include' extends U
    ? Notice 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Notice ? Notice[P] : never
  } 
    : Notice
  : Notice


  type NoticeCountArgs = Merge<
    Omit<NoticeFindManyArgs, 'select' | 'include'> & {
      select?: NoticeCountAggregateInputType | true
    }
  >

  export interface NoticeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Notice that matches the filter.
     * @param {NoticeFindUniqueArgs} args - Arguments to find a Notice
     * @example
     * // Get one Notice
     * const notice = await prisma.notice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NoticeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, NoticeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Notice'> extends True ? CheckSelect<T, Prisma__NoticeClient<Notice>, Prisma__NoticeClient<NoticeGetPayload<T>>> : CheckSelect<T, Prisma__NoticeClient<Notice | null, null>, Prisma__NoticeClient<NoticeGetPayload<T> | null, null>>

    /**
     * Find the first Notice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeFindFirstArgs} args - Arguments to find a Notice
     * @example
     * // Get one Notice
     * const notice = await prisma.notice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NoticeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, NoticeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Notice'> extends True ? CheckSelect<T, Prisma__NoticeClient<Notice>, Prisma__NoticeClient<NoticeGetPayload<T>>> : CheckSelect<T, Prisma__NoticeClient<Notice | null, null>, Prisma__NoticeClient<NoticeGetPayload<T> | null, null>>

    /**
     * Find zero or more Notices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notices
     * const notices = await prisma.notice.findMany()
     * 
     * // Get first 10 Notices
     * const notices = await prisma.notice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const noticeWithIdOnly = await prisma.notice.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends NoticeFindManyArgs>(
      args?: SelectSubset<T, NoticeFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Notice>>, PrismaPromise<Array<NoticeGetPayload<T>>>>

    /**
     * Create a Notice.
     * @param {NoticeCreateArgs} args - Arguments to create a Notice.
     * @example
     * // Create one Notice
     * const Notice = await prisma.notice.create({
     *   data: {
     *     // ... data to create a Notice
     *   }
     * })
     * 
    **/
    create<T extends NoticeCreateArgs>(
      args: SelectSubset<T, NoticeCreateArgs>
    ): CheckSelect<T, Prisma__NoticeClient<Notice>, Prisma__NoticeClient<NoticeGetPayload<T>>>

    /**
     * Create many Notices.
     *     @param {NoticeCreateManyArgs} args - Arguments to create many Notices.
     *     @example
     *     // Create many Notices
     *     const notice = await prisma.notice.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends NoticeCreateManyArgs>(
      args?: SelectSubset<T, NoticeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Notice.
     * @param {NoticeDeleteArgs} args - Arguments to delete one Notice.
     * @example
     * // Delete one Notice
     * const Notice = await prisma.notice.delete({
     *   where: {
     *     // ... filter to delete one Notice
     *   }
     * })
     * 
    **/
    delete<T extends NoticeDeleteArgs>(
      args: SelectSubset<T, NoticeDeleteArgs>
    ): CheckSelect<T, Prisma__NoticeClient<Notice>, Prisma__NoticeClient<NoticeGetPayload<T>>>

    /**
     * Update one Notice.
     * @param {NoticeUpdateArgs} args - Arguments to update one Notice.
     * @example
     * // Update one Notice
     * const notice = await prisma.notice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NoticeUpdateArgs>(
      args: SelectSubset<T, NoticeUpdateArgs>
    ): CheckSelect<T, Prisma__NoticeClient<Notice>, Prisma__NoticeClient<NoticeGetPayload<T>>>

    /**
     * Delete zero or more Notices.
     * @param {NoticeDeleteManyArgs} args - Arguments to filter Notices to delete.
     * @example
     * // Delete a few Notices
     * const { count } = await prisma.notice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NoticeDeleteManyArgs>(
      args?: SelectSubset<T, NoticeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notices
     * const notice = await prisma.notice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NoticeUpdateManyArgs>(
      args: SelectSubset<T, NoticeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Notice.
     * @param {NoticeUpsertArgs} args - Arguments to update or create a Notice.
     * @example
     * // Update or create a Notice
     * const notice = await prisma.notice.upsert({
     *   create: {
     *     // ... data to create a Notice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notice we want to update
     *   }
     * })
    **/
    upsert<T extends NoticeUpsertArgs>(
      args: SelectSubset<T, NoticeUpsertArgs>
    ): CheckSelect<T, Prisma__NoticeClient<Notice>, Prisma__NoticeClient<NoticeGetPayload<T>>>

    /**
     * Find one Notice that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {NoticeFindUniqueOrThrowArgs} args - Arguments to find a Notice
     * @example
     * // Get one Notice
     * const notice = await prisma.notice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends NoticeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, NoticeFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__NoticeClient<Notice>, Prisma__NoticeClient<NoticeGetPayload<T>>>

    /**
     * Find the first Notice that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeFindFirstOrThrowArgs} args - Arguments to find a Notice
     * @example
     * // Get one Notice
     * const notice = await prisma.notice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends NoticeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, NoticeFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__NoticeClient<Notice>, Prisma__NoticeClient<NoticeGetPayload<T>>>

    /**
     * Count the number of Notices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeCountArgs} args - Arguments to filter Notices to count.
     * @example
     * // Count the number of Notices
     * const count = await prisma.notice.count({
     *   where: {
     *     // ... the filter for the Notices we want to count
     *   }
     * })
    **/
    count<T extends NoticeCountArgs>(
      args?: Subset<T, NoticeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NoticeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NoticeAggregateArgs>(args: Subset<T, NoticeAggregateArgs>): PrismaPromise<GetNoticeAggregateType<T>>

    /**
     * Group by Notice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NoticeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NoticeGroupByArgs['orderBy'] }
        : { orderBy?: NoticeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NoticeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNoticeGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Notice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__NoticeClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Notice base type for findUnique actions
   */
  export type NoticeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Notice
     * 
    **/
    select?: NoticeSelect | null
    /**
     * Filter, which Notice to fetch.
     * 
    **/
    where: NoticeWhereUniqueInput
  }

  /**
   * Notice: findUnique
   */
  export interface NoticeFindUniqueArgs extends NoticeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Notice base type for findFirst actions
   */
  export type NoticeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Notice
     * 
    **/
    select?: NoticeSelect | null
    /**
     * Filter, which Notice to fetch.
     * 
    **/
    where?: NoticeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notices to fetch.
     * 
    **/
    orderBy?: Enumerable<NoticeOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notices.
     * 
    **/
    cursor?: NoticeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notices from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notices.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notices.
     * 
    **/
    distinct?: Enumerable<NoticeScalarFieldEnum>
  }

  /**
   * Notice: findFirst
   */
  export interface NoticeFindFirstArgs extends NoticeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Notice findMany
   */
  export type NoticeFindManyArgs = {
    /**
     * Select specific fields to fetch from the Notice
     * 
    **/
    select?: NoticeSelect | null
    /**
     * Filter, which Notices to fetch.
     * 
    **/
    where?: NoticeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notices to fetch.
     * 
    **/
    orderBy?: Enumerable<NoticeOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notices.
     * 
    **/
    cursor?: NoticeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notices from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notices.
     * 
    **/
    skip?: number
    distinct?: Enumerable<NoticeScalarFieldEnum>
  }


  /**
   * Notice create
   */
  export type NoticeCreateArgs = {
    /**
     * Select specific fields to fetch from the Notice
     * 
    **/
    select?: NoticeSelect | null
    /**
     * The data needed to create a Notice.
     * 
    **/
    data: XOR<NoticeCreateInput, NoticeUncheckedCreateInput>
  }


  /**
   * Notice createMany
   */
  export type NoticeCreateManyArgs = {
    /**
     * The data used to create many Notices.
     * 
    **/
    data: Enumerable<NoticeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Notice update
   */
  export type NoticeUpdateArgs = {
    /**
     * Select specific fields to fetch from the Notice
     * 
    **/
    select?: NoticeSelect | null
    /**
     * The data needed to update a Notice.
     * 
    **/
    data: XOR<NoticeUpdateInput, NoticeUncheckedUpdateInput>
    /**
     * Choose, which Notice to update.
     * 
    **/
    where: NoticeWhereUniqueInput
  }


  /**
   * Notice updateMany
   */
  export type NoticeUpdateManyArgs = {
    /**
     * The data used to update Notices.
     * 
    **/
    data: XOR<NoticeUpdateManyMutationInput, NoticeUncheckedUpdateManyInput>
    /**
     * Filter which Notices to update
     * 
    **/
    where?: NoticeWhereInput
  }


  /**
   * Notice upsert
   */
  export type NoticeUpsertArgs = {
    /**
     * Select specific fields to fetch from the Notice
     * 
    **/
    select?: NoticeSelect | null
    /**
     * The filter to search for the Notice to update in case it exists.
     * 
    **/
    where: NoticeWhereUniqueInput
    /**
     * In case the Notice found by the `where` argument doesn't exist, create a new Notice with this data.
     * 
    **/
    create: XOR<NoticeCreateInput, NoticeUncheckedCreateInput>
    /**
     * In case the Notice was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<NoticeUpdateInput, NoticeUncheckedUpdateInput>
  }


  /**
   * Notice delete
   */
  export type NoticeDeleteArgs = {
    /**
     * Select specific fields to fetch from the Notice
     * 
    **/
    select?: NoticeSelect | null
    /**
     * Filter which Notice to delete.
     * 
    **/
    where: NoticeWhereUniqueInput
  }


  /**
   * Notice deleteMany
   */
  export type NoticeDeleteManyArgs = {
    /**
     * Filter which Notices to delete
     * 
    **/
    where?: NoticeWhereInput
  }


  /**
   * Notice: findUniqueOrThrow
   */
  export type NoticeFindUniqueOrThrowArgs = NoticeFindUniqueArgsBase
      

  /**
   * Notice: findFirstOrThrow
   */
  export type NoticeFindFirstOrThrowArgs = NoticeFindFirstArgsBase
      

  /**
   * Notice without action
   */
  export type NoticeArgs = {
    /**
     * Select specific fields to fetch from the Notice
     * 
    **/
    select?: NoticeSelect | null
  }



  /**
   * Model Creator
   */


  export type AggregateCreator = {
    _count: CreatorCountAggregateOutputType | null
    _avg: CreatorAvgAggregateOutputType | null
    _sum: CreatorSumAggregateOutputType | null
    _min: CreatorMinAggregateOutputType | null
    _max: CreatorMaxAggregateOutputType | null
  }

  export type CreatorAvgAggregateOutputType = {
    id: number | null
  }

  export type CreatorSumAggregateOutputType = {
    id: bigint | null
  }

  export type CreatorMinAggregateOutputType = {
    id: bigint | null
    userId: string | null
    createdAt: Date | null
  }

  export type CreatorMaxAggregateOutputType = {
    id: bigint | null
    userId: string | null
    createdAt: Date | null
  }

  export type CreatorCountAggregateOutputType = {
    id: number
    userId: number
    createdAt: number
    _all: number
  }


  export type CreatorAvgAggregateInputType = {
    id?: true
  }

  export type CreatorSumAggregateInputType = {
    id?: true
  }

  export type CreatorMinAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
  }

  export type CreatorMaxAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
  }

  export type CreatorCountAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type CreatorAggregateArgs = {
    /**
     * Filter which Creator to aggregate.
     * 
    **/
    where?: CreatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Creators to fetch.
     * 
    **/
    orderBy?: Enumerable<CreatorOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CreatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Creators from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Creators.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Creators
    **/
    _count?: true | CreatorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CreatorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CreatorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreatorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreatorMaxAggregateInputType
  }

  export type GetCreatorAggregateType<T extends CreatorAggregateArgs> = {
        [P in keyof T & keyof AggregateCreator]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreator[P]>
      : GetScalarType<T[P], AggregateCreator[P]>
  }




  export type CreatorGroupByArgs = {
    where?: CreatorWhereInput
    orderBy?: Enumerable<CreatorOrderByWithAggregationInput>
    by: Array<CreatorScalarFieldEnum>
    having?: CreatorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreatorCountAggregateInputType | true
    _avg?: CreatorAvgAggregateInputType
    _sum?: CreatorSumAggregateInputType
    _min?: CreatorMinAggregateInputType
    _max?: CreatorMaxAggregateInputType
  }


  export type CreatorGroupByOutputType = {
    id: bigint
    userId: string
    createdAt: Date
    _count: CreatorCountAggregateOutputType | null
    _avg: CreatorAvgAggregateOutputType | null
    _sum: CreatorSumAggregateOutputType | null
    _min: CreatorMinAggregateOutputType | null
    _max: CreatorMaxAggregateOutputType | null
  }

  type GetCreatorGroupByPayload<T extends CreatorGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CreatorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreatorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreatorGroupByOutputType[P]>
            : GetScalarType<T[P], CreatorGroupByOutputType[P]>
        }
      >
    >


  export type CreatorSelect = {
    id?: boolean
    user?: boolean | UserArgs
    userId?: boolean
    createdAt?: boolean
    requestPosts?: boolean | RequestPostFindManyArgs
    requestApplyCreators?: boolean | RequestApplyCreatorFindManyArgs
    requestInquiries?: boolean | RequestInquiryFindManyArgs
    creatorAuths?: boolean | CreatorAuthFindManyArgs
    creatorReviews?: boolean | CreatorReviewFindManyArgs
    _count?: boolean | CreatorCountOutputTypeArgs
  }

  export type CreatorInclude = {
    user?: boolean | UserArgs
    requestPosts?: boolean | RequestPostFindManyArgs
    requestApplyCreators?: boolean | RequestApplyCreatorFindManyArgs
    requestInquiries?: boolean | RequestInquiryFindManyArgs
    creatorAuths?: boolean | CreatorAuthFindManyArgs
    creatorReviews?: boolean | CreatorReviewFindManyArgs
    _count?: boolean | CreatorCountOutputTypeArgs
  }

  export type CreatorGetPayload<
    S extends boolean | null | undefined | CreatorArgs,
    U = keyof S
      > = S extends true
        ? Creator
    : S extends undefined
    ? never
    : S extends CreatorArgs | CreatorFindManyArgs
    ?'include' extends U
    ? Creator  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'requestPosts' ? Array < RequestPostGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'requestApplyCreators' ? Array < RequestApplyCreatorGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'requestInquiries' ? Array < RequestInquiryGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'creatorAuths' ? Array < CreatorAuthGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'creatorReviews' ? Array < CreatorReviewGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? CreatorCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'requestPosts' ? Array < RequestPostGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'requestApplyCreators' ? Array < RequestApplyCreatorGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'requestInquiries' ? Array < RequestInquiryGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'creatorAuths' ? Array < CreatorAuthGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'creatorReviews' ? Array < CreatorReviewGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? CreatorCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Creator ? Creator[P] : never
  } 
    : Creator
  : Creator


  type CreatorCountArgs = Merge<
    Omit<CreatorFindManyArgs, 'select' | 'include'> & {
      select?: CreatorCountAggregateInputType | true
    }
  >

  export interface CreatorDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Creator that matches the filter.
     * @param {CreatorFindUniqueArgs} args - Arguments to find a Creator
     * @example
     * // Get one Creator
     * const creator = await prisma.creator.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CreatorFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CreatorFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Creator'> extends True ? CheckSelect<T, Prisma__CreatorClient<Creator>, Prisma__CreatorClient<CreatorGetPayload<T>>> : CheckSelect<T, Prisma__CreatorClient<Creator | null, null>, Prisma__CreatorClient<CreatorGetPayload<T> | null, null>>

    /**
     * Find the first Creator that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorFindFirstArgs} args - Arguments to find a Creator
     * @example
     * // Get one Creator
     * const creator = await prisma.creator.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CreatorFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CreatorFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Creator'> extends True ? CheckSelect<T, Prisma__CreatorClient<Creator>, Prisma__CreatorClient<CreatorGetPayload<T>>> : CheckSelect<T, Prisma__CreatorClient<Creator | null, null>, Prisma__CreatorClient<CreatorGetPayload<T> | null, null>>

    /**
     * Find zero or more Creators that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Creators
     * const creators = await prisma.creator.findMany()
     * 
     * // Get first 10 Creators
     * const creators = await prisma.creator.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const creatorWithIdOnly = await prisma.creator.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CreatorFindManyArgs>(
      args?: SelectSubset<T, CreatorFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Creator>>, PrismaPromise<Array<CreatorGetPayload<T>>>>

    /**
     * Create a Creator.
     * @param {CreatorCreateArgs} args - Arguments to create a Creator.
     * @example
     * // Create one Creator
     * const Creator = await prisma.creator.create({
     *   data: {
     *     // ... data to create a Creator
     *   }
     * })
     * 
    **/
    create<T extends CreatorCreateArgs>(
      args: SelectSubset<T, CreatorCreateArgs>
    ): CheckSelect<T, Prisma__CreatorClient<Creator>, Prisma__CreatorClient<CreatorGetPayload<T>>>

    /**
     * Create many Creators.
     *     @param {CreatorCreateManyArgs} args - Arguments to create many Creators.
     *     @example
     *     // Create many Creators
     *     const creator = await prisma.creator.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CreatorCreateManyArgs>(
      args?: SelectSubset<T, CreatorCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Creator.
     * @param {CreatorDeleteArgs} args - Arguments to delete one Creator.
     * @example
     * // Delete one Creator
     * const Creator = await prisma.creator.delete({
     *   where: {
     *     // ... filter to delete one Creator
     *   }
     * })
     * 
    **/
    delete<T extends CreatorDeleteArgs>(
      args: SelectSubset<T, CreatorDeleteArgs>
    ): CheckSelect<T, Prisma__CreatorClient<Creator>, Prisma__CreatorClient<CreatorGetPayload<T>>>

    /**
     * Update one Creator.
     * @param {CreatorUpdateArgs} args - Arguments to update one Creator.
     * @example
     * // Update one Creator
     * const creator = await prisma.creator.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CreatorUpdateArgs>(
      args: SelectSubset<T, CreatorUpdateArgs>
    ): CheckSelect<T, Prisma__CreatorClient<Creator>, Prisma__CreatorClient<CreatorGetPayload<T>>>

    /**
     * Delete zero or more Creators.
     * @param {CreatorDeleteManyArgs} args - Arguments to filter Creators to delete.
     * @example
     * // Delete a few Creators
     * const { count } = await prisma.creator.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CreatorDeleteManyArgs>(
      args?: SelectSubset<T, CreatorDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Creators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Creators
     * const creator = await prisma.creator.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CreatorUpdateManyArgs>(
      args: SelectSubset<T, CreatorUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Creator.
     * @param {CreatorUpsertArgs} args - Arguments to update or create a Creator.
     * @example
     * // Update or create a Creator
     * const creator = await prisma.creator.upsert({
     *   create: {
     *     // ... data to create a Creator
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Creator we want to update
     *   }
     * })
    **/
    upsert<T extends CreatorUpsertArgs>(
      args: SelectSubset<T, CreatorUpsertArgs>
    ): CheckSelect<T, Prisma__CreatorClient<Creator>, Prisma__CreatorClient<CreatorGetPayload<T>>>

    /**
     * Find one Creator that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {CreatorFindUniqueOrThrowArgs} args - Arguments to find a Creator
     * @example
     * // Get one Creator
     * const creator = await prisma.creator.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CreatorFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CreatorFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__CreatorClient<Creator>, Prisma__CreatorClient<CreatorGetPayload<T>>>

    /**
     * Find the first Creator that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorFindFirstOrThrowArgs} args - Arguments to find a Creator
     * @example
     * // Get one Creator
     * const creator = await prisma.creator.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CreatorFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CreatorFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__CreatorClient<Creator>, Prisma__CreatorClient<CreatorGetPayload<T>>>

    /**
     * Count the number of Creators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorCountArgs} args - Arguments to filter Creators to count.
     * @example
     * // Count the number of Creators
     * const count = await prisma.creator.count({
     *   where: {
     *     // ... the filter for the Creators we want to count
     *   }
     * })
    **/
    count<T extends CreatorCountArgs>(
      args?: Subset<T, CreatorCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreatorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Creator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreatorAggregateArgs>(args: Subset<T, CreatorAggregateArgs>): PrismaPromise<GetCreatorAggregateType<T>>

    /**
     * Group by Creator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreatorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreatorGroupByArgs['orderBy'] }
        : { orderBy?: CreatorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreatorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreatorGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Creator.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CreatorClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | Null>, Prisma__UserClient<UserGetPayload<T> | Null>>;

    requestPosts<T extends RequestPostFindManyArgs = {}>(args?: Subset<T, RequestPostFindManyArgs>): CheckSelect<T, PrismaPromise<Array<RequestPost>| Null>, PrismaPromise<Array<RequestPostGetPayload<T>>| Null>>;

    requestApplyCreators<T extends RequestApplyCreatorFindManyArgs = {}>(args?: Subset<T, RequestApplyCreatorFindManyArgs>): CheckSelect<T, PrismaPromise<Array<RequestApplyCreator>| Null>, PrismaPromise<Array<RequestApplyCreatorGetPayload<T>>| Null>>;

    requestInquiries<T extends RequestInquiryFindManyArgs = {}>(args?: Subset<T, RequestInquiryFindManyArgs>): CheckSelect<T, PrismaPromise<Array<RequestInquiry>| Null>, PrismaPromise<Array<RequestInquiryGetPayload<T>>| Null>>;

    creatorAuths<T extends CreatorAuthFindManyArgs = {}>(args?: Subset<T, CreatorAuthFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CreatorAuth>| Null>, PrismaPromise<Array<CreatorAuthGetPayload<T>>| Null>>;

    creatorReviews<T extends CreatorReviewFindManyArgs = {}>(args?: Subset<T, CreatorReviewFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CreatorReview>| Null>, PrismaPromise<Array<CreatorReviewGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Creator base type for findUnique actions
   */
  export type CreatorFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Creator
     * 
    **/
    select?: CreatorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreatorInclude | null
    /**
     * Filter, which Creator to fetch.
     * 
    **/
    where: CreatorWhereUniqueInput
  }

  /**
   * Creator: findUnique
   */
  export interface CreatorFindUniqueArgs extends CreatorFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Creator base type for findFirst actions
   */
  export type CreatorFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Creator
     * 
    **/
    select?: CreatorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreatorInclude | null
    /**
     * Filter, which Creator to fetch.
     * 
    **/
    where?: CreatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Creators to fetch.
     * 
    **/
    orderBy?: Enumerable<CreatorOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Creators.
     * 
    **/
    cursor?: CreatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Creators from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Creators.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Creators.
     * 
    **/
    distinct?: Enumerable<CreatorScalarFieldEnum>
  }

  /**
   * Creator: findFirst
   */
  export interface CreatorFindFirstArgs extends CreatorFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Creator findMany
   */
  export type CreatorFindManyArgs = {
    /**
     * Select specific fields to fetch from the Creator
     * 
    **/
    select?: CreatorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreatorInclude | null
    /**
     * Filter, which Creators to fetch.
     * 
    **/
    where?: CreatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Creators to fetch.
     * 
    **/
    orderBy?: Enumerable<CreatorOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Creators.
     * 
    **/
    cursor?: CreatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Creators from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Creators.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CreatorScalarFieldEnum>
  }


  /**
   * Creator create
   */
  export type CreatorCreateArgs = {
    /**
     * Select specific fields to fetch from the Creator
     * 
    **/
    select?: CreatorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreatorInclude | null
    /**
     * The data needed to create a Creator.
     * 
    **/
    data: XOR<CreatorCreateInput, CreatorUncheckedCreateInput>
  }


  /**
   * Creator createMany
   */
  export type CreatorCreateManyArgs = {
    /**
     * The data used to create many Creators.
     * 
    **/
    data: Enumerable<CreatorCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Creator update
   */
  export type CreatorUpdateArgs = {
    /**
     * Select specific fields to fetch from the Creator
     * 
    **/
    select?: CreatorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreatorInclude | null
    /**
     * The data needed to update a Creator.
     * 
    **/
    data: XOR<CreatorUpdateInput, CreatorUncheckedUpdateInput>
    /**
     * Choose, which Creator to update.
     * 
    **/
    where: CreatorWhereUniqueInput
  }


  /**
   * Creator updateMany
   */
  export type CreatorUpdateManyArgs = {
    /**
     * The data used to update Creators.
     * 
    **/
    data: XOR<CreatorUpdateManyMutationInput, CreatorUncheckedUpdateManyInput>
    /**
     * Filter which Creators to update
     * 
    **/
    where?: CreatorWhereInput
  }


  /**
   * Creator upsert
   */
  export type CreatorUpsertArgs = {
    /**
     * Select specific fields to fetch from the Creator
     * 
    **/
    select?: CreatorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreatorInclude | null
    /**
     * The filter to search for the Creator to update in case it exists.
     * 
    **/
    where: CreatorWhereUniqueInput
    /**
     * In case the Creator found by the `where` argument doesn't exist, create a new Creator with this data.
     * 
    **/
    create: XOR<CreatorCreateInput, CreatorUncheckedCreateInput>
    /**
     * In case the Creator was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CreatorUpdateInput, CreatorUncheckedUpdateInput>
  }


  /**
   * Creator delete
   */
  export type CreatorDeleteArgs = {
    /**
     * Select specific fields to fetch from the Creator
     * 
    **/
    select?: CreatorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreatorInclude | null
    /**
     * Filter which Creator to delete.
     * 
    **/
    where: CreatorWhereUniqueInput
  }


  /**
   * Creator deleteMany
   */
  export type CreatorDeleteManyArgs = {
    /**
     * Filter which Creators to delete
     * 
    **/
    where?: CreatorWhereInput
  }


  /**
   * Creator: findUniqueOrThrow
   */
  export type CreatorFindUniqueOrThrowArgs = CreatorFindUniqueArgsBase
      

  /**
   * Creator: findFirstOrThrow
   */
  export type CreatorFindFirstOrThrowArgs = CreatorFindFirstArgsBase
      

  /**
   * Creator without action
   */
  export type CreatorArgs = {
    /**
     * Select specific fields to fetch from the Creator
     * 
    **/
    select?: CreatorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreatorInclude | null
  }



  /**
   * Model CreatorAuth
   */


  export type AggregateCreatorAuth = {
    _count: CreatorAuthCountAggregateOutputType | null
    _avg: CreatorAuthAvgAggregateOutputType | null
    _sum: CreatorAuthSumAggregateOutputType | null
    _min: CreatorAuthMinAggregateOutputType | null
    _max: CreatorAuthMaxAggregateOutputType | null
  }

  export type CreatorAuthAvgAggregateOutputType = {
    id: number | null
    creatorId: number | null
  }

  export type CreatorAuthSumAggregateOutputType = {
    id: bigint | null
    creatorId: bigint | null
  }

  export type CreatorAuthMinAggregateOutputType = {
    id: bigint | null
    creatorId: bigint | null
    isMain: boolean | null
    profileUrl: string | null
    platform: AuthPlatformType | null
    createdAt: Date | null
  }

  export type CreatorAuthMaxAggregateOutputType = {
    id: bigint | null
    creatorId: bigint | null
    isMain: boolean | null
    profileUrl: string | null
    platform: AuthPlatformType | null
    createdAt: Date | null
  }

  export type CreatorAuthCountAggregateOutputType = {
    id: number
    creatorId: number
    isMain: number
    profileUrl: number
    platform: number
    createdAt: number
    _all: number
  }


  export type CreatorAuthAvgAggregateInputType = {
    id?: true
    creatorId?: true
  }

  export type CreatorAuthSumAggregateInputType = {
    id?: true
    creatorId?: true
  }

  export type CreatorAuthMinAggregateInputType = {
    id?: true
    creatorId?: true
    isMain?: true
    profileUrl?: true
    platform?: true
    createdAt?: true
  }

  export type CreatorAuthMaxAggregateInputType = {
    id?: true
    creatorId?: true
    isMain?: true
    profileUrl?: true
    platform?: true
    createdAt?: true
  }

  export type CreatorAuthCountAggregateInputType = {
    id?: true
    creatorId?: true
    isMain?: true
    profileUrl?: true
    platform?: true
    createdAt?: true
    _all?: true
  }

  export type CreatorAuthAggregateArgs = {
    /**
     * Filter which CreatorAuth to aggregate.
     * 
    **/
    where?: CreatorAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreatorAuths to fetch.
     * 
    **/
    orderBy?: Enumerable<CreatorAuthOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CreatorAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreatorAuths from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreatorAuths.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CreatorAuths
    **/
    _count?: true | CreatorAuthCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CreatorAuthAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CreatorAuthSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreatorAuthMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreatorAuthMaxAggregateInputType
  }

  export type GetCreatorAuthAggregateType<T extends CreatorAuthAggregateArgs> = {
        [P in keyof T & keyof AggregateCreatorAuth]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreatorAuth[P]>
      : GetScalarType<T[P], AggregateCreatorAuth[P]>
  }




  export type CreatorAuthGroupByArgs = {
    where?: CreatorAuthWhereInput
    orderBy?: Enumerable<CreatorAuthOrderByWithAggregationInput>
    by: Array<CreatorAuthScalarFieldEnum>
    having?: CreatorAuthScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreatorAuthCountAggregateInputType | true
    _avg?: CreatorAuthAvgAggregateInputType
    _sum?: CreatorAuthSumAggregateInputType
    _min?: CreatorAuthMinAggregateInputType
    _max?: CreatorAuthMaxAggregateInputType
  }


  export type CreatorAuthGroupByOutputType = {
    id: bigint
    creatorId: bigint
    isMain: boolean
    profileUrl: string | null
    platform: AuthPlatformType
    createdAt: Date
    _count: CreatorAuthCountAggregateOutputType | null
    _avg: CreatorAuthAvgAggregateOutputType | null
    _sum: CreatorAuthSumAggregateOutputType | null
    _min: CreatorAuthMinAggregateOutputType | null
    _max: CreatorAuthMaxAggregateOutputType | null
  }

  type GetCreatorAuthGroupByPayload<T extends CreatorAuthGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CreatorAuthGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreatorAuthGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreatorAuthGroupByOutputType[P]>
            : GetScalarType<T[P], CreatorAuthGroupByOutputType[P]>
        }
      >
    >


  export type CreatorAuthSelect = {
    id?: boolean
    creator?: boolean | CreatorArgs
    creatorId?: boolean
    isMain?: boolean
    profileUrl?: boolean
    platform?: boolean
    createdAt?: boolean
  }

  export type CreatorAuthInclude = {
    creator?: boolean | CreatorArgs
  }

  export type CreatorAuthGetPayload<
    S extends boolean | null | undefined | CreatorAuthArgs,
    U = keyof S
      > = S extends true
        ? CreatorAuth
    : S extends undefined
    ? never
    : S extends CreatorAuthArgs | CreatorAuthFindManyArgs
    ?'include' extends U
    ? CreatorAuth  & {
    [P in TrueKeys<S['include']>]:
        P extends 'creator' ? CreatorGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'creator' ? CreatorGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof CreatorAuth ? CreatorAuth[P] : never
  } 
    : CreatorAuth
  : CreatorAuth


  type CreatorAuthCountArgs = Merge<
    Omit<CreatorAuthFindManyArgs, 'select' | 'include'> & {
      select?: CreatorAuthCountAggregateInputType | true
    }
  >

  export interface CreatorAuthDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one CreatorAuth that matches the filter.
     * @param {CreatorAuthFindUniqueArgs} args - Arguments to find a CreatorAuth
     * @example
     * // Get one CreatorAuth
     * const creatorAuth = await prisma.creatorAuth.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CreatorAuthFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CreatorAuthFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CreatorAuth'> extends True ? CheckSelect<T, Prisma__CreatorAuthClient<CreatorAuth>, Prisma__CreatorAuthClient<CreatorAuthGetPayload<T>>> : CheckSelect<T, Prisma__CreatorAuthClient<CreatorAuth | null, null>, Prisma__CreatorAuthClient<CreatorAuthGetPayload<T> | null, null>>

    /**
     * Find the first CreatorAuth that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorAuthFindFirstArgs} args - Arguments to find a CreatorAuth
     * @example
     * // Get one CreatorAuth
     * const creatorAuth = await prisma.creatorAuth.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CreatorAuthFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CreatorAuthFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CreatorAuth'> extends True ? CheckSelect<T, Prisma__CreatorAuthClient<CreatorAuth>, Prisma__CreatorAuthClient<CreatorAuthGetPayload<T>>> : CheckSelect<T, Prisma__CreatorAuthClient<CreatorAuth | null, null>, Prisma__CreatorAuthClient<CreatorAuthGetPayload<T> | null, null>>

    /**
     * Find zero or more CreatorAuths that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorAuthFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CreatorAuths
     * const creatorAuths = await prisma.creatorAuth.findMany()
     * 
     * // Get first 10 CreatorAuths
     * const creatorAuths = await prisma.creatorAuth.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const creatorAuthWithIdOnly = await prisma.creatorAuth.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CreatorAuthFindManyArgs>(
      args?: SelectSubset<T, CreatorAuthFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CreatorAuth>>, PrismaPromise<Array<CreatorAuthGetPayload<T>>>>

    /**
     * Create a CreatorAuth.
     * @param {CreatorAuthCreateArgs} args - Arguments to create a CreatorAuth.
     * @example
     * // Create one CreatorAuth
     * const CreatorAuth = await prisma.creatorAuth.create({
     *   data: {
     *     // ... data to create a CreatorAuth
     *   }
     * })
     * 
    **/
    create<T extends CreatorAuthCreateArgs>(
      args: SelectSubset<T, CreatorAuthCreateArgs>
    ): CheckSelect<T, Prisma__CreatorAuthClient<CreatorAuth>, Prisma__CreatorAuthClient<CreatorAuthGetPayload<T>>>

    /**
     * Create many CreatorAuths.
     *     @param {CreatorAuthCreateManyArgs} args - Arguments to create many CreatorAuths.
     *     @example
     *     // Create many CreatorAuths
     *     const creatorAuth = await prisma.creatorAuth.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CreatorAuthCreateManyArgs>(
      args?: SelectSubset<T, CreatorAuthCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CreatorAuth.
     * @param {CreatorAuthDeleteArgs} args - Arguments to delete one CreatorAuth.
     * @example
     * // Delete one CreatorAuth
     * const CreatorAuth = await prisma.creatorAuth.delete({
     *   where: {
     *     // ... filter to delete one CreatorAuth
     *   }
     * })
     * 
    **/
    delete<T extends CreatorAuthDeleteArgs>(
      args: SelectSubset<T, CreatorAuthDeleteArgs>
    ): CheckSelect<T, Prisma__CreatorAuthClient<CreatorAuth>, Prisma__CreatorAuthClient<CreatorAuthGetPayload<T>>>

    /**
     * Update one CreatorAuth.
     * @param {CreatorAuthUpdateArgs} args - Arguments to update one CreatorAuth.
     * @example
     * // Update one CreatorAuth
     * const creatorAuth = await prisma.creatorAuth.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CreatorAuthUpdateArgs>(
      args: SelectSubset<T, CreatorAuthUpdateArgs>
    ): CheckSelect<T, Prisma__CreatorAuthClient<CreatorAuth>, Prisma__CreatorAuthClient<CreatorAuthGetPayload<T>>>

    /**
     * Delete zero or more CreatorAuths.
     * @param {CreatorAuthDeleteManyArgs} args - Arguments to filter CreatorAuths to delete.
     * @example
     * // Delete a few CreatorAuths
     * const { count } = await prisma.creatorAuth.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CreatorAuthDeleteManyArgs>(
      args?: SelectSubset<T, CreatorAuthDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreatorAuths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorAuthUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CreatorAuths
     * const creatorAuth = await prisma.creatorAuth.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CreatorAuthUpdateManyArgs>(
      args: SelectSubset<T, CreatorAuthUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CreatorAuth.
     * @param {CreatorAuthUpsertArgs} args - Arguments to update or create a CreatorAuth.
     * @example
     * // Update or create a CreatorAuth
     * const creatorAuth = await prisma.creatorAuth.upsert({
     *   create: {
     *     // ... data to create a CreatorAuth
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CreatorAuth we want to update
     *   }
     * })
    **/
    upsert<T extends CreatorAuthUpsertArgs>(
      args: SelectSubset<T, CreatorAuthUpsertArgs>
    ): CheckSelect<T, Prisma__CreatorAuthClient<CreatorAuth>, Prisma__CreatorAuthClient<CreatorAuthGetPayload<T>>>

    /**
     * Find one CreatorAuth that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {CreatorAuthFindUniqueOrThrowArgs} args - Arguments to find a CreatorAuth
     * @example
     * // Get one CreatorAuth
     * const creatorAuth = await prisma.creatorAuth.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CreatorAuthFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CreatorAuthFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__CreatorAuthClient<CreatorAuth>, Prisma__CreatorAuthClient<CreatorAuthGetPayload<T>>>

    /**
     * Find the first CreatorAuth that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorAuthFindFirstOrThrowArgs} args - Arguments to find a CreatorAuth
     * @example
     * // Get one CreatorAuth
     * const creatorAuth = await prisma.creatorAuth.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CreatorAuthFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CreatorAuthFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__CreatorAuthClient<CreatorAuth>, Prisma__CreatorAuthClient<CreatorAuthGetPayload<T>>>

    /**
     * Count the number of CreatorAuths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorAuthCountArgs} args - Arguments to filter CreatorAuths to count.
     * @example
     * // Count the number of CreatorAuths
     * const count = await prisma.creatorAuth.count({
     *   where: {
     *     // ... the filter for the CreatorAuths we want to count
     *   }
     * })
    **/
    count<T extends CreatorAuthCountArgs>(
      args?: Subset<T, CreatorAuthCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreatorAuthCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CreatorAuth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorAuthAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreatorAuthAggregateArgs>(args: Subset<T, CreatorAuthAggregateArgs>): PrismaPromise<GetCreatorAuthAggregateType<T>>

    /**
     * Group by CreatorAuth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorAuthGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreatorAuthGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreatorAuthGroupByArgs['orderBy'] }
        : { orderBy?: CreatorAuthGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreatorAuthGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreatorAuthGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for CreatorAuth.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CreatorAuthClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    creator<T extends CreatorArgs = {}>(args?: Subset<T, CreatorArgs>): CheckSelect<T, Prisma__CreatorClient<Creator | Null>, Prisma__CreatorClient<CreatorGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * CreatorAuth base type for findUnique actions
   */
  export type CreatorAuthFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the CreatorAuth
     * 
    **/
    select?: CreatorAuthSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreatorAuthInclude | null
    /**
     * Filter, which CreatorAuth to fetch.
     * 
    **/
    where: CreatorAuthWhereUniqueInput
  }

  /**
   * CreatorAuth: findUnique
   */
  export interface CreatorAuthFindUniqueArgs extends CreatorAuthFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CreatorAuth base type for findFirst actions
   */
  export type CreatorAuthFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the CreatorAuth
     * 
    **/
    select?: CreatorAuthSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreatorAuthInclude | null
    /**
     * Filter, which CreatorAuth to fetch.
     * 
    **/
    where?: CreatorAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreatorAuths to fetch.
     * 
    **/
    orderBy?: Enumerable<CreatorAuthOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreatorAuths.
     * 
    **/
    cursor?: CreatorAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreatorAuths from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreatorAuths.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreatorAuths.
     * 
    **/
    distinct?: Enumerable<CreatorAuthScalarFieldEnum>
  }

  /**
   * CreatorAuth: findFirst
   */
  export interface CreatorAuthFindFirstArgs extends CreatorAuthFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CreatorAuth findMany
   */
  export type CreatorAuthFindManyArgs = {
    /**
     * Select specific fields to fetch from the CreatorAuth
     * 
    **/
    select?: CreatorAuthSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreatorAuthInclude | null
    /**
     * Filter, which CreatorAuths to fetch.
     * 
    **/
    where?: CreatorAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreatorAuths to fetch.
     * 
    **/
    orderBy?: Enumerable<CreatorAuthOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CreatorAuths.
     * 
    **/
    cursor?: CreatorAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreatorAuths from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreatorAuths.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CreatorAuthScalarFieldEnum>
  }


  /**
   * CreatorAuth create
   */
  export type CreatorAuthCreateArgs = {
    /**
     * Select specific fields to fetch from the CreatorAuth
     * 
    **/
    select?: CreatorAuthSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreatorAuthInclude | null
    /**
     * The data needed to create a CreatorAuth.
     * 
    **/
    data: XOR<CreatorAuthCreateInput, CreatorAuthUncheckedCreateInput>
  }


  /**
   * CreatorAuth createMany
   */
  export type CreatorAuthCreateManyArgs = {
    /**
     * The data used to create many CreatorAuths.
     * 
    **/
    data: Enumerable<CreatorAuthCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CreatorAuth update
   */
  export type CreatorAuthUpdateArgs = {
    /**
     * Select specific fields to fetch from the CreatorAuth
     * 
    **/
    select?: CreatorAuthSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreatorAuthInclude | null
    /**
     * The data needed to update a CreatorAuth.
     * 
    **/
    data: XOR<CreatorAuthUpdateInput, CreatorAuthUncheckedUpdateInput>
    /**
     * Choose, which CreatorAuth to update.
     * 
    **/
    where: CreatorAuthWhereUniqueInput
  }


  /**
   * CreatorAuth updateMany
   */
  export type CreatorAuthUpdateManyArgs = {
    /**
     * The data used to update CreatorAuths.
     * 
    **/
    data: XOR<CreatorAuthUpdateManyMutationInput, CreatorAuthUncheckedUpdateManyInput>
    /**
     * Filter which CreatorAuths to update
     * 
    **/
    where?: CreatorAuthWhereInput
  }


  /**
   * CreatorAuth upsert
   */
  export type CreatorAuthUpsertArgs = {
    /**
     * Select specific fields to fetch from the CreatorAuth
     * 
    **/
    select?: CreatorAuthSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreatorAuthInclude | null
    /**
     * The filter to search for the CreatorAuth to update in case it exists.
     * 
    **/
    where: CreatorAuthWhereUniqueInput
    /**
     * In case the CreatorAuth found by the `where` argument doesn't exist, create a new CreatorAuth with this data.
     * 
    **/
    create: XOR<CreatorAuthCreateInput, CreatorAuthUncheckedCreateInput>
    /**
     * In case the CreatorAuth was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CreatorAuthUpdateInput, CreatorAuthUncheckedUpdateInput>
  }


  /**
   * CreatorAuth delete
   */
  export type CreatorAuthDeleteArgs = {
    /**
     * Select specific fields to fetch from the CreatorAuth
     * 
    **/
    select?: CreatorAuthSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreatorAuthInclude | null
    /**
     * Filter which CreatorAuth to delete.
     * 
    **/
    where: CreatorAuthWhereUniqueInput
  }


  /**
   * CreatorAuth deleteMany
   */
  export type CreatorAuthDeleteManyArgs = {
    /**
     * Filter which CreatorAuths to delete
     * 
    **/
    where?: CreatorAuthWhereInput
  }


  /**
   * CreatorAuth: findUniqueOrThrow
   */
  export type CreatorAuthFindUniqueOrThrowArgs = CreatorAuthFindUniqueArgsBase
      

  /**
   * CreatorAuth: findFirstOrThrow
   */
  export type CreatorAuthFindFirstOrThrowArgs = CreatorAuthFindFirstArgsBase
      

  /**
   * CreatorAuth without action
   */
  export type CreatorAuthArgs = {
    /**
     * Select specific fields to fetch from the CreatorAuth
     * 
    **/
    select?: CreatorAuthSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreatorAuthInclude | null
  }



  /**
   * Model CreatorReview
   */


  export type AggregateCreatorReview = {
    _count: CreatorReviewCountAggregateOutputType | null
    _avg: CreatorReviewAvgAggregateOutputType | null
    _sum: CreatorReviewSumAggregateOutputType | null
    _min: CreatorReviewMinAggregateOutputType | null
    _max: CreatorReviewMaxAggregateOutputType | null
  }

  export type CreatorReviewAvgAggregateOutputType = {
    id: number | null
    creatorId: number | null
  }

  export type CreatorReviewSumAggregateOutputType = {
    id: bigint | null
    creatorId: bigint | null
  }

  export type CreatorReviewMinAggregateOutputType = {
    id: bigint | null
    creatorId: bigint | null
    userId: string | null
    content: string | null
    createdAt: Date | null
  }

  export type CreatorReviewMaxAggregateOutputType = {
    id: bigint | null
    creatorId: bigint | null
    userId: string | null
    content: string | null
    createdAt: Date | null
  }

  export type CreatorReviewCountAggregateOutputType = {
    id: number
    creatorId: number
    userId: number
    content: number
    createdAt: number
    _all: number
  }


  export type CreatorReviewAvgAggregateInputType = {
    id?: true
    creatorId?: true
  }

  export type CreatorReviewSumAggregateInputType = {
    id?: true
    creatorId?: true
  }

  export type CreatorReviewMinAggregateInputType = {
    id?: true
    creatorId?: true
    userId?: true
    content?: true
    createdAt?: true
  }

  export type CreatorReviewMaxAggregateInputType = {
    id?: true
    creatorId?: true
    userId?: true
    content?: true
    createdAt?: true
  }

  export type CreatorReviewCountAggregateInputType = {
    id?: true
    creatorId?: true
    userId?: true
    content?: true
    createdAt?: true
    _all?: true
  }

  export type CreatorReviewAggregateArgs = {
    /**
     * Filter which CreatorReview to aggregate.
     * 
    **/
    where?: CreatorReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreatorReviews to fetch.
     * 
    **/
    orderBy?: Enumerable<CreatorReviewOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CreatorReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreatorReviews from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreatorReviews.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CreatorReviews
    **/
    _count?: true | CreatorReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CreatorReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CreatorReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreatorReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreatorReviewMaxAggregateInputType
  }

  export type GetCreatorReviewAggregateType<T extends CreatorReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateCreatorReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreatorReview[P]>
      : GetScalarType<T[P], AggregateCreatorReview[P]>
  }




  export type CreatorReviewGroupByArgs = {
    where?: CreatorReviewWhereInput
    orderBy?: Enumerable<CreatorReviewOrderByWithAggregationInput>
    by: Array<CreatorReviewScalarFieldEnum>
    having?: CreatorReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreatorReviewCountAggregateInputType | true
    _avg?: CreatorReviewAvgAggregateInputType
    _sum?: CreatorReviewSumAggregateInputType
    _min?: CreatorReviewMinAggregateInputType
    _max?: CreatorReviewMaxAggregateInputType
  }


  export type CreatorReviewGroupByOutputType = {
    id: bigint
    creatorId: bigint
    userId: string | null
    content: string | null
    createdAt: Date
    _count: CreatorReviewCountAggregateOutputType | null
    _avg: CreatorReviewAvgAggregateOutputType | null
    _sum: CreatorReviewSumAggregateOutputType | null
    _min: CreatorReviewMinAggregateOutputType | null
    _max: CreatorReviewMaxAggregateOutputType | null
  }

  type GetCreatorReviewGroupByPayload<T extends CreatorReviewGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CreatorReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreatorReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreatorReviewGroupByOutputType[P]>
            : GetScalarType<T[P], CreatorReviewGroupByOutputType[P]>
        }
      >
    >


  export type CreatorReviewSelect = {
    id?: boolean
    creator?: boolean | CreatorArgs
    creatorId?: boolean
    user?: boolean | UserArgs
    userId?: boolean
    reviewItems?: boolean | CreatorReviewItemFindManyArgs
    content?: boolean
    createdAt?: boolean
    _count?: boolean | CreatorReviewCountOutputTypeArgs
  }

  export type CreatorReviewInclude = {
    creator?: boolean | CreatorArgs
    user?: boolean | UserArgs
    reviewItems?: boolean | CreatorReviewItemFindManyArgs
    _count?: boolean | CreatorReviewCountOutputTypeArgs
  }

  export type CreatorReviewGetPayload<
    S extends boolean | null | undefined | CreatorReviewArgs,
    U = keyof S
      > = S extends true
        ? CreatorReview
    : S extends undefined
    ? never
    : S extends CreatorReviewArgs | CreatorReviewFindManyArgs
    ?'include' extends U
    ? CreatorReview  & {
    [P in TrueKeys<S['include']>]:
        P extends 'creator' ? CreatorGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'reviewItems' ? Array < CreatorReviewItemGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? CreatorReviewCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'creator' ? CreatorGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'reviewItems' ? Array < CreatorReviewItemGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? CreatorReviewCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof CreatorReview ? CreatorReview[P] : never
  } 
    : CreatorReview
  : CreatorReview


  type CreatorReviewCountArgs = Merge<
    Omit<CreatorReviewFindManyArgs, 'select' | 'include'> & {
      select?: CreatorReviewCountAggregateInputType | true
    }
  >

  export interface CreatorReviewDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one CreatorReview that matches the filter.
     * @param {CreatorReviewFindUniqueArgs} args - Arguments to find a CreatorReview
     * @example
     * // Get one CreatorReview
     * const creatorReview = await prisma.creatorReview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CreatorReviewFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CreatorReviewFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CreatorReview'> extends True ? CheckSelect<T, Prisma__CreatorReviewClient<CreatorReview>, Prisma__CreatorReviewClient<CreatorReviewGetPayload<T>>> : CheckSelect<T, Prisma__CreatorReviewClient<CreatorReview | null, null>, Prisma__CreatorReviewClient<CreatorReviewGetPayload<T> | null, null>>

    /**
     * Find the first CreatorReview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorReviewFindFirstArgs} args - Arguments to find a CreatorReview
     * @example
     * // Get one CreatorReview
     * const creatorReview = await prisma.creatorReview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CreatorReviewFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CreatorReviewFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CreatorReview'> extends True ? CheckSelect<T, Prisma__CreatorReviewClient<CreatorReview>, Prisma__CreatorReviewClient<CreatorReviewGetPayload<T>>> : CheckSelect<T, Prisma__CreatorReviewClient<CreatorReview | null, null>, Prisma__CreatorReviewClient<CreatorReviewGetPayload<T> | null, null>>

    /**
     * Find zero or more CreatorReviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorReviewFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CreatorReviews
     * const creatorReviews = await prisma.creatorReview.findMany()
     * 
     * // Get first 10 CreatorReviews
     * const creatorReviews = await prisma.creatorReview.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const creatorReviewWithIdOnly = await prisma.creatorReview.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CreatorReviewFindManyArgs>(
      args?: SelectSubset<T, CreatorReviewFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CreatorReview>>, PrismaPromise<Array<CreatorReviewGetPayload<T>>>>

    /**
     * Create a CreatorReview.
     * @param {CreatorReviewCreateArgs} args - Arguments to create a CreatorReview.
     * @example
     * // Create one CreatorReview
     * const CreatorReview = await prisma.creatorReview.create({
     *   data: {
     *     // ... data to create a CreatorReview
     *   }
     * })
     * 
    **/
    create<T extends CreatorReviewCreateArgs>(
      args: SelectSubset<T, CreatorReviewCreateArgs>
    ): CheckSelect<T, Prisma__CreatorReviewClient<CreatorReview>, Prisma__CreatorReviewClient<CreatorReviewGetPayload<T>>>

    /**
     * Create many CreatorReviews.
     *     @param {CreatorReviewCreateManyArgs} args - Arguments to create many CreatorReviews.
     *     @example
     *     // Create many CreatorReviews
     *     const creatorReview = await prisma.creatorReview.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CreatorReviewCreateManyArgs>(
      args?: SelectSubset<T, CreatorReviewCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CreatorReview.
     * @param {CreatorReviewDeleteArgs} args - Arguments to delete one CreatorReview.
     * @example
     * // Delete one CreatorReview
     * const CreatorReview = await prisma.creatorReview.delete({
     *   where: {
     *     // ... filter to delete one CreatorReview
     *   }
     * })
     * 
    **/
    delete<T extends CreatorReviewDeleteArgs>(
      args: SelectSubset<T, CreatorReviewDeleteArgs>
    ): CheckSelect<T, Prisma__CreatorReviewClient<CreatorReview>, Prisma__CreatorReviewClient<CreatorReviewGetPayload<T>>>

    /**
     * Update one CreatorReview.
     * @param {CreatorReviewUpdateArgs} args - Arguments to update one CreatorReview.
     * @example
     * // Update one CreatorReview
     * const creatorReview = await prisma.creatorReview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CreatorReviewUpdateArgs>(
      args: SelectSubset<T, CreatorReviewUpdateArgs>
    ): CheckSelect<T, Prisma__CreatorReviewClient<CreatorReview>, Prisma__CreatorReviewClient<CreatorReviewGetPayload<T>>>

    /**
     * Delete zero or more CreatorReviews.
     * @param {CreatorReviewDeleteManyArgs} args - Arguments to filter CreatorReviews to delete.
     * @example
     * // Delete a few CreatorReviews
     * const { count } = await prisma.creatorReview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CreatorReviewDeleteManyArgs>(
      args?: SelectSubset<T, CreatorReviewDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreatorReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CreatorReviews
     * const creatorReview = await prisma.creatorReview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CreatorReviewUpdateManyArgs>(
      args: SelectSubset<T, CreatorReviewUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CreatorReview.
     * @param {CreatorReviewUpsertArgs} args - Arguments to update or create a CreatorReview.
     * @example
     * // Update or create a CreatorReview
     * const creatorReview = await prisma.creatorReview.upsert({
     *   create: {
     *     // ... data to create a CreatorReview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CreatorReview we want to update
     *   }
     * })
    **/
    upsert<T extends CreatorReviewUpsertArgs>(
      args: SelectSubset<T, CreatorReviewUpsertArgs>
    ): CheckSelect<T, Prisma__CreatorReviewClient<CreatorReview>, Prisma__CreatorReviewClient<CreatorReviewGetPayload<T>>>

    /**
     * Find one CreatorReview that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {CreatorReviewFindUniqueOrThrowArgs} args - Arguments to find a CreatorReview
     * @example
     * // Get one CreatorReview
     * const creatorReview = await prisma.creatorReview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CreatorReviewFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CreatorReviewFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__CreatorReviewClient<CreatorReview>, Prisma__CreatorReviewClient<CreatorReviewGetPayload<T>>>

    /**
     * Find the first CreatorReview that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorReviewFindFirstOrThrowArgs} args - Arguments to find a CreatorReview
     * @example
     * // Get one CreatorReview
     * const creatorReview = await prisma.creatorReview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CreatorReviewFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CreatorReviewFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__CreatorReviewClient<CreatorReview>, Prisma__CreatorReviewClient<CreatorReviewGetPayload<T>>>

    /**
     * Count the number of CreatorReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorReviewCountArgs} args - Arguments to filter CreatorReviews to count.
     * @example
     * // Count the number of CreatorReviews
     * const count = await prisma.creatorReview.count({
     *   where: {
     *     // ... the filter for the CreatorReviews we want to count
     *   }
     * })
    **/
    count<T extends CreatorReviewCountArgs>(
      args?: Subset<T, CreatorReviewCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreatorReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CreatorReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreatorReviewAggregateArgs>(args: Subset<T, CreatorReviewAggregateArgs>): PrismaPromise<GetCreatorReviewAggregateType<T>>

    /**
     * Group by CreatorReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreatorReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreatorReviewGroupByArgs['orderBy'] }
        : { orderBy?: CreatorReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreatorReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreatorReviewGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for CreatorReview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CreatorReviewClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    creator<T extends CreatorArgs = {}>(args?: Subset<T, CreatorArgs>): CheckSelect<T, Prisma__CreatorClient<Creator | Null>, Prisma__CreatorClient<CreatorGetPayload<T> | Null>>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | Null>, Prisma__UserClient<UserGetPayload<T> | Null>>;

    reviewItems<T extends CreatorReviewItemFindManyArgs = {}>(args?: Subset<T, CreatorReviewItemFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CreatorReviewItem>| Null>, PrismaPromise<Array<CreatorReviewItemGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * CreatorReview base type for findUnique actions
   */
  export type CreatorReviewFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the CreatorReview
     * 
    **/
    select?: CreatorReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreatorReviewInclude | null
    /**
     * Filter, which CreatorReview to fetch.
     * 
    **/
    where: CreatorReviewWhereUniqueInput
  }

  /**
   * CreatorReview: findUnique
   */
  export interface CreatorReviewFindUniqueArgs extends CreatorReviewFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CreatorReview base type for findFirst actions
   */
  export type CreatorReviewFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the CreatorReview
     * 
    **/
    select?: CreatorReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreatorReviewInclude | null
    /**
     * Filter, which CreatorReview to fetch.
     * 
    **/
    where?: CreatorReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreatorReviews to fetch.
     * 
    **/
    orderBy?: Enumerable<CreatorReviewOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreatorReviews.
     * 
    **/
    cursor?: CreatorReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreatorReviews from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreatorReviews.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreatorReviews.
     * 
    **/
    distinct?: Enumerable<CreatorReviewScalarFieldEnum>
  }

  /**
   * CreatorReview: findFirst
   */
  export interface CreatorReviewFindFirstArgs extends CreatorReviewFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CreatorReview findMany
   */
  export type CreatorReviewFindManyArgs = {
    /**
     * Select specific fields to fetch from the CreatorReview
     * 
    **/
    select?: CreatorReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreatorReviewInclude | null
    /**
     * Filter, which CreatorReviews to fetch.
     * 
    **/
    where?: CreatorReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreatorReviews to fetch.
     * 
    **/
    orderBy?: Enumerable<CreatorReviewOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CreatorReviews.
     * 
    **/
    cursor?: CreatorReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreatorReviews from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreatorReviews.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CreatorReviewScalarFieldEnum>
  }


  /**
   * CreatorReview create
   */
  export type CreatorReviewCreateArgs = {
    /**
     * Select specific fields to fetch from the CreatorReview
     * 
    **/
    select?: CreatorReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreatorReviewInclude | null
    /**
     * The data needed to create a CreatorReview.
     * 
    **/
    data: XOR<CreatorReviewCreateInput, CreatorReviewUncheckedCreateInput>
  }


  /**
   * CreatorReview createMany
   */
  export type CreatorReviewCreateManyArgs = {
    /**
     * The data used to create many CreatorReviews.
     * 
    **/
    data: Enumerable<CreatorReviewCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CreatorReview update
   */
  export type CreatorReviewUpdateArgs = {
    /**
     * Select specific fields to fetch from the CreatorReview
     * 
    **/
    select?: CreatorReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreatorReviewInclude | null
    /**
     * The data needed to update a CreatorReview.
     * 
    **/
    data: XOR<CreatorReviewUpdateInput, CreatorReviewUncheckedUpdateInput>
    /**
     * Choose, which CreatorReview to update.
     * 
    **/
    where: CreatorReviewWhereUniqueInput
  }


  /**
   * CreatorReview updateMany
   */
  export type CreatorReviewUpdateManyArgs = {
    /**
     * The data used to update CreatorReviews.
     * 
    **/
    data: XOR<CreatorReviewUpdateManyMutationInput, CreatorReviewUncheckedUpdateManyInput>
    /**
     * Filter which CreatorReviews to update
     * 
    **/
    where?: CreatorReviewWhereInput
  }


  /**
   * CreatorReview upsert
   */
  export type CreatorReviewUpsertArgs = {
    /**
     * Select specific fields to fetch from the CreatorReview
     * 
    **/
    select?: CreatorReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreatorReviewInclude | null
    /**
     * The filter to search for the CreatorReview to update in case it exists.
     * 
    **/
    where: CreatorReviewWhereUniqueInput
    /**
     * In case the CreatorReview found by the `where` argument doesn't exist, create a new CreatorReview with this data.
     * 
    **/
    create: XOR<CreatorReviewCreateInput, CreatorReviewUncheckedCreateInput>
    /**
     * In case the CreatorReview was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CreatorReviewUpdateInput, CreatorReviewUncheckedUpdateInput>
  }


  /**
   * CreatorReview delete
   */
  export type CreatorReviewDeleteArgs = {
    /**
     * Select specific fields to fetch from the CreatorReview
     * 
    **/
    select?: CreatorReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreatorReviewInclude | null
    /**
     * Filter which CreatorReview to delete.
     * 
    **/
    where: CreatorReviewWhereUniqueInput
  }


  /**
   * CreatorReview deleteMany
   */
  export type CreatorReviewDeleteManyArgs = {
    /**
     * Filter which CreatorReviews to delete
     * 
    **/
    where?: CreatorReviewWhereInput
  }


  /**
   * CreatorReview: findUniqueOrThrow
   */
  export type CreatorReviewFindUniqueOrThrowArgs = CreatorReviewFindUniqueArgsBase
      

  /**
   * CreatorReview: findFirstOrThrow
   */
  export type CreatorReviewFindFirstOrThrowArgs = CreatorReviewFindFirstArgsBase
      

  /**
   * CreatorReview without action
   */
  export type CreatorReviewArgs = {
    /**
     * Select specific fields to fetch from the CreatorReview
     * 
    **/
    select?: CreatorReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreatorReviewInclude | null
  }



  /**
   * Model CreatorReviewItem
   */


  export type AggregateCreatorReviewItem = {
    _count: CreatorReviewItemCountAggregateOutputType | null
    _avg: CreatorReviewItemAvgAggregateOutputType | null
    _sum: CreatorReviewItemSumAggregateOutputType | null
    _min: CreatorReviewItemMinAggregateOutputType | null
    _max: CreatorReviewItemMaxAggregateOutputType | null
  }

  export type CreatorReviewItemAvgAggregateOutputType = {
    id: number | null
    reviewId: number | null
  }

  export type CreatorReviewItemSumAggregateOutputType = {
    id: bigint | null
    reviewId: bigint | null
  }

  export type CreatorReviewItemMinAggregateOutputType = {
    id: bigint | null
    reviewId: bigint | null
    content: string | null
    isChecked: boolean | null
  }

  export type CreatorReviewItemMaxAggregateOutputType = {
    id: bigint | null
    reviewId: bigint | null
    content: string | null
    isChecked: boolean | null
  }

  export type CreatorReviewItemCountAggregateOutputType = {
    id: number
    reviewId: number
    content: number
    isChecked: number
    _all: number
  }


  export type CreatorReviewItemAvgAggregateInputType = {
    id?: true
    reviewId?: true
  }

  export type CreatorReviewItemSumAggregateInputType = {
    id?: true
    reviewId?: true
  }

  export type CreatorReviewItemMinAggregateInputType = {
    id?: true
    reviewId?: true
    content?: true
    isChecked?: true
  }

  export type CreatorReviewItemMaxAggregateInputType = {
    id?: true
    reviewId?: true
    content?: true
    isChecked?: true
  }

  export type CreatorReviewItemCountAggregateInputType = {
    id?: true
    reviewId?: true
    content?: true
    isChecked?: true
    _all?: true
  }

  export type CreatorReviewItemAggregateArgs = {
    /**
     * Filter which CreatorReviewItem to aggregate.
     * 
    **/
    where?: CreatorReviewItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreatorReviewItems to fetch.
     * 
    **/
    orderBy?: Enumerable<CreatorReviewItemOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CreatorReviewItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreatorReviewItems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreatorReviewItems.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CreatorReviewItems
    **/
    _count?: true | CreatorReviewItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CreatorReviewItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CreatorReviewItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreatorReviewItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreatorReviewItemMaxAggregateInputType
  }

  export type GetCreatorReviewItemAggregateType<T extends CreatorReviewItemAggregateArgs> = {
        [P in keyof T & keyof AggregateCreatorReviewItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreatorReviewItem[P]>
      : GetScalarType<T[P], AggregateCreatorReviewItem[P]>
  }




  export type CreatorReviewItemGroupByArgs = {
    where?: CreatorReviewItemWhereInput
    orderBy?: Enumerable<CreatorReviewItemOrderByWithAggregationInput>
    by: Array<CreatorReviewItemScalarFieldEnum>
    having?: CreatorReviewItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreatorReviewItemCountAggregateInputType | true
    _avg?: CreatorReviewItemAvgAggregateInputType
    _sum?: CreatorReviewItemSumAggregateInputType
    _min?: CreatorReviewItemMinAggregateInputType
    _max?: CreatorReviewItemMaxAggregateInputType
  }


  export type CreatorReviewItemGroupByOutputType = {
    id: bigint
    reviewId: bigint
    content: string
    isChecked: boolean
    _count: CreatorReviewItemCountAggregateOutputType | null
    _avg: CreatorReviewItemAvgAggregateOutputType | null
    _sum: CreatorReviewItemSumAggregateOutputType | null
    _min: CreatorReviewItemMinAggregateOutputType | null
    _max: CreatorReviewItemMaxAggregateOutputType | null
  }

  type GetCreatorReviewItemGroupByPayload<T extends CreatorReviewItemGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CreatorReviewItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreatorReviewItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreatorReviewItemGroupByOutputType[P]>
            : GetScalarType<T[P], CreatorReviewItemGroupByOutputType[P]>
        }
      >
    >


  export type CreatorReviewItemSelect = {
    id?: boolean
    review?: boolean | CreatorReviewArgs
    reviewId?: boolean
    content?: boolean
    isChecked?: boolean
  }

  export type CreatorReviewItemInclude = {
    review?: boolean | CreatorReviewArgs
  }

  export type CreatorReviewItemGetPayload<
    S extends boolean | null | undefined | CreatorReviewItemArgs,
    U = keyof S
      > = S extends true
        ? CreatorReviewItem
    : S extends undefined
    ? never
    : S extends CreatorReviewItemArgs | CreatorReviewItemFindManyArgs
    ?'include' extends U
    ? CreatorReviewItem  & {
    [P in TrueKeys<S['include']>]:
        P extends 'review' ? CreatorReviewGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'review' ? CreatorReviewGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof CreatorReviewItem ? CreatorReviewItem[P] : never
  } 
    : CreatorReviewItem
  : CreatorReviewItem


  type CreatorReviewItemCountArgs = Merge<
    Omit<CreatorReviewItemFindManyArgs, 'select' | 'include'> & {
      select?: CreatorReviewItemCountAggregateInputType | true
    }
  >

  export interface CreatorReviewItemDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one CreatorReviewItem that matches the filter.
     * @param {CreatorReviewItemFindUniqueArgs} args - Arguments to find a CreatorReviewItem
     * @example
     * // Get one CreatorReviewItem
     * const creatorReviewItem = await prisma.creatorReviewItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CreatorReviewItemFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CreatorReviewItemFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CreatorReviewItem'> extends True ? CheckSelect<T, Prisma__CreatorReviewItemClient<CreatorReviewItem>, Prisma__CreatorReviewItemClient<CreatorReviewItemGetPayload<T>>> : CheckSelect<T, Prisma__CreatorReviewItemClient<CreatorReviewItem | null, null>, Prisma__CreatorReviewItemClient<CreatorReviewItemGetPayload<T> | null, null>>

    /**
     * Find the first CreatorReviewItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorReviewItemFindFirstArgs} args - Arguments to find a CreatorReviewItem
     * @example
     * // Get one CreatorReviewItem
     * const creatorReviewItem = await prisma.creatorReviewItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CreatorReviewItemFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CreatorReviewItemFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CreatorReviewItem'> extends True ? CheckSelect<T, Prisma__CreatorReviewItemClient<CreatorReviewItem>, Prisma__CreatorReviewItemClient<CreatorReviewItemGetPayload<T>>> : CheckSelect<T, Prisma__CreatorReviewItemClient<CreatorReviewItem | null, null>, Prisma__CreatorReviewItemClient<CreatorReviewItemGetPayload<T> | null, null>>

    /**
     * Find zero or more CreatorReviewItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorReviewItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CreatorReviewItems
     * const creatorReviewItems = await prisma.creatorReviewItem.findMany()
     * 
     * // Get first 10 CreatorReviewItems
     * const creatorReviewItems = await prisma.creatorReviewItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const creatorReviewItemWithIdOnly = await prisma.creatorReviewItem.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CreatorReviewItemFindManyArgs>(
      args?: SelectSubset<T, CreatorReviewItemFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CreatorReviewItem>>, PrismaPromise<Array<CreatorReviewItemGetPayload<T>>>>

    /**
     * Create a CreatorReviewItem.
     * @param {CreatorReviewItemCreateArgs} args - Arguments to create a CreatorReviewItem.
     * @example
     * // Create one CreatorReviewItem
     * const CreatorReviewItem = await prisma.creatorReviewItem.create({
     *   data: {
     *     // ... data to create a CreatorReviewItem
     *   }
     * })
     * 
    **/
    create<T extends CreatorReviewItemCreateArgs>(
      args: SelectSubset<T, CreatorReviewItemCreateArgs>
    ): CheckSelect<T, Prisma__CreatorReviewItemClient<CreatorReviewItem>, Prisma__CreatorReviewItemClient<CreatorReviewItemGetPayload<T>>>

    /**
     * Create many CreatorReviewItems.
     *     @param {CreatorReviewItemCreateManyArgs} args - Arguments to create many CreatorReviewItems.
     *     @example
     *     // Create many CreatorReviewItems
     *     const creatorReviewItem = await prisma.creatorReviewItem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CreatorReviewItemCreateManyArgs>(
      args?: SelectSubset<T, CreatorReviewItemCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CreatorReviewItem.
     * @param {CreatorReviewItemDeleteArgs} args - Arguments to delete one CreatorReviewItem.
     * @example
     * // Delete one CreatorReviewItem
     * const CreatorReviewItem = await prisma.creatorReviewItem.delete({
     *   where: {
     *     // ... filter to delete one CreatorReviewItem
     *   }
     * })
     * 
    **/
    delete<T extends CreatorReviewItemDeleteArgs>(
      args: SelectSubset<T, CreatorReviewItemDeleteArgs>
    ): CheckSelect<T, Prisma__CreatorReviewItemClient<CreatorReviewItem>, Prisma__CreatorReviewItemClient<CreatorReviewItemGetPayload<T>>>

    /**
     * Update one CreatorReviewItem.
     * @param {CreatorReviewItemUpdateArgs} args - Arguments to update one CreatorReviewItem.
     * @example
     * // Update one CreatorReviewItem
     * const creatorReviewItem = await prisma.creatorReviewItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CreatorReviewItemUpdateArgs>(
      args: SelectSubset<T, CreatorReviewItemUpdateArgs>
    ): CheckSelect<T, Prisma__CreatorReviewItemClient<CreatorReviewItem>, Prisma__CreatorReviewItemClient<CreatorReviewItemGetPayload<T>>>

    /**
     * Delete zero or more CreatorReviewItems.
     * @param {CreatorReviewItemDeleteManyArgs} args - Arguments to filter CreatorReviewItems to delete.
     * @example
     * // Delete a few CreatorReviewItems
     * const { count } = await prisma.creatorReviewItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CreatorReviewItemDeleteManyArgs>(
      args?: SelectSubset<T, CreatorReviewItemDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreatorReviewItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorReviewItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CreatorReviewItems
     * const creatorReviewItem = await prisma.creatorReviewItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CreatorReviewItemUpdateManyArgs>(
      args: SelectSubset<T, CreatorReviewItemUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CreatorReviewItem.
     * @param {CreatorReviewItemUpsertArgs} args - Arguments to update or create a CreatorReviewItem.
     * @example
     * // Update or create a CreatorReviewItem
     * const creatorReviewItem = await prisma.creatorReviewItem.upsert({
     *   create: {
     *     // ... data to create a CreatorReviewItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CreatorReviewItem we want to update
     *   }
     * })
    **/
    upsert<T extends CreatorReviewItemUpsertArgs>(
      args: SelectSubset<T, CreatorReviewItemUpsertArgs>
    ): CheckSelect<T, Prisma__CreatorReviewItemClient<CreatorReviewItem>, Prisma__CreatorReviewItemClient<CreatorReviewItemGetPayload<T>>>

    /**
     * Find one CreatorReviewItem that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {CreatorReviewItemFindUniqueOrThrowArgs} args - Arguments to find a CreatorReviewItem
     * @example
     * // Get one CreatorReviewItem
     * const creatorReviewItem = await prisma.creatorReviewItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CreatorReviewItemFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CreatorReviewItemFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__CreatorReviewItemClient<CreatorReviewItem>, Prisma__CreatorReviewItemClient<CreatorReviewItemGetPayload<T>>>

    /**
     * Find the first CreatorReviewItem that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorReviewItemFindFirstOrThrowArgs} args - Arguments to find a CreatorReviewItem
     * @example
     * // Get one CreatorReviewItem
     * const creatorReviewItem = await prisma.creatorReviewItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CreatorReviewItemFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CreatorReviewItemFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__CreatorReviewItemClient<CreatorReviewItem>, Prisma__CreatorReviewItemClient<CreatorReviewItemGetPayload<T>>>

    /**
     * Count the number of CreatorReviewItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorReviewItemCountArgs} args - Arguments to filter CreatorReviewItems to count.
     * @example
     * // Count the number of CreatorReviewItems
     * const count = await prisma.creatorReviewItem.count({
     *   where: {
     *     // ... the filter for the CreatorReviewItems we want to count
     *   }
     * })
    **/
    count<T extends CreatorReviewItemCountArgs>(
      args?: Subset<T, CreatorReviewItemCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreatorReviewItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CreatorReviewItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorReviewItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreatorReviewItemAggregateArgs>(args: Subset<T, CreatorReviewItemAggregateArgs>): PrismaPromise<GetCreatorReviewItemAggregateType<T>>

    /**
     * Group by CreatorReviewItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatorReviewItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreatorReviewItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreatorReviewItemGroupByArgs['orderBy'] }
        : { orderBy?: CreatorReviewItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreatorReviewItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreatorReviewItemGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for CreatorReviewItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CreatorReviewItemClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    review<T extends CreatorReviewArgs = {}>(args?: Subset<T, CreatorReviewArgs>): CheckSelect<T, Prisma__CreatorReviewClient<CreatorReview | Null>, Prisma__CreatorReviewClient<CreatorReviewGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * CreatorReviewItem base type for findUnique actions
   */
  export type CreatorReviewItemFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the CreatorReviewItem
     * 
    **/
    select?: CreatorReviewItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreatorReviewItemInclude | null
    /**
     * Filter, which CreatorReviewItem to fetch.
     * 
    **/
    where: CreatorReviewItemWhereUniqueInput
  }

  /**
   * CreatorReviewItem: findUnique
   */
  export interface CreatorReviewItemFindUniqueArgs extends CreatorReviewItemFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CreatorReviewItem base type for findFirst actions
   */
  export type CreatorReviewItemFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the CreatorReviewItem
     * 
    **/
    select?: CreatorReviewItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreatorReviewItemInclude | null
    /**
     * Filter, which CreatorReviewItem to fetch.
     * 
    **/
    where?: CreatorReviewItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreatorReviewItems to fetch.
     * 
    **/
    orderBy?: Enumerable<CreatorReviewItemOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreatorReviewItems.
     * 
    **/
    cursor?: CreatorReviewItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreatorReviewItems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreatorReviewItems.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreatorReviewItems.
     * 
    **/
    distinct?: Enumerable<CreatorReviewItemScalarFieldEnum>
  }

  /**
   * CreatorReviewItem: findFirst
   */
  export interface CreatorReviewItemFindFirstArgs extends CreatorReviewItemFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CreatorReviewItem findMany
   */
  export type CreatorReviewItemFindManyArgs = {
    /**
     * Select specific fields to fetch from the CreatorReviewItem
     * 
    **/
    select?: CreatorReviewItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreatorReviewItemInclude | null
    /**
     * Filter, which CreatorReviewItems to fetch.
     * 
    **/
    where?: CreatorReviewItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreatorReviewItems to fetch.
     * 
    **/
    orderBy?: Enumerable<CreatorReviewItemOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CreatorReviewItems.
     * 
    **/
    cursor?: CreatorReviewItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreatorReviewItems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreatorReviewItems.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CreatorReviewItemScalarFieldEnum>
  }


  /**
   * CreatorReviewItem create
   */
  export type CreatorReviewItemCreateArgs = {
    /**
     * Select specific fields to fetch from the CreatorReviewItem
     * 
    **/
    select?: CreatorReviewItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreatorReviewItemInclude | null
    /**
     * The data needed to create a CreatorReviewItem.
     * 
    **/
    data: XOR<CreatorReviewItemCreateInput, CreatorReviewItemUncheckedCreateInput>
  }


  /**
   * CreatorReviewItem createMany
   */
  export type CreatorReviewItemCreateManyArgs = {
    /**
     * The data used to create many CreatorReviewItems.
     * 
    **/
    data: Enumerable<CreatorReviewItemCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CreatorReviewItem update
   */
  export type CreatorReviewItemUpdateArgs = {
    /**
     * Select specific fields to fetch from the CreatorReviewItem
     * 
    **/
    select?: CreatorReviewItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreatorReviewItemInclude | null
    /**
     * The data needed to update a CreatorReviewItem.
     * 
    **/
    data: XOR<CreatorReviewItemUpdateInput, CreatorReviewItemUncheckedUpdateInput>
    /**
     * Choose, which CreatorReviewItem to update.
     * 
    **/
    where: CreatorReviewItemWhereUniqueInput
  }


  /**
   * CreatorReviewItem updateMany
   */
  export type CreatorReviewItemUpdateManyArgs = {
    /**
     * The data used to update CreatorReviewItems.
     * 
    **/
    data: XOR<CreatorReviewItemUpdateManyMutationInput, CreatorReviewItemUncheckedUpdateManyInput>
    /**
     * Filter which CreatorReviewItems to update
     * 
    **/
    where?: CreatorReviewItemWhereInput
  }


  /**
   * CreatorReviewItem upsert
   */
  export type CreatorReviewItemUpsertArgs = {
    /**
     * Select specific fields to fetch from the CreatorReviewItem
     * 
    **/
    select?: CreatorReviewItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreatorReviewItemInclude | null
    /**
     * The filter to search for the CreatorReviewItem to update in case it exists.
     * 
    **/
    where: CreatorReviewItemWhereUniqueInput
    /**
     * In case the CreatorReviewItem found by the `where` argument doesn't exist, create a new CreatorReviewItem with this data.
     * 
    **/
    create: XOR<CreatorReviewItemCreateInput, CreatorReviewItemUncheckedCreateInput>
    /**
     * In case the CreatorReviewItem was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CreatorReviewItemUpdateInput, CreatorReviewItemUncheckedUpdateInput>
  }


  /**
   * CreatorReviewItem delete
   */
  export type CreatorReviewItemDeleteArgs = {
    /**
     * Select specific fields to fetch from the CreatorReviewItem
     * 
    **/
    select?: CreatorReviewItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreatorReviewItemInclude | null
    /**
     * Filter which CreatorReviewItem to delete.
     * 
    **/
    where: CreatorReviewItemWhereUniqueInput
  }


  /**
   * CreatorReviewItem deleteMany
   */
  export type CreatorReviewItemDeleteManyArgs = {
    /**
     * Filter which CreatorReviewItems to delete
     * 
    **/
    where?: CreatorReviewItemWhereInput
  }


  /**
   * CreatorReviewItem: findUniqueOrThrow
   */
  export type CreatorReviewItemFindUniqueOrThrowArgs = CreatorReviewItemFindUniqueArgsBase
      

  /**
   * CreatorReviewItem: findFirstOrThrow
   */
  export type CreatorReviewItemFindFirstOrThrowArgs = CreatorReviewItemFindFirstArgsBase
      

  /**
   * CreatorReviewItem without action
   */
  export type CreatorReviewItemArgs = {
    /**
     * Select specific fields to fetch from the CreatorReviewItem
     * 
    **/
    select?: CreatorReviewItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreatorReviewItemInclude | null
  }



  /**
   * Model Log
   */


  export type AggregateLog = {
    _count: LogCountAggregateOutputType | null
    _avg: LogAvgAggregateOutputType | null
    _sum: LogSumAggregateOutputType | null
    _min: LogMinAggregateOutputType | null
    _max: LogMaxAggregateOutputType | null
  }

  export type LogAvgAggregateOutputType = {
    id: number | null
    requestId: number | null
  }

  export type LogSumAggregateOutputType = {
    id: bigint | null
    requestId: bigint | null
  }

  export type LogMinAggregateOutputType = {
    id: bigint | null
    logType: LogType | null
    message: string | null
    senderId: string | null
    isRead: boolean | null
    requestId: bigint | null
    createdAt: Date | null
  }

  export type LogMaxAggregateOutputType = {
    id: bigint | null
    logType: LogType | null
    message: string | null
    senderId: string | null
    isRead: boolean | null
    requestId: bigint | null
    createdAt: Date | null
  }

  export type LogCountAggregateOutputType = {
    id: number
    logType: number
    message: number
    senderId: number
    isRead: number
    requestId: number
    createdAt: number
    _all: number
  }


  export type LogAvgAggregateInputType = {
    id?: true
    requestId?: true
  }

  export type LogSumAggregateInputType = {
    id?: true
    requestId?: true
  }

  export type LogMinAggregateInputType = {
    id?: true
    logType?: true
    message?: true
    senderId?: true
    isRead?: true
    requestId?: true
    createdAt?: true
  }

  export type LogMaxAggregateInputType = {
    id?: true
    logType?: true
    message?: true
    senderId?: true
    isRead?: true
    requestId?: true
    createdAt?: true
  }

  export type LogCountAggregateInputType = {
    id?: true
    logType?: true
    message?: true
    senderId?: true
    isRead?: true
    requestId?: true
    createdAt?: true
    _all?: true
  }

  export type LogAggregateArgs = {
    /**
     * Filter which Log to aggregate.
     * 
    **/
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     * 
    **/
    orderBy?: Enumerable<LogOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Logs
    **/
    _count?: true | LogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogMaxAggregateInputType
  }

  export type GetLogAggregateType<T extends LogAggregateArgs> = {
        [P in keyof T & keyof AggregateLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLog[P]>
      : GetScalarType<T[P], AggregateLog[P]>
  }




  export type LogGroupByArgs = {
    where?: LogWhereInput
    orderBy?: Enumerable<LogOrderByWithAggregationInput>
    by: Array<LogScalarFieldEnum>
    having?: LogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogCountAggregateInputType | true
    _avg?: LogAvgAggregateInputType
    _sum?: LogSumAggregateInputType
    _min?: LogMinAggregateInputType
    _max?: LogMaxAggregateInputType
  }


  export type LogGroupByOutputType = {
    id: bigint
    logType: LogType
    message: string | null
    senderId: string | null
    isRead: boolean | null
    requestId: bigint | null
    createdAt: Date
    _count: LogCountAggregateOutputType | null
    _avg: LogAvgAggregateOutputType | null
    _sum: LogSumAggregateOutputType | null
    _min: LogMinAggregateOutputType | null
    _max: LogMaxAggregateOutputType | null
  }

  type GetLogGroupByPayload<T extends LogGroupByArgs> = PrismaPromise<
    Array<
      PickArray<LogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogGroupByOutputType[P]>
            : GetScalarType<T[P], LogGroupByOutputType[P]>
        }
      >
    >


  export type LogSelect = {
    id?: boolean
    logType?: boolean
    message?: boolean
    senderId?: boolean
    sender?: boolean | UserArgs
    isRead?: boolean
    receiver?: boolean | UserFindManyArgs
    requestId?: boolean
    request?: boolean | RequestPostArgs
    createdAt?: boolean
    _count?: boolean | LogCountOutputTypeArgs
  }

  export type LogInclude = {
    sender?: boolean | UserArgs
    receiver?: boolean | UserFindManyArgs
    request?: boolean | RequestPostArgs
    _count?: boolean | LogCountOutputTypeArgs
  }

  export type LogGetPayload<
    S extends boolean | null | undefined | LogArgs,
    U = keyof S
      > = S extends true
        ? Log
    : S extends undefined
    ? never
    : S extends LogArgs | LogFindManyArgs
    ?'include' extends U
    ? Log  & {
    [P in TrueKeys<S['include']>]:
        P extends 'sender' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'receiver' ? Array < UserGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'request' ? RequestPostGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends '_count' ? LogCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'sender' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'receiver' ? Array < UserGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'request' ? RequestPostGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends '_count' ? LogCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Log ? Log[P] : never
  } 
    : Log
  : Log


  type LogCountArgs = Merge<
    Omit<LogFindManyArgs, 'select' | 'include'> & {
      select?: LogCountAggregateInputType | true
    }
  >

  export interface LogDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Log that matches the filter.
     * @param {LogFindUniqueArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LogFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LogFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Log'> extends True ? CheckSelect<T, Prisma__LogClient<Log>, Prisma__LogClient<LogGetPayload<T>>> : CheckSelect<T, Prisma__LogClient<Log | null, null>, Prisma__LogClient<LogGetPayload<T> | null, null>>

    /**
     * Find the first Log that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindFirstArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LogFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LogFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Log'> extends True ? CheckSelect<T, Prisma__LogClient<Log>, Prisma__LogClient<LogGetPayload<T>>> : CheckSelect<T, Prisma__LogClient<Log | null, null>, Prisma__LogClient<LogGetPayload<T> | null, null>>

    /**
     * Find zero or more Logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Logs
     * const logs = await prisma.log.findMany()
     * 
     * // Get first 10 Logs
     * const logs = await prisma.log.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logWithIdOnly = await prisma.log.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LogFindManyArgs>(
      args?: SelectSubset<T, LogFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Log>>, PrismaPromise<Array<LogGetPayload<T>>>>

    /**
     * Create a Log.
     * @param {LogCreateArgs} args - Arguments to create a Log.
     * @example
     * // Create one Log
     * const Log = await prisma.log.create({
     *   data: {
     *     // ... data to create a Log
     *   }
     * })
     * 
    **/
    create<T extends LogCreateArgs>(
      args: SelectSubset<T, LogCreateArgs>
    ): CheckSelect<T, Prisma__LogClient<Log>, Prisma__LogClient<LogGetPayload<T>>>

    /**
     * Create many Logs.
     *     @param {LogCreateManyArgs} args - Arguments to create many Logs.
     *     @example
     *     // Create many Logs
     *     const log = await prisma.log.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LogCreateManyArgs>(
      args?: SelectSubset<T, LogCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Log.
     * @param {LogDeleteArgs} args - Arguments to delete one Log.
     * @example
     * // Delete one Log
     * const Log = await prisma.log.delete({
     *   where: {
     *     // ... filter to delete one Log
     *   }
     * })
     * 
    **/
    delete<T extends LogDeleteArgs>(
      args: SelectSubset<T, LogDeleteArgs>
    ): CheckSelect<T, Prisma__LogClient<Log>, Prisma__LogClient<LogGetPayload<T>>>

    /**
     * Update one Log.
     * @param {LogUpdateArgs} args - Arguments to update one Log.
     * @example
     * // Update one Log
     * const log = await prisma.log.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LogUpdateArgs>(
      args: SelectSubset<T, LogUpdateArgs>
    ): CheckSelect<T, Prisma__LogClient<Log>, Prisma__LogClient<LogGetPayload<T>>>

    /**
     * Delete zero or more Logs.
     * @param {LogDeleteManyArgs} args - Arguments to filter Logs to delete.
     * @example
     * // Delete a few Logs
     * const { count } = await prisma.log.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LogDeleteManyArgs>(
      args?: SelectSubset<T, LogDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Logs
     * const log = await prisma.log.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LogUpdateManyArgs>(
      args: SelectSubset<T, LogUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Log.
     * @param {LogUpsertArgs} args - Arguments to update or create a Log.
     * @example
     * // Update or create a Log
     * const log = await prisma.log.upsert({
     *   create: {
     *     // ... data to create a Log
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Log we want to update
     *   }
     * })
    **/
    upsert<T extends LogUpsertArgs>(
      args: SelectSubset<T, LogUpsertArgs>
    ): CheckSelect<T, Prisma__LogClient<Log>, Prisma__LogClient<LogGetPayload<T>>>

    /**
     * Find one Log that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {LogFindUniqueOrThrowArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LogFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, LogFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__LogClient<Log>, Prisma__LogClient<LogGetPayload<T>>>

    /**
     * Find the first Log that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindFirstOrThrowArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LogFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LogFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__LogClient<Log>, Prisma__LogClient<LogGetPayload<T>>>

    /**
     * Count the number of Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogCountArgs} args - Arguments to filter Logs to count.
     * @example
     * // Count the number of Logs
     * const count = await prisma.log.count({
     *   where: {
     *     // ... the filter for the Logs we want to count
     *   }
     * })
    **/
    count<T extends LogCountArgs>(
      args?: Subset<T, LogCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogAggregateArgs>(args: Subset<T, LogAggregateArgs>): PrismaPromise<GetLogAggregateType<T>>

    /**
     * Group by Log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogGroupByArgs['orderBy'] }
        : { orderBy?: LogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Log.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LogClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    sender<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | Null>, Prisma__UserClient<UserGetPayload<T> | Null>>;

    receiver<T extends UserFindManyArgs = {}>(args?: Subset<T, UserFindManyArgs>): CheckSelect<T, PrismaPromise<Array<User>| Null>, PrismaPromise<Array<UserGetPayload<T>>| Null>>;

    request<T extends RequestPostArgs = {}>(args?: Subset<T, RequestPostArgs>): CheckSelect<T, Prisma__RequestPostClient<RequestPost | Null>, Prisma__RequestPostClient<RequestPostGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Log base type for findUnique actions
   */
  export type LogFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Log
     * 
    **/
    select?: LogSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LogInclude | null
    /**
     * Filter, which Log to fetch.
     * 
    **/
    where: LogWhereUniqueInput
  }

  /**
   * Log: findUnique
   */
  export interface LogFindUniqueArgs extends LogFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Log base type for findFirst actions
   */
  export type LogFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Log
     * 
    **/
    select?: LogSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LogInclude | null
    /**
     * Filter, which Log to fetch.
     * 
    **/
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     * 
    **/
    orderBy?: Enumerable<LogOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logs.
     * 
    **/
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logs.
     * 
    **/
    distinct?: Enumerable<LogScalarFieldEnum>
  }

  /**
   * Log: findFirst
   */
  export interface LogFindFirstArgs extends LogFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Log findMany
   */
  export type LogFindManyArgs = {
    /**
     * Select specific fields to fetch from the Log
     * 
    **/
    select?: LogSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LogInclude | null
    /**
     * Filter, which Logs to fetch.
     * 
    **/
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     * 
    **/
    orderBy?: Enumerable<LogOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Logs.
     * 
    **/
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     * 
    **/
    skip?: number
    distinct?: Enumerable<LogScalarFieldEnum>
  }


  /**
   * Log create
   */
  export type LogCreateArgs = {
    /**
     * Select specific fields to fetch from the Log
     * 
    **/
    select?: LogSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LogInclude | null
    /**
     * The data needed to create a Log.
     * 
    **/
    data: XOR<LogCreateInput, LogUncheckedCreateInput>
  }


  /**
   * Log createMany
   */
  export type LogCreateManyArgs = {
    /**
     * The data used to create many Logs.
     * 
    **/
    data: Enumerable<LogCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Log update
   */
  export type LogUpdateArgs = {
    /**
     * Select specific fields to fetch from the Log
     * 
    **/
    select?: LogSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LogInclude | null
    /**
     * The data needed to update a Log.
     * 
    **/
    data: XOR<LogUpdateInput, LogUncheckedUpdateInput>
    /**
     * Choose, which Log to update.
     * 
    **/
    where: LogWhereUniqueInput
  }


  /**
   * Log updateMany
   */
  export type LogUpdateManyArgs = {
    /**
     * The data used to update Logs.
     * 
    **/
    data: XOR<LogUpdateManyMutationInput, LogUncheckedUpdateManyInput>
    /**
     * Filter which Logs to update
     * 
    **/
    where?: LogWhereInput
  }


  /**
   * Log upsert
   */
  export type LogUpsertArgs = {
    /**
     * Select specific fields to fetch from the Log
     * 
    **/
    select?: LogSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LogInclude | null
    /**
     * The filter to search for the Log to update in case it exists.
     * 
    **/
    where: LogWhereUniqueInput
    /**
     * In case the Log found by the `where` argument doesn't exist, create a new Log with this data.
     * 
    **/
    create: XOR<LogCreateInput, LogUncheckedCreateInput>
    /**
     * In case the Log was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<LogUpdateInput, LogUncheckedUpdateInput>
  }


  /**
   * Log delete
   */
  export type LogDeleteArgs = {
    /**
     * Select specific fields to fetch from the Log
     * 
    **/
    select?: LogSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LogInclude | null
    /**
     * Filter which Log to delete.
     * 
    **/
    where: LogWhereUniqueInput
  }


  /**
   * Log deleteMany
   */
  export type LogDeleteManyArgs = {
    /**
     * Filter which Logs to delete
     * 
    **/
    where?: LogWhereInput
  }


  /**
   * Log: findUniqueOrThrow
   */
  export type LogFindUniqueOrThrowArgs = LogFindUniqueArgsBase
      

  /**
   * Log: findFirstOrThrow
   */
  export type LogFindFirstOrThrowArgs = LogFindFirstArgsBase
      

  /**
   * Log without action
   */
  export type LogArgs = {
    /**
     * Select specific fields to fetch from the Log
     * 
    **/
    select?: LogSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LogInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const AccountOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type AccountOrderByRelevanceFieldEnum = (typeof AccountOrderByRelevanceFieldEnum)[keyof typeof AccountOrderByRelevanceFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const CreatorAuthOrderByRelevanceFieldEnum: {
    profileUrl: 'profileUrl'
  };

  export type CreatorAuthOrderByRelevanceFieldEnum = (typeof CreatorAuthOrderByRelevanceFieldEnum)[keyof typeof CreatorAuthOrderByRelevanceFieldEnum]


  export const CreatorAuthScalarFieldEnum: {
    id: 'id',
    creatorId: 'creatorId',
    isMain: 'isMain',
    profileUrl: 'profileUrl',
    platform: 'platform',
    createdAt: 'createdAt'
  };

  export type CreatorAuthScalarFieldEnum = (typeof CreatorAuthScalarFieldEnum)[keyof typeof CreatorAuthScalarFieldEnum]


  export const CreatorOrderByRelevanceFieldEnum: {
    userId: 'userId'
  };

  export type CreatorOrderByRelevanceFieldEnum = (typeof CreatorOrderByRelevanceFieldEnum)[keyof typeof CreatorOrderByRelevanceFieldEnum]


  export const CreatorReviewItemOrderByRelevanceFieldEnum: {
    content: 'content'
  };

  export type CreatorReviewItemOrderByRelevanceFieldEnum = (typeof CreatorReviewItemOrderByRelevanceFieldEnum)[keyof typeof CreatorReviewItemOrderByRelevanceFieldEnum]


  export const CreatorReviewItemScalarFieldEnum: {
    id: 'id',
    reviewId: 'reviewId',
    content: 'content',
    isChecked: 'isChecked'
  };

  export type CreatorReviewItemScalarFieldEnum = (typeof CreatorReviewItemScalarFieldEnum)[keyof typeof CreatorReviewItemScalarFieldEnum]


  export const CreatorReviewOrderByRelevanceFieldEnum: {
    userId: 'userId',
    content: 'content'
  };

  export type CreatorReviewOrderByRelevanceFieldEnum = (typeof CreatorReviewOrderByRelevanceFieldEnum)[keyof typeof CreatorReviewOrderByRelevanceFieldEnum]


  export const CreatorReviewScalarFieldEnum: {
    id: 'id',
    creatorId: 'creatorId',
    userId: 'userId',
    content: 'content',
    createdAt: 'createdAt'
  };

  export type CreatorReviewScalarFieldEnum = (typeof CreatorReviewScalarFieldEnum)[keyof typeof CreatorReviewScalarFieldEnum]


  export const CreatorScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type CreatorScalarFieldEnum = (typeof CreatorScalarFieldEnum)[keyof typeof CreatorScalarFieldEnum]


  export const FaqOrderByRelevanceFieldEnum: {
    title: 'title',
    content: 'content'
  };

  export type FaqOrderByRelevanceFieldEnum = (typeof FaqOrderByRelevanceFieldEnum)[keyof typeof FaqOrderByRelevanceFieldEnum]


  export const FaqScalarFieldEnum: {
    id: 'id',
    type: 'type',
    title: 'title',
    content: 'content',
    createdAt: 'createdAt'
  };

  export type FaqScalarFieldEnum = (typeof FaqScalarFieldEnum)[keyof typeof FaqScalarFieldEnum]


  export const LogOrderByRelevanceFieldEnum: {
    message: 'message',
    senderId: 'senderId'
  };

  export type LogOrderByRelevanceFieldEnum = (typeof LogOrderByRelevanceFieldEnum)[keyof typeof LogOrderByRelevanceFieldEnum]


  export const LogScalarFieldEnum: {
    id: 'id',
    logType: 'logType',
    message: 'message',
    senderId: 'senderId',
    isRead: 'isRead',
    requestId: 'requestId',
    createdAt: 'createdAt'
  };

  export type LogScalarFieldEnum = (typeof LogScalarFieldEnum)[keyof typeof LogScalarFieldEnum]


  export const NoticeOrderByRelevanceFieldEnum: {
    title: 'title',
    content: 'content'
  };

  export type NoticeOrderByRelevanceFieldEnum = (typeof NoticeOrderByRelevanceFieldEnum)[keyof typeof NoticeOrderByRelevanceFieldEnum]


  export const NoticeScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    createdAt: 'createdAt'
  };

  export type NoticeScalarFieldEnum = (typeof NoticeScalarFieldEnum)[keyof typeof NoticeScalarFieldEnum]


  export const PointOrderByRelevanceFieldEnum: {
    userId: 'userId'
  };

  export type PointOrderByRelevanceFieldEnum = (typeof PointOrderByRelevanceFieldEnum)[keyof typeof PointOrderByRelevanceFieldEnum]


  export const PointScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    quantity: 'quantity',
    type: 'type',
    createdAt: 'createdAt'
  };

  export type PointScalarFieldEnum = (typeof PointScalarFieldEnum)[keyof typeof PointScalarFieldEnum]


  export const RankingOrderByRelevanceFieldEnum: {
    userId: 'userId'
  };

  export type RankingOrderByRelevanceFieldEnum = (typeof RankingOrderByRelevanceFieldEnum)[keyof typeof RankingOrderByRelevanceFieldEnum]


  export const RankingScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    ranking: 'ranking',
    type: 'type',
    score: 'score',
    change: 'change',
    createdAt: 'createdAt'
  };

  export type RankingScalarFieldEnum = (typeof RankingScalarFieldEnum)[keyof typeof RankingScalarFieldEnum]


  export const RequestApplyCreatorScalarFieldEnum: {
    id: 'id',
    requestId: 'requestId',
    creatorId: 'creatorId'
  };

  export type RequestApplyCreatorScalarFieldEnum = (typeof RequestApplyCreatorScalarFieldEnum)[keyof typeof RequestApplyCreatorScalarFieldEnum]


  export const RequestBookmarkOrderByRelevanceFieldEnum: {
    userId: 'userId'
  };

  export type RequestBookmarkOrderByRelevanceFieldEnum = (typeof RequestBookmarkOrderByRelevanceFieldEnum)[keyof typeof RequestBookmarkOrderByRelevanceFieldEnum]


  export const RequestBookmarkScalarFieldEnum: {
    id: 'id',
    requestId: 'requestId',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type RequestBookmarkScalarFieldEnum = (typeof RequestBookmarkScalarFieldEnum)[keyof typeof RequestBookmarkScalarFieldEnum]


  export const RequestCommentHeartOrderByRelevanceFieldEnum: {
    userId: 'userId'
  };

  export type RequestCommentHeartOrderByRelevanceFieldEnum = (typeof RequestCommentHeartOrderByRelevanceFieldEnum)[keyof typeof RequestCommentHeartOrderByRelevanceFieldEnum]


  export const RequestCommentHeartScalarFieldEnum: {
    id: 'id',
    requestCommentId: 'requestCommentId',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type RequestCommentHeartScalarFieldEnum = (typeof RequestCommentHeartScalarFieldEnum)[keyof typeof RequestCommentHeartScalarFieldEnum]


  export const RequestCommentOrderByRelevanceFieldEnum: {
    userId: 'userId',
    content: 'content'
  };

  export type RequestCommentOrderByRelevanceFieldEnum = (typeof RequestCommentOrderByRelevanceFieldEnum)[keyof typeof RequestCommentOrderByRelevanceFieldEnum]


  export const RequestCommentScalarFieldEnum: {
    id: 'id',
    requestId: 'requestId',
    userId: 'userId',
    parentId: 'parentId',
    rootId: 'rootId',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RequestCommentScalarFieldEnum = (typeof RequestCommentScalarFieldEnum)[keyof typeof RequestCommentScalarFieldEnum]


  export const RequestFundingOrderByRelevanceFieldEnum: {
    userId: 'userId'
  };

  export type RequestFundingOrderByRelevanceFieldEnum = (typeof RequestFundingOrderByRelevanceFieldEnum)[keyof typeof RequestFundingOrderByRelevanceFieldEnum]


  export const RequestFundingScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    quantity: 'quantity',
    requestId: 'requestId',
    createdAt: 'createdAt',
    status: 'status'
  };

  export type RequestFundingScalarFieldEnum = (typeof RequestFundingScalarFieldEnum)[keyof typeof RequestFundingScalarFieldEnum]


  export const RequestInquiryMessageOrderByRelevanceFieldEnum: {
    fromId: 'fromId',
    text: 'text',
    fileUrl: 'fileUrl'
  };

  export type RequestInquiryMessageOrderByRelevanceFieldEnum = (typeof RequestInquiryMessageOrderByRelevanceFieldEnum)[keyof typeof RequestInquiryMessageOrderByRelevanceFieldEnum]


  export const RequestInquiryMessageScalarFieldEnum: {
    id: 'id',
    roomId: 'roomId',
    fromId: 'fromId',
    text: 'text',
    fileUrl: 'fileUrl',
    type: 'type',
    isRead: 'isRead',
    createdAt: 'createdAt'
  };

  export type RequestInquiryMessageScalarFieldEnum = (typeof RequestInquiryMessageScalarFieldEnum)[keyof typeof RequestInquiryMessageScalarFieldEnum]


  export const RequestInquiryOrderByRelevanceFieldEnum: {
    userId: 'userId'
  };

  export type RequestInquiryOrderByRelevanceFieldEnum = (typeof RequestInquiryOrderByRelevanceFieldEnum)[keyof typeof RequestInquiryOrderByRelevanceFieldEnum]


  export const RequestInquiryScalarFieldEnum: {
    id: 'id',
    requestId: 'requestId',
    creatorId: 'creatorId',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type RequestInquiryScalarFieldEnum = (typeof RequestInquiryScalarFieldEnum)[keyof typeof RequestInquiryScalarFieldEnum]


  export const RequestPlatformScalarFieldEnum: {
    id: 'id',
    requestId: 'requestId',
    name: 'name'
  };

  export type RequestPlatformScalarFieldEnum = (typeof RequestPlatformScalarFieldEnum)[keyof typeof RequestPlatformScalarFieldEnum]


  export const RequestPostOrderByRelevanceFieldEnum: {
    userId: 'userId',
    title: 'title',
    content: 'content',
    solvedUrl: 'solvedUrl',
    thumbnailUrl: 'thumbnailUrl',
    refusalReason: 'refusalReason'
  };

  export type RequestPostOrderByRelevanceFieldEnum = (typeof RequestPostOrderByRelevanceFieldEnum)[keyof typeof RequestPostOrderByRelevanceFieldEnum]


  export const RequestPostScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId',
    title: 'title',
    content: 'content',
    category: 'category',
    creatorId: 'creatorId',
    expires: 'expires',
    totalViews: 'totalViews',
    status: 'status',
    solvedUrl: 'solvedUrl',
    thumbnailUrl: 'thumbnailUrl',
    refusalReason: 'refusalReason',
    totalQuantity: 'totalQuantity',
    totalLikeScroe: 'totalLikeScroe',
    isUnspecified: 'isUnspecified'
  };

  export type RequestPostScalarFieldEnum = (typeof RequestPostScalarFieldEnum)[keyof typeof RequestPostScalarFieldEnum]


  export const RequestReactionOrderByRelevanceFieldEnum: {
    userId: 'userId'
  };

  export type RequestReactionOrderByRelevanceFieldEnum = (typeof RequestReactionOrderByRelevanceFieldEnum)[keyof typeof RequestReactionOrderByRelevanceFieldEnum]


  export const RequestReactionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    requestId: 'requestId',
    createdAt: 'createdAt'
  };

  export type RequestReactionScalarFieldEnum = (typeof RequestReactionScalarFieldEnum)[keyof typeof RequestReactionScalarFieldEnum]


  export const RequestReportOrderByRelevanceFieldEnum: {
    userId: 'userId',
    content: 'content'
  };

  export type RequestReportOrderByRelevanceFieldEnum = (typeof RequestReportOrderByRelevanceFieldEnum)[keyof typeof RequestReportOrderByRelevanceFieldEnum]


  export const RequestReportScalarFieldEnum: {
    id: 'id',
    requestId: 'requestId',
    userId: 'userId',
    content: 'content',
    type: 'type',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type RequestReportScalarFieldEnum = (typeof RequestReportScalarFieldEnum)[keyof typeof RequestReportScalarFieldEnum]


  export const SessionOrderByRelevanceFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId'
  };

  export type SessionOrderByRelevanceFieldEnum = (typeof SessionOrderByRelevanceFieldEnum)[keyof typeof SessionOrderByRelevanceFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    image: 'image',
    introduction: 'introduction'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    image: 'image',
    introduction: 'introduction',
    totalPoint: 'totalPoint'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const VerificationTokenOrderByRelevanceFieldEnum: {
    identifier: 'identifier',
    token: 'token'
  };

  export type VerificationTokenOrderByRelevanceFieldEnum = (typeof VerificationTokenOrderByRelevanceFieldEnum)[keyof typeof VerificationTokenOrderByRelevanceFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    identifier: 'identifier',
    token: 'token',
    expires: 'expires'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type AccountWhereInput = {
    AND?: Enumerable<AccountWhereInput>
    OR?: Enumerable<AccountWhereInput>
    NOT?: Enumerable<AccountWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    type?: StringFilter | string
    provider?: StringFilter | string
    providerAccountId?: StringFilter | string
    refresh_token?: StringNullableFilter | string | null
    access_token?: StringNullableFilter | string | null
    expires_at?: IntNullableFilter | number | null
    token_type?: StringNullableFilter | string | null
    scope?: StringNullableFilter | string | null
    id_token?: StringNullableFilter | string | null
    session_state?: StringNullableFilter | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    user?: UserOrderByWithRelationAndSearchRelevanceInput
    _relevance?: AccountOrderByRelevanceInput
  }

  export type AccountWhereUniqueInput = {
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
  }

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AccountScalarWhereWithAggregatesInput>
    OR?: Enumerable<AccountScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AccountScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    type?: StringWithAggregatesFilter | string
    provider?: StringWithAggregatesFilter | string
    providerAccountId?: StringWithAggregatesFilter | string
    refresh_token?: StringNullableWithAggregatesFilter | string | null
    access_token?: StringNullableWithAggregatesFilter | string | null
    expires_at?: IntNullableWithAggregatesFilter | number | null
    token_type?: StringNullableWithAggregatesFilter | string | null
    scope?: StringNullableWithAggregatesFilter | string | null
    id_token?: StringNullableWithAggregatesFilter | string | null
    session_state?: StringNullableWithAggregatesFilter | string | null
  }

  export type SessionWhereInput = {
    AND?: Enumerable<SessionWhereInput>
    OR?: Enumerable<SessionWhereInput>
    NOT?: Enumerable<SessionWhereInput>
    id?: StringFilter | string
    sessionToken?: StringFilter | string
    userId?: StringFilter | string
    expires?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    user?: UserOrderByWithRelationAndSearchRelevanceInput
    _relevance?: SessionOrderByRelevanceInput
  }

  export type SessionWhereUniqueInput = {
    id?: string
    sessionToken?: string
  }

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SessionScalarWhereWithAggregatesInput>
    OR?: Enumerable<SessionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SessionScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    sessionToken?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    expires?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: StringFilter | string
    name?: StringNullableFilter | string | null
    email?: StringNullableFilter | string | null
    emailVerified?: DateTimeNullableFilter | Date | string | null
    image?: StringNullableFilter | string | null
    introduction?: StringNullableFilter | string | null
    totalPoint?: IntFilter | number
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    requestPosts?: RequestPostListRelationFilter
    requestFundings?: RequestFundingListRelationFilter
    requestComments?: RequestCommentListRelationFilter
    requestReactions?: RequestReactionListRelationFilter
    requestBookmarks?: RequestBookmarkListRelationFilter
    requestReports?: RequestReportListRelationFilter
    requestInquiries?: RequestInquiryListRelationFilter
    requestinquiryMessages?: RequestInquiryMessageListRelationFilter
    requestCommentHearts?: RequestCommentHeartListRelationFilter
    logs?: LogListRelationFilter
    points?: PointListRelationFilter
    rankings?: RankingListRelationFilter
    creatorReviews?: CreatorReviewListRelationFilter
    creator?: XOR<CreatorRelationFilter, CreatorWhereInput> | null
    Log?: LogListRelationFilter
  }

  export type UserOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    introduction?: SortOrder
    totalPoint?: SortOrder
    accounts?: AccountOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    requestPosts?: RequestPostOrderByRelationAggregateInput
    requestFundings?: RequestFundingOrderByRelationAggregateInput
    requestComments?: RequestCommentOrderByRelationAggregateInput
    requestReactions?: RequestReactionOrderByRelationAggregateInput
    requestBookmarks?: RequestBookmarkOrderByRelationAggregateInput
    requestReports?: RequestReportOrderByRelationAggregateInput
    requestInquiries?: RequestInquiryOrderByRelationAggregateInput
    requestinquiryMessages?: RequestInquiryMessageOrderByRelationAggregateInput
    requestCommentHearts?: RequestCommentHeartOrderByRelationAggregateInput
    logs?: LogOrderByRelationAggregateInput
    points?: PointOrderByRelationAggregateInput
    rankings?: RankingOrderByRelationAggregateInput
    creatorReviews?: CreatorReviewOrderByRelationAggregateInput
    creator?: CreatorOrderByWithRelationAndSearchRelevanceInput
    Log?: LogOrderByRelationAggregateInput
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = {
    id?: string
    name?: string
    email?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    introduction?: SortOrder
    totalPoint?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringNullableWithAggregatesFilter | string | null
    email?: StringNullableWithAggregatesFilter | string | null
    emailVerified?: DateTimeNullableWithAggregatesFilter | Date | string | null
    image?: StringNullableWithAggregatesFilter | string | null
    introduction?: StringNullableWithAggregatesFilter | string | null
    totalPoint?: IntWithAggregatesFilter | number
  }

  export type VerificationTokenWhereInput = {
    AND?: Enumerable<VerificationTokenWhereInput>
    OR?: Enumerable<VerificationTokenWhereInput>
    NOT?: Enumerable<VerificationTokenWhereInput>
    identifier?: StringFilter | string
    token?: StringFilter | string
    expires?: DateTimeFilter | Date | string
  }

  export type VerificationTokenOrderByWithRelationAndSearchRelevanceInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _relevance?: VerificationTokenOrderByRelevanceInput
  }

  export type VerificationTokenWhereUniqueInput = {
    token?: string
    identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput
  }

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: Enumerable<VerificationTokenScalarWhereWithAggregatesInput>
    OR?: Enumerable<VerificationTokenScalarWhereWithAggregatesInput>
    NOT?: Enumerable<VerificationTokenScalarWhereWithAggregatesInput>
    identifier?: StringWithAggregatesFilter | string
    token?: StringWithAggregatesFilter | string
    expires?: DateTimeWithAggregatesFilter | Date | string
  }

  export type RequestPostWhereInput = {
    AND?: Enumerable<RequestPostWhereInput>
    OR?: Enumerable<RequestPostWhereInput>
    NOT?: Enumerable<RequestPostWhereInput>
    id?: BigIntFilter | bigint | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput> | null
    userId?: StringNullableFilter | string | null
    title?: StringFilter | string
    content?: StringFilter | string
    creator?: XOR<CreatorRelationFilter, CreatorWhereInput> | null
    category?: EnumRequestCategoryTypeNullableFilter | RequestCategoryType | null
    creatorId?: BigIntNullableFilter | bigint | number | null
    expires?: DateTimeNullableFilter | Date | string | null
    totalViews?: IntFilter | number
    status?: EnumRequestStatusTypeFilter | RequestStatusType
    solvedUrl?: StringNullableFilter | string | null
    thumbnailUrl?: StringNullableFilter | string | null
    refusalReason?: StringNullableFilter | string | null
    totalQuantity?: IntFilter | number
    totalLikeScroe?: IntFilter | number
    isUnspecified?: BoolFilter | boolean
    requestFundings?: RequestFundingListRelationFilter
    requestReactions?: RequestReactionListRelationFilter
    requestApplyCreators?: RequestApplyCreatorListRelationFilter
    requestPlatforms?: RequestPlatformListRelationFilter
    requestComments?: RequestCommentListRelationFilter
    requestBookmarks?: RequestBookmarkListRelationFilter
    requestReports?: RequestReportListRelationFilter
    requestInquirys?: RequestInquiryListRelationFilter
    Log?: LogListRelationFilter
  }

  export type RequestPostOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationAndSearchRelevanceInput
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    creator?: CreatorOrderByWithRelationAndSearchRelevanceInput
    category?: SortOrder
    creatorId?: SortOrder
    expires?: SortOrder
    totalViews?: SortOrder
    status?: SortOrder
    solvedUrl?: SortOrder
    thumbnailUrl?: SortOrder
    refusalReason?: SortOrder
    totalQuantity?: SortOrder
    totalLikeScroe?: SortOrder
    isUnspecified?: SortOrder
    requestFundings?: RequestFundingOrderByRelationAggregateInput
    requestReactions?: RequestReactionOrderByRelationAggregateInput
    requestApplyCreators?: RequestApplyCreatorOrderByRelationAggregateInput
    requestPlatforms?: RequestPlatformOrderByRelationAggregateInput
    requestComments?: RequestCommentOrderByRelationAggregateInput
    requestBookmarks?: RequestBookmarkOrderByRelationAggregateInput
    requestReports?: RequestReportOrderByRelationAggregateInput
    requestInquirys?: RequestInquiryOrderByRelationAggregateInput
    Log?: LogOrderByRelationAggregateInput
    _relevance?: RequestPostOrderByRelevanceInput
  }

  export type RequestPostWhereUniqueInput = {
    id?: bigint | number
  }

  export type RequestPostOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    category?: SortOrder
    creatorId?: SortOrder
    expires?: SortOrder
    totalViews?: SortOrder
    status?: SortOrder
    solvedUrl?: SortOrder
    thumbnailUrl?: SortOrder
    refusalReason?: SortOrder
    totalQuantity?: SortOrder
    totalLikeScroe?: SortOrder
    isUnspecified?: SortOrder
    _count?: RequestPostCountOrderByAggregateInput
    _avg?: RequestPostAvgOrderByAggregateInput
    _max?: RequestPostMaxOrderByAggregateInput
    _min?: RequestPostMinOrderByAggregateInput
    _sum?: RequestPostSumOrderByAggregateInput
  }

  export type RequestPostScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RequestPostScalarWhereWithAggregatesInput>
    OR?: Enumerable<RequestPostScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RequestPostScalarWhereWithAggregatesInput>
    id?: BigIntWithAggregatesFilter | bigint | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    userId?: StringNullableWithAggregatesFilter | string | null
    title?: StringWithAggregatesFilter | string
    content?: StringWithAggregatesFilter | string
    category?: EnumRequestCategoryTypeNullableWithAggregatesFilter | RequestCategoryType | null
    creatorId?: BigIntNullableWithAggregatesFilter | bigint | number | null
    expires?: DateTimeNullableWithAggregatesFilter | Date | string | null
    totalViews?: IntWithAggregatesFilter | number
    status?: EnumRequestStatusTypeWithAggregatesFilter | RequestStatusType
    solvedUrl?: StringNullableWithAggregatesFilter | string | null
    thumbnailUrl?: StringNullableWithAggregatesFilter | string | null
    refusalReason?: StringNullableWithAggregatesFilter | string | null
    totalQuantity?: IntWithAggregatesFilter | number
    totalLikeScroe?: IntWithAggregatesFilter | number
    isUnspecified?: BoolWithAggregatesFilter | boolean
  }

  export type RequestFundingWhereInput = {
    AND?: Enumerable<RequestFundingWhereInput>
    OR?: Enumerable<RequestFundingWhereInput>
    NOT?: Enumerable<RequestFundingWhereInput>
    id?: BigIntFilter | bigint | number
    user?: XOR<UserRelationFilter, UserWhereInput> | null
    userId?: StringNullableFilter | string | null
    quantity?: IntFilter | number
    request?: XOR<RequestPostRelationFilter, RequestPostWhereInput> | null
    requestId?: BigIntNullableFilter | bigint | number | null
    createdAt?: DateTimeFilter | Date | string
    status?: EnumRequestFundingStatusFilter | RequestFundingStatus
  }

  export type RequestFundingOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    user?: UserOrderByWithRelationAndSearchRelevanceInput
    userId?: SortOrder
    quantity?: SortOrder
    request?: RequestPostOrderByWithRelationAndSearchRelevanceInput
    requestId?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    _relevance?: RequestFundingOrderByRelevanceInput
  }

  export type RequestFundingWhereUniqueInput = {
    id?: bigint | number
  }

  export type RequestFundingOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    quantity?: SortOrder
    requestId?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    _count?: RequestFundingCountOrderByAggregateInput
    _avg?: RequestFundingAvgOrderByAggregateInput
    _max?: RequestFundingMaxOrderByAggregateInput
    _min?: RequestFundingMinOrderByAggregateInput
    _sum?: RequestFundingSumOrderByAggregateInput
  }

  export type RequestFundingScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RequestFundingScalarWhereWithAggregatesInput>
    OR?: Enumerable<RequestFundingScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RequestFundingScalarWhereWithAggregatesInput>
    id?: BigIntWithAggregatesFilter | bigint | number
    userId?: StringNullableWithAggregatesFilter | string | null
    quantity?: IntWithAggregatesFilter | number
    requestId?: BigIntNullableWithAggregatesFilter | bigint | number | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    status?: EnumRequestFundingStatusWithAggregatesFilter | RequestFundingStatus
  }

  export type RequestReactionWhereInput = {
    AND?: Enumerable<RequestReactionWhereInput>
    OR?: Enumerable<RequestReactionWhereInput>
    NOT?: Enumerable<RequestReactionWhereInput>
    id?: BigIntFilter | bigint | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    userId?: StringFilter | string
    type?: EnumReactionTypeFilter | ReactionType
    request?: XOR<RequestPostRelationFilter, RequestPostWhereInput>
    requestId?: BigIntFilter | bigint | number
    createdAt?: DateTimeFilter | Date | string
  }

  export type RequestReactionOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    user?: UserOrderByWithRelationAndSearchRelevanceInput
    userId?: SortOrder
    type?: SortOrder
    request?: RequestPostOrderByWithRelationAndSearchRelevanceInput
    requestId?: SortOrder
    createdAt?: SortOrder
    _relevance?: RequestReactionOrderByRelevanceInput
  }

  export type RequestReactionWhereUniqueInput = {
    id?: bigint | number
    userId_requestId?: RequestReactionUserIdRequestIdCompoundUniqueInput
  }

  export type RequestReactionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    requestId?: SortOrder
    createdAt?: SortOrder
    _count?: RequestReactionCountOrderByAggregateInput
    _avg?: RequestReactionAvgOrderByAggregateInput
    _max?: RequestReactionMaxOrderByAggregateInput
    _min?: RequestReactionMinOrderByAggregateInput
    _sum?: RequestReactionSumOrderByAggregateInput
  }

  export type RequestReactionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RequestReactionScalarWhereWithAggregatesInput>
    OR?: Enumerable<RequestReactionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RequestReactionScalarWhereWithAggregatesInput>
    id?: BigIntWithAggregatesFilter | bigint | number
    userId?: StringWithAggregatesFilter | string
    type?: EnumReactionTypeWithAggregatesFilter | ReactionType
    requestId?: BigIntWithAggregatesFilter | bigint | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type RequestCommentWhereInput = {
    AND?: Enumerable<RequestCommentWhereInput>
    OR?: Enumerable<RequestCommentWhereInput>
    NOT?: Enumerable<RequestCommentWhereInput>
    id?: BigIntFilter | bigint | number
    request?: XOR<RequestPostRelationFilter, RequestPostWhereInput>
    requestId?: BigIntFilter | bigint | number
    user?: XOR<UserRelationFilter, UserWhereInput> | null
    userId?: StringNullableFilter | string | null
    parentId?: BigIntNullableFilter | bigint | number | null
    parentComment?: XOR<RequestCommentRelationFilter, RequestCommentWhereInput> | null
    rootId?: BigIntNullableFilter | bigint | number | null
    content?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    hearts?: RequestCommentHeartListRelationFilter
    childrenComments?: RequestCommentListRelationFilter
  }

  export type RequestCommentOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    request?: RequestPostOrderByWithRelationAndSearchRelevanceInput
    requestId?: SortOrder
    user?: UserOrderByWithRelationAndSearchRelevanceInput
    userId?: SortOrder
    parentId?: SortOrder
    parentComment?: RequestCommentOrderByWithRelationAndSearchRelevanceInput
    rootId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hearts?: RequestCommentHeartOrderByRelationAggregateInput
    childrenComments?: RequestCommentOrderByRelationAggregateInput
    _relevance?: RequestCommentOrderByRelevanceInput
  }

  export type RequestCommentWhereUniqueInput = {
    id?: bigint | number
  }

  export type RequestCommentOrderByWithAggregationInput = {
    id?: SortOrder
    requestId?: SortOrder
    userId?: SortOrder
    parentId?: SortOrder
    rootId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RequestCommentCountOrderByAggregateInput
    _avg?: RequestCommentAvgOrderByAggregateInput
    _max?: RequestCommentMaxOrderByAggregateInput
    _min?: RequestCommentMinOrderByAggregateInput
    _sum?: RequestCommentSumOrderByAggregateInput
  }

  export type RequestCommentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RequestCommentScalarWhereWithAggregatesInput>
    OR?: Enumerable<RequestCommentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RequestCommentScalarWhereWithAggregatesInput>
    id?: BigIntWithAggregatesFilter | bigint | number
    requestId?: BigIntWithAggregatesFilter | bigint | number
    userId?: StringNullableWithAggregatesFilter | string | null
    parentId?: BigIntNullableWithAggregatesFilter | bigint | number | null
    rootId?: BigIntNullableWithAggregatesFilter | bigint | number | null
    content?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type RequestCommentHeartWhereInput = {
    AND?: Enumerable<RequestCommentHeartWhereInput>
    OR?: Enumerable<RequestCommentHeartWhereInput>
    NOT?: Enumerable<RequestCommentHeartWhereInput>
    id?: BigIntFilter | bigint | number
    requestComment?: XOR<RequestCommentRelationFilter, RequestCommentWhereInput>
    requestCommentId?: BigIntFilter | bigint | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    userId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
  }

  export type RequestCommentHeartOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    requestComment?: RequestCommentOrderByWithRelationAndSearchRelevanceInput
    requestCommentId?: SortOrder
    user?: UserOrderByWithRelationAndSearchRelevanceInput
    userId?: SortOrder
    createdAt?: SortOrder
    _relevance?: RequestCommentHeartOrderByRelevanceInput
  }

  export type RequestCommentHeartWhereUniqueInput = {
    id?: bigint | number
    requestCommentId_userId?: RequestCommentHeartRequestCommentIdUserIdCompoundUniqueInput
  }

  export type RequestCommentHeartOrderByWithAggregationInput = {
    id?: SortOrder
    requestCommentId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: RequestCommentHeartCountOrderByAggregateInput
    _avg?: RequestCommentHeartAvgOrderByAggregateInput
    _max?: RequestCommentHeartMaxOrderByAggregateInput
    _min?: RequestCommentHeartMinOrderByAggregateInput
    _sum?: RequestCommentHeartSumOrderByAggregateInput
  }

  export type RequestCommentHeartScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RequestCommentHeartScalarWhereWithAggregatesInput>
    OR?: Enumerable<RequestCommentHeartScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RequestCommentHeartScalarWhereWithAggregatesInput>
    id?: BigIntWithAggregatesFilter | bigint | number
    requestCommentId?: BigIntWithAggregatesFilter | bigint | number
    userId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type RequestBookmarkWhereInput = {
    AND?: Enumerable<RequestBookmarkWhereInput>
    OR?: Enumerable<RequestBookmarkWhereInput>
    NOT?: Enumerable<RequestBookmarkWhereInput>
    id?: BigIntFilter | bigint | number
    request?: XOR<RequestPostRelationFilter, RequestPostWhereInput> | null
    requestId?: BigIntNullableFilter | bigint | number | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    userId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
  }

  export type RequestBookmarkOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    request?: RequestPostOrderByWithRelationAndSearchRelevanceInput
    requestId?: SortOrder
    user?: UserOrderByWithRelationAndSearchRelevanceInput
    userId?: SortOrder
    createdAt?: SortOrder
    _relevance?: RequestBookmarkOrderByRelevanceInput
  }

  export type RequestBookmarkWhereUniqueInput = {
    id?: bigint | number
  }

  export type RequestBookmarkOrderByWithAggregationInput = {
    id?: SortOrder
    requestId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: RequestBookmarkCountOrderByAggregateInput
    _avg?: RequestBookmarkAvgOrderByAggregateInput
    _max?: RequestBookmarkMaxOrderByAggregateInput
    _min?: RequestBookmarkMinOrderByAggregateInput
    _sum?: RequestBookmarkSumOrderByAggregateInput
  }

  export type RequestBookmarkScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RequestBookmarkScalarWhereWithAggregatesInput>
    OR?: Enumerable<RequestBookmarkScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RequestBookmarkScalarWhereWithAggregatesInput>
    id?: BigIntWithAggregatesFilter | bigint | number
    requestId?: BigIntNullableWithAggregatesFilter | bigint | number | null
    userId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type RequestPlatformWhereInput = {
    AND?: Enumerable<RequestPlatformWhereInput>
    OR?: Enumerable<RequestPlatformWhereInput>
    NOT?: Enumerable<RequestPlatformWhereInput>
    id?: BigIntFilter | bigint | number
    request?: XOR<RequestPostRelationFilter, RequestPostWhereInput>
    requestId?: BigIntFilter | bigint | number
    name?: EnumRequestPlatformTypeFilter | RequestPlatformType
  }

  export type RequestPlatformOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    request?: RequestPostOrderByWithRelationAndSearchRelevanceInput
    requestId?: SortOrder
    name?: SortOrder
  }

  export type RequestPlatformWhereUniqueInput = {
    id?: bigint | number
  }

  export type RequestPlatformOrderByWithAggregationInput = {
    id?: SortOrder
    requestId?: SortOrder
    name?: SortOrder
    _count?: RequestPlatformCountOrderByAggregateInput
    _avg?: RequestPlatformAvgOrderByAggregateInput
    _max?: RequestPlatformMaxOrderByAggregateInput
    _min?: RequestPlatformMinOrderByAggregateInput
    _sum?: RequestPlatformSumOrderByAggregateInput
  }

  export type RequestPlatformScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RequestPlatformScalarWhereWithAggregatesInput>
    OR?: Enumerable<RequestPlatformScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RequestPlatformScalarWhereWithAggregatesInput>
    id?: BigIntWithAggregatesFilter | bigint | number
    requestId?: BigIntWithAggregatesFilter | bigint | number
    name?: EnumRequestPlatformTypeWithAggregatesFilter | RequestPlatformType
  }

  export type RequestApplyCreatorWhereInput = {
    AND?: Enumerable<RequestApplyCreatorWhereInput>
    OR?: Enumerable<RequestApplyCreatorWhereInput>
    NOT?: Enumerable<RequestApplyCreatorWhereInput>
    id?: BigIntFilter | bigint | number
    request?: XOR<RequestPostRelationFilter, RequestPostWhereInput>
    requestId?: BigIntFilter | bigint | number
    creator?: XOR<CreatorRelationFilter, CreatorWhereInput> | null
    creatorId?: BigIntNullableFilter | bigint | number | null
  }

  export type RequestApplyCreatorOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    request?: RequestPostOrderByWithRelationAndSearchRelevanceInput
    requestId?: SortOrder
    creator?: CreatorOrderByWithRelationAndSearchRelevanceInput
    creatorId?: SortOrder
  }

  export type RequestApplyCreatorWhereUniqueInput = {
    id?: bigint | number
  }

  export type RequestApplyCreatorOrderByWithAggregationInput = {
    id?: SortOrder
    requestId?: SortOrder
    creatorId?: SortOrder
    _count?: RequestApplyCreatorCountOrderByAggregateInput
    _avg?: RequestApplyCreatorAvgOrderByAggregateInput
    _max?: RequestApplyCreatorMaxOrderByAggregateInput
    _min?: RequestApplyCreatorMinOrderByAggregateInput
    _sum?: RequestApplyCreatorSumOrderByAggregateInput
  }

  export type RequestApplyCreatorScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RequestApplyCreatorScalarWhereWithAggregatesInput>
    OR?: Enumerable<RequestApplyCreatorScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RequestApplyCreatorScalarWhereWithAggregatesInput>
    id?: BigIntWithAggregatesFilter | bigint | number
    requestId?: BigIntWithAggregatesFilter | bigint | number
    creatorId?: BigIntNullableWithAggregatesFilter | bigint | number | null
  }

  export type RequestReportWhereInput = {
    AND?: Enumerable<RequestReportWhereInput>
    OR?: Enumerable<RequestReportWhereInput>
    NOT?: Enumerable<RequestReportWhereInput>
    id?: BigIntFilter | bigint | number
    request?: XOR<RequestPostRelationFilter, RequestPostWhereInput>
    requestId?: BigIntFilter | bigint | number
    user?: XOR<UserRelationFilter, UserWhereInput> | null
    userId?: StringNullableFilter | string | null
    content?: StringFilter | string
    type?: EnumRequestReportTypeFilter | RequestReportType
    status?: EnumRequestReportStatusFilter | RequestReportStatus
    createdAt?: DateTimeFilter | Date | string
  }

  export type RequestReportOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    request?: RequestPostOrderByWithRelationAndSearchRelevanceInput
    requestId?: SortOrder
    user?: UserOrderByWithRelationAndSearchRelevanceInput
    userId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _relevance?: RequestReportOrderByRelevanceInput
  }

  export type RequestReportWhereUniqueInput = {
    id?: bigint | number
  }

  export type RequestReportOrderByWithAggregationInput = {
    id?: SortOrder
    requestId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: RequestReportCountOrderByAggregateInput
    _avg?: RequestReportAvgOrderByAggregateInput
    _max?: RequestReportMaxOrderByAggregateInput
    _min?: RequestReportMinOrderByAggregateInput
    _sum?: RequestReportSumOrderByAggregateInput
  }

  export type RequestReportScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RequestReportScalarWhereWithAggregatesInput>
    OR?: Enumerable<RequestReportScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RequestReportScalarWhereWithAggregatesInput>
    id?: BigIntWithAggregatesFilter | bigint | number
    requestId?: BigIntWithAggregatesFilter | bigint | number
    userId?: StringNullableWithAggregatesFilter | string | null
    content?: StringWithAggregatesFilter | string
    type?: EnumRequestReportTypeWithAggregatesFilter | RequestReportType
    status?: EnumRequestReportStatusWithAggregatesFilter | RequestReportStatus
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type RequestInquiryWhereInput = {
    AND?: Enumerable<RequestInquiryWhereInput>
    OR?: Enumerable<RequestInquiryWhereInput>
    NOT?: Enumerable<RequestInquiryWhereInput>
    id?: BigIntFilter | bigint | number
    request?: XOR<RequestPostRelationFilter, RequestPostWhereInput>
    requestId?: BigIntFilter | bigint | number
    creator?: XOR<CreatorRelationFilter, CreatorWhereInput> | null
    creatorId?: BigIntNullableFilter | bigint | number | null
    user?: XOR<UserRelationFilter, UserWhereInput> | null
    userId?: StringNullableFilter | string | null
    requestInquiryMessages?: RequestInquiryMessageListRelationFilter
    createdAt?: DateTimeFilter | Date | string
  }

  export type RequestInquiryOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    request?: RequestPostOrderByWithRelationAndSearchRelevanceInput
    requestId?: SortOrder
    creator?: CreatorOrderByWithRelationAndSearchRelevanceInput
    creatorId?: SortOrder
    user?: UserOrderByWithRelationAndSearchRelevanceInput
    userId?: SortOrder
    requestInquiryMessages?: RequestInquiryMessageOrderByRelationAggregateInput
    createdAt?: SortOrder
    _relevance?: RequestInquiryOrderByRelevanceInput
  }

  export type RequestInquiryWhereUniqueInput = {
    id?: bigint | number
  }

  export type RequestInquiryOrderByWithAggregationInput = {
    id?: SortOrder
    requestId?: SortOrder
    creatorId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: RequestInquiryCountOrderByAggregateInput
    _avg?: RequestInquiryAvgOrderByAggregateInput
    _max?: RequestInquiryMaxOrderByAggregateInput
    _min?: RequestInquiryMinOrderByAggregateInput
    _sum?: RequestInquirySumOrderByAggregateInput
  }

  export type RequestInquiryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RequestInquiryScalarWhereWithAggregatesInput>
    OR?: Enumerable<RequestInquiryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RequestInquiryScalarWhereWithAggregatesInput>
    id?: BigIntWithAggregatesFilter | bigint | number
    requestId?: BigIntWithAggregatesFilter | bigint | number
    creatorId?: BigIntNullableWithAggregatesFilter | bigint | number | null
    userId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type RequestInquiryMessageWhereInput = {
    AND?: Enumerable<RequestInquiryMessageWhereInput>
    OR?: Enumerable<RequestInquiryMessageWhereInput>
    NOT?: Enumerable<RequestInquiryMessageWhereInput>
    id?: BigIntFilter | bigint | number
    room?: XOR<RequestInquiryRelationFilter, RequestInquiryWhereInput>
    roomId?: BigIntFilter | bigint | number
    from?: XOR<UserRelationFilter, UserWhereInput>
    fromId?: StringFilter | string
    text?: StringFilter | string
    fileUrl?: StringNullableFilter | string | null
    type?: EnumMessageTypeFilter | MessageType
    isRead?: BoolNullableFilter | boolean | null
    createdAt?: DateTimeFilter | Date | string
  }

  export type RequestInquiryMessageOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    room?: RequestInquiryOrderByWithRelationAndSearchRelevanceInput
    roomId?: SortOrder
    from?: UserOrderByWithRelationAndSearchRelevanceInput
    fromId?: SortOrder
    text?: SortOrder
    fileUrl?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    _relevance?: RequestInquiryMessageOrderByRelevanceInput
  }

  export type RequestInquiryMessageWhereUniqueInput = {
    id?: bigint | number
  }

  export type RequestInquiryMessageOrderByWithAggregationInput = {
    id?: SortOrder
    roomId?: SortOrder
    fromId?: SortOrder
    text?: SortOrder
    fileUrl?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    _count?: RequestInquiryMessageCountOrderByAggregateInput
    _avg?: RequestInquiryMessageAvgOrderByAggregateInput
    _max?: RequestInquiryMessageMaxOrderByAggregateInput
    _min?: RequestInquiryMessageMinOrderByAggregateInput
    _sum?: RequestInquiryMessageSumOrderByAggregateInput
  }

  export type RequestInquiryMessageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RequestInquiryMessageScalarWhereWithAggregatesInput>
    OR?: Enumerable<RequestInquiryMessageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RequestInquiryMessageScalarWhereWithAggregatesInput>
    id?: BigIntWithAggregatesFilter | bigint | number
    roomId?: BigIntWithAggregatesFilter | bigint | number
    fromId?: StringWithAggregatesFilter | string
    text?: StringWithAggregatesFilter | string
    fileUrl?: StringNullableWithAggregatesFilter | string | null
    type?: EnumMessageTypeWithAggregatesFilter | MessageType
    isRead?: BoolNullableWithAggregatesFilter | boolean | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type PointWhereInput = {
    AND?: Enumerable<PointWhereInput>
    OR?: Enumerable<PointWhereInput>
    NOT?: Enumerable<PointWhereInput>
    id?: BigIntFilter | bigint | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    userId?: StringFilter | string
    quantity?: IntFilter | number
    type?: EnumPoinTypeFilter | PoinType
    createdAt?: DateTimeFilter | Date | string
  }

  export type PointOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    user?: UserOrderByWithRelationAndSearchRelevanceInput
    userId?: SortOrder
    quantity?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    _relevance?: PointOrderByRelevanceInput
  }

  export type PointWhereUniqueInput = {
    id?: bigint | number
  }

  export type PointOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    quantity?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    _count?: PointCountOrderByAggregateInput
    _avg?: PointAvgOrderByAggregateInput
    _max?: PointMaxOrderByAggregateInput
    _min?: PointMinOrderByAggregateInput
    _sum?: PointSumOrderByAggregateInput
  }

  export type PointScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PointScalarWhereWithAggregatesInput>
    OR?: Enumerable<PointScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PointScalarWhereWithAggregatesInput>
    id?: BigIntWithAggregatesFilter | bigint | number
    userId?: StringWithAggregatesFilter | string
    quantity?: IntWithAggregatesFilter | number
    type?: EnumPoinTypeWithAggregatesFilter | PoinType
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type RankingWhereInput = {
    AND?: Enumerable<RankingWhereInput>
    OR?: Enumerable<RankingWhereInput>
    NOT?: Enumerable<RankingWhereInput>
    id?: IntFilter | number
    user?: XOR<UserRelationFilter, UserWhereInput> | null
    userId?: StringNullableFilter | string | null
    ranking?: IntFilter | number
    type?: EnumRankingTypeFilter | RankingType
    score?: BigIntFilter | bigint | number
    change?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
  }

  export type RankingOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    user?: UserOrderByWithRelationAndSearchRelevanceInput
    userId?: SortOrder
    ranking?: SortOrder
    type?: SortOrder
    score?: SortOrder
    change?: SortOrder
    createdAt?: SortOrder
    _relevance?: RankingOrderByRelevanceInput
  }

  export type RankingWhereUniqueInput = {
    id?: number
  }

  export type RankingOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    ranking?: SortOrder
    type?: SortOrder
    score?: SortOrder
    change?: SortOrder
    createdAt?: SortOrder
    _count?: RankingCountOrderByAggregateInput
    _avg?: RankingAvgOrderByAggregateInput
    _max?: RankingMaxOrderByAggregateInput
    _min?: RankingMinOrderByAggregateInput
    _sum?: RankingSumOrderByAggregateInput
  }

  export type RankingScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RankingScalarWhereWithAggregatesInput>
    OR?: Enumerable<RankingScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RankingScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userId?: StringNullableWithAggregatesFilter | string | null
    ranking?: IntWithAggregatesFilter | number
    type?: EnumRankingTypeWithAggregatesFilter | RankingType
    score?: BigIntWithAggregatesFilter | bigint | number
    change?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type FaqWhereInput = {
    AND?: Enumerable<FaqWhereInput>
    OR?: Enumerable<FaqWhereInput>
    NOT?: Enumerable<FaqWhereInput>
    id?: IntFilter | number
    type?: EnumFaqTypeFilter | FaqType
    title?: StringFilter | string
    content?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
  }

  export type FaqOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    _relevance?: FaqOrderByRelevanceInput
  }

  export type FaqWhereUniqueInput = {
    id?: number
  }

  export type FaqOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    _count?: FaqCountOrderByAggregateInput
    _avg?: FaqAvgOrderByAggregateInput
    _max?: FaqMaxOrderByAggregateInput
    _min?: FaqMinOrderByAggregateInput
    _sum?: FaqSumOrderByAggregateInput
  }

  export type FaqScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FaqScalarWhereWithAggregatesInput>
    OR?: Enumerable<FaqScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FaqScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    type?: EnumFaqTypeWithAggregatesFilter | FaqType
    title?: StringWithAggregatesFilter | string
    content?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type NoticeWhereInput = {
    AND?: Enumerable<NoticeWhereInput>
    OR?: Enumerable<NoticeWhereInput>
    NOT?: Enumerable<NoticeWhereInput>
    id?: IntFilter | number
    title?: StringFilter | string
    content?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
  }

  export type NoticeOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    _relevance?: NoticeOrderByRelevanceInput
  }

  export type NoticeWhereUniqueInput = {
    id?: number
  }

  export type NoticeOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    _count?: NoticeCountOrderByAggregateInput
    _avg?: NoticeAvgOrderByAggregateInput
    _max?: NoticeMaxOrderByAggregateInput
    _min?: NoticeMinOrderByAggregateInput
    _sum?: NoticeSumOrderByAggregateInput
  }

  export type NoticeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<NoticeScalarWhereWithAggregatesInput>
    OR?: Enumerable<NoticeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<NoticeScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    title?: StringWithAggregatesFilter | string
    content?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CreatorWhereInput = {
    AND?: Enumerable<CreatorWhereInput>
    OR?: Enumerable<CreatorWhereInput>
    NOT?: Enumerable<CreatorWhereInput>
    id?: BigIntFilter | bigint | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    userId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    requestPosts?: RequestPostListRelationFilter
    requestApplyCreators?: RequestApplyCreatorListRelationFilter
    requestInquiries?: RequestInquiryListRelationFilter
    creatorAuths?: CreatorAuthListRelationFilter
    creatorReviews?: CreatorReviewListRelationFilter
  }

  export type CreatorOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    user?: UserOrderByWithRelationAndSearchRelevanceInput
    userId?: SortOrder
    createdAt?: SortOrder
    requestPosts?: RequestPostOrderByRelationAggregateInput
    requestApplyCreators?: RequestApplyCreatorOrderByRelationAggregateInput
    requestInquiries?: RequestInquiryOrderByRelationAggregateInput
    creatorAuths?: CreatorAuthOrderByRelationAggregateInput
    creatorReviews?: CreatorReviewOrderByRelationAggregateInput
    _relevance?: CreatorOrderByRelevanceInput
  }

  export type CreatorWhereUniqueInput = {
    id?: bigint | number
    userId?: string
  }

  export type CreatorOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: CreatorCountOrderByAggregateInput
    _avg?: CreatorAvgOrderByAggregateInput
    _max?: CreatorMaxOrderByAggregateInput
    _min?: CreatorMinOrderByAggregateInput
    _sum?: CreatorSumOrderByAggregateInput
  }

  export type CreatorScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CreatorScalarWhereWithAggregatesInput>
    OR?: Enumerable<CreatorScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CreatorScalarWhereWithAggregatesInput>
    id?: BigIntWithAggregatesFilter | bigint | number
    userId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CreatorAuthWhereInput = {
    AND?: Enumerable<CreatorAuthWhereInput>
    OR?: Enumerable<CreatorAuthWhereInput>
    NOT?: Enumerable<CreatorAuthWhereInput>
    id?: BigIntFilter | bigint | number
    creator?: XOR<CreatorRelationFilter, CreatorWhereInput>
    creatorId?: BigIntFilter | bigint | number
    isMain?: BoolFilter | boolean
    profileUrl?: StringNullableFilter | string | null
    platform?: EnumAuthPlatformTypeFilter | AuthPlatformType
    createdAt?: DateTimeFilter | Date | string
  }

  export type CreatorAuthOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    creator?: CreatorOrderByWithRelationAndSearchRelevanceInput
    creatorId?: SortOrder
    isMain?: SortOrder
    profileUrl?: SortOrder
    platform?: SortOrder
    createdAt?: SortOrder
    _relevance?: CreatorAuthOrderByRelevanceInput
  }

  export type CreatorAuthWhereUniqueInput = {
    id?: bigint | number
  }

  export type CreatorAuthOrderByWithAggregationInput = {
    id?: SortOrder
    creatorId?: SortOrder
    isMain?: SortOrder
    profileUrl?: SortOrder
    platform?: SortOrder
    createdAt?: SortOrder
    _count?: CreatorAuthCountOrderByAggregateInput
    _avg?: CreatorAuthAvgOrderByAggregateInput
    _max?: CreatorAuthMaxOrderByAggregateInput
    _min?: CreatorAuthMinOrderByAggregateInput
    _sum?: CreatorAuthSumOrderByAggregateInput
  }

  export type CreatorAuthScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CreatorAuthScalarWhereWithAggregatesInput>
    OR?: Enumerable<CreatorAuthScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CreatorAuthScalarWhereWithAggregatesInput>
    id?: BigIntWithAggregatesFilter | bigint | number
    creatorId?: BigIntWithAggregatesFilter | bigint | number
    isMain?: BoolWithAggregatesFilter | boolean
    profileUrl?: StringNullableWithAggregatesFilter | string | null
    platform?: EnumAuthPlatformTypeWithAggregatesFilter | AuthPlatformType
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CreatorReviewWhereInput = {
    AND?: Enumerable<CreatorReviewWhereInput>
    OR?: Enumerable<CreatorReviewWhereInput>
    NOT?: Enumerable<CreatorReviewWhereInput>
    id?: BigIntFilter | bigint | number
    creator?: XOR<CreatorRelationFilter, CreatorWhereInput>
    creatorId?: BigIntFilter | bigint | number
    user?: XOR<UserRelationFilter, UserWhereInput> | null
    userId?: StringNullableFilter | string | null
    reviewItems?: CreatorReviewItemListRelationFilter
    content?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
  }

  export type CreatorReviewOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    creator?: CreatorOrderByWithRelationAndSearchRelevanceInput
    creatorId?: SortOrder
    user?: UserOrderByWithRelationAndSearchRelevanceInput
    userId?: SortOrder
    reviewItems?: CreatorReviewItemOrderByRelationAggregateInput
    content?: SortOrder
    createdAt?: SortOrder
    _relevance?: CreatorReviewOrderByRelevanceInput
  }

  export type CreatorReviewWhereUniqueInput = {
    id?: bigint | number
  }

  export type CreatorReviewOrderByWithAggregationInput = {
    id?: SortOrder
    creatorId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    _count?: CreatorReviewCountOrderByAggregateInput
    _avg?: CreatorReviewAvgOrderByAggregateInput
    _max?: CreatorReviewMaxOrderByAggregateInput
    _min?: CreatorReviewMinOrderByAggregateInput
    _sum?: CreatorReviewSumOrderByAggregateInput
  }

  export type CreatorReviewScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CreatorReviewScalarWhereWithAggregatesInput>
    OR?: Enumerable<CreatorReviewScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CreatorReviewScalarWhereWithAggregatesInput>
    id?: BigIntWithAggregatesFilter | bigint | number
    creatorId?: BigIntWithAggregatesFilter | bigint | number
    userId?: StringNullableWithAggregatesFilter | string | null
    content?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CreatorReviewItemWhereInput = {
    AND?: Enumerable<CreatorReviewItemWhereInput>
    OR?: Enumerable<CreatorReviewItemWhereInput>
    NOT?: Enumerable<CreatorReviewItemWhereInput>
    id?: BigIntFilter | bigint | number
    review?: XOR<CreatorReviewRelationFilter, CreatorReviewWhereInput>
    reviewId?: BigIntFilter | bigint | number
    content?: StringFilter | string
    isChecked?: BoolFilter | boolean
  }

  export type CreatorReviewItemOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    review?: CreatorReviewOrderByWithRelationAndSearchRelevanceInput
    reviewId?: SortOrder
    content?: SortOrder
    isChecked?: SortOrder
    _relevance?: CreatorReviewItemOrderByRelevanceInput
  }

  export type CreatorReviewItemWhereUniqueInput = {
    id?: bigint | number
  }

  export type CreatorReviewItemOrderByWithAggregationInput = {
    id?: SortOrder
    reviewId?: SortOrder
    content?: SortOrder
    isChecked?: SortOrder
    _count?: CreatorReviewItemCountOrderByAggregateInput
    _avg?: CreatorReviewItemAvgOrderByAggregateInput
    _max?: CreatorReviewItemMaxOrderByAggregateInput
    _min?: CreatorReviewItemMinOrderByAggregateInput
    _sum?: CreatorReviewItemSumOrderByAggregateInput
  }

  export type CreatorReviewItemScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CreatorReviewItemScalarWhereWithAggregatesInput>
    OR?: Enumerable<CreatorReviewItemScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CreatorReviewItemScalarWhereWithAggregatesInput>
    id?: BigIntWithAggregatesFilter | bigint | number
    reviewId?: BigIntWithAggregatesFilter | bigint | number
    content?: StringWithAggregatesFilter | string
    isChecked?: BoolWithAggregatesFilter | boolean
  }

  export type LogWhereInput = {
    AND?: Enumerable<LogWhereInput>
    OR?: Enumerable<LogWhereInput>
    NOT?: Enumerable<LogWhereInput>
    id?: BigIntFilter | bigint | number
    logType?: EnumLogTypeFilter | LogType
    message?: StringNullableFilter | string | null
    senderId?: StringNullableFilter | string | null
    sender?: XOR<UserRelationFilter, UserWhereInput> | null
    isRead?: BoolNullableFilter | boolean | null
    receiver?: UserListRelationFilter
    requestId?: BigIntNullableFilter | bigint | number | null
    request?: XOR<RequestPostRelationFilter, RequestPostWhereInput> | null
    createdAt?: DateTimeFilter | Date | string
  }

  export type LogOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    logType?: SortOrder
    message?: SortOrder
    senderId?: SortOrder
    sender?: UserOrderByWithRelationAndSearchRelevanceInput
    isRead?: SortOrder
    receiver?: UserOrderByRelationAggregateInput
    requestId?: SortOrder
    request?: RequestPostOrderByWithRelationAndSearchRelevanceInput
    createdAt?: SortOrder
    _relevance?: LogOrderByRelevanceInput
  }

  export type LogWhereUniqueInput = {
    id?: bigint | number
  }

  export type LogOrderByWithAggregationInput = {
    id?: SortOrder
    logType?: SortOrder
    message?: SortOrder
    senderId?: SortOrder
    isRead?: SortOrder
    requestId?: SortOrder
    createdAt?: SortOrder
    _count?: LogCountOrderByAggregateInput
    _avg?: LogAvgOrderByAggregateInput
    _max?: LogMaxOrderByAggregateInput
    _min?: LogMinOrderByAggregateInput
    _sum?: LogSumOrderByAggregateInput
  }

  export type LogScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LogScalarWhereWithAggregatesInput>
    OR?: Enumerable<LogScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LogScalarWhereWithAggregatesInput>
    id?: BigIntWithAggregatesFilter | bigint | number
    logType?: EnumLogTypeWithAggregatesFilter | LogType
    message?: StringNullableWithAggregatesFilter | string | null
    senderId?: StringNullableWithAggregatesFilter | string | null
    isRead?: BoolNullableWithAggregatesFilter | boolean | null
    requestId?: BigIntNullableWithAggregatesFilter | bigint | number | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    introduction?: string | null
    totalPoint?: number
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    requestPosts?: RequestPostCreateNestedManyWithoutUserInput
    requestFundings?: RequestFundingCreateNestedManyWithoutUserInput
    requestComments?: RequestCommentCreateNestedManyWithoutUserInput
    requestReactions?: RequestReactionCreateNestedManyWithoutUserInput
    requestBookmarks?: RequestBookmarkCreateNestedManyWithoutUserInput
    requestReports?: RequestReportCreateNestedManyWithoutUserInput
    requestInquiries?: RequestInquiryCreateNestedManyWithoutUserInput
    requestinquiryMessages?: RequestInquiryMessageCreateNestedManyWithoutFromInput
    requestCommentHearts?: RequestCommentHeartCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutReceiverInput
    points?: PointCreateNestedManyWithoutUserInput
    rankings?: RankingCreateNestedManyWithoutUserInput
    creatorReviews?: CreatorReviewCreateNestedManyWithoutUserInput
    creator?: CreatorCreateNestedOneWithoutUserInput
    Log?: LogCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    introduction?: string | null
    totalPoint?: number
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    requestPosts?: RequestPostUncheckedCreateNestedManyWithoutUserInput
    requestFundings?: RequestFundingUncheckedCreateNestedManyWithoutUserInput
    requestComments?: RequestCommentUncheckedCreateNestedManyWithoutUserInput
    requestReactions?: RequestReactionUncheckedCreateNestedManyWithoutUserInput
    requestBookmarks?: RequestBookmarkUncheckedCreateNestedManyWithoutUserInput
    requestReports?: RequestReportUncheckedCreateNestedManyWithoutUserInput
    requestInquiries?: RequestInquiryUncheckedCreateNestedManyWithoutUserInput
    requestinquiryMessages?: RequestInquiryMessageUncheckedCreateNestedManyWithoutFromInput
    requestCommentHearts?: RequestCommentHeartUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutReceiverInput
    points?: PointUncheckedCreateNestedManyWithoutUserInput
    rankings?: RankingUncheckedCreateNestedManyWithoutUserInput
    creatorReviews?: CreatorReviewUncheckedCreateNestedManyWithoutUserInput
    creator?: CreatorUncheckedCreateNestedOneWithoutUserInput
    Log?: LogUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoint?: IntFieldUpdateOperationsInput | number
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    requestPosts?: RequestPostUpdateManyWithoutUserNestedInput
    requestFundings?: RequestFundingUpdateManyWithoutUserNestedInput
    requestComments?: RequestCommentUpdateManyWithoutUserNestedInput
    requestReactions?: RequestReactionUpdateManyWithoutUserNestedInput
    requestBookmarks?: RequestBookmarkUpdateManyWithoutUserNestedInput
    requestReports?: RequestReportUpdateManyWithoutUserNestedInput
    requestInquiries?: RequestInquiryUpdateManyWithoutUserNestedInput
    requestinquiryMessages?: RequestInquiryMessageUpdateManyWithoutFromNestedInput
    requestCommentHearts?: RequestCommentHeartUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutReceiverNestedInput
    points?: PointUpdateManyWithoutUserNestedInput
    rankings?: RankingUpdateManyWithoutUserNestedInput
    creatorReviews?: CreatorReviewUpdateManyWithoutUserNestedInput
    creator?: CreatorUpdateOneWithoutUserNestedInput
    Log?: LogUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoint?: IntFieldUpdateOperationsInput | number
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    requestPosts?: RequestPostUncheckedUpdateManyWithoutUserNestedInput
    requestFundings?: RequestFundingUncheckedUpdateManyWithoutUserNestedInput
    requestComments?: RequestCommentUncheckedUpdateManyWithoutUserNestedInput
    requestReactions?: RequestReactionUncheckedUpdateManyWithoutUserNestedInput
    requestBookmarks?: RequestBookmarkUncheckedUpdateManyWithoutUserNestedInput
    requestReports?: RequestReportUncheckedUpdateManyWithoutUserNestedInput
    requestInquiries?: RequestInquiryUncheckedUpdateManyWithoutUserNestedInput
    requestinquiryMessages?: RequestInquiryMessageUncheckedUpdateManyWithoutFromNestedInput
    requestCommentHearts?: RequestCommentHeartUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutReceiverNestedInput
    points?: PointUncheckedUpdateManyWithoutUserNestedInput
    rankings?: RankingUncheckedUpdateManyWithoutUserNestedInput
    creatorReviews?: CreatorReviewUncheckedUpdateManyWithoutUserNestedInput
    creator?: CreatorUncheckedUpdateOneWithoutUserNestedInput
    Log?: LogUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    introduction?: string | null
    totalPoint?: number
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoint?: IntFieldUpdateOperationsInput | number
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoint?: IntFieldUpdateOperationsInput | number
  }

  export type VerificationTokenCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestPostCreateInput = {
    id?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutRequestPostsInput
    title: string
    content: string
    creator?: CreatorCreateNestedOneWithoutRequestPostsInput
    category?: RequestCategoryType | null
    expires?: Date | string | null
    totalViews?: number
    status?: RequestStatusType
    solvedUrl?: string | null
    thumbnailUrl?: string | null
    refusalReason?: string | null
    totalQuantity?: number
    totalLikeScroe?: number
    isUnspecified?: boolean
    requestFundings?: RequestFundingCreateNestedManyWithoutRequestInput
    requestReactions?: RequestReactionCreateNestedManyWithoutRequestInput
    requestApplyCreators?: RequestApplyCreatorCreateNestedManyWithoutRequestInput
    requestPlatforms?: RequestPlatformCreateNestedManyWithoutRequestInput
    requestComments?: RequestCommentCreateNestedManyWithoutRequestInput
    requestBookmarks?: RequestBookmarkCreateNestedManyWithoutRequestInput
    requestReports?: RequestReportCreateNestedManyWithoutRequestInput
    requestInquirys?: RequestInquiryCreateNestedManyWithoutRequestInput
    Log?: LogCreateNestedManyWithoutRequestInput
  }

  export type RequestPostUncheckedCreateInput = {
    id?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    title: string
    content: string
    category?: RequestCategoryType | null
    creatorId?: bigint | number | null
    expires?: Date | string | null
    totalViews?: number
    status?: RequestStatusType
    solvedUrl?: string | null
    thumbnailUrl?: string | null
    refusalReason?: string | null
    totalQuantity?: number
    totalLikeScroe?: number
    isUnspecified?: boolean
    requestFundings?: RequestFundingUncheckedCreateNestedManyWithoutRequestInput
    requestReactions?: RequestReactionUncheckedCreateNestedManyWithoutRequestInput
    requestApplyCreators?: RequestApplyCreatorUncheckedCreateNestedManyWithoutRequestInput
    requestPlatforms?: RequestPlatformUncheckedCreateNestedManyWithoutRequestInput
    requestComments?: RequestCommentUncheckedCreateNestedManyWithoutRequestInput
    requestBookmarks?: RequestBookmarkUncheckedCreateNestedManyWithoutRequestInput
    requestReports?: RequestReportUncheckedCreateNestedManyWithoutRequestInput
    requestInquirys?: RequestInquiryUncheckedCreateNestedManyWithoutRequestInput
    Log?: LogUncheckedCreateNestedManyWithoutRequestInput
  }

  export type RequestPostUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutRequestPostsNestedInput
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    creator?: CreatorUpdateOneWithoutRequestPostsNestedInput
    category?: NullableEnumRequestCategoryTypeFieldUpdateOperationsInput | RequestCategoryType | null
    expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalViews?: IntFieldUpdateOperationsInput | number
    status?: EnumRequestStatusTypeFieldUpdateOperationsInput | RequestStatusType
    solvedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    refusalReason?: NullableStringFieldUpdateOperationsInput | string | null
    totalQuantity?: IntFieldUpdateOperationsInput | number
    totalLikeScroe?: IntFieldUpdateOperationsInput | number
    isUnspecified?: BoolFieldUpdateOperationsInput | boolean
    requestFundings?: RequestFundingUpdateManyWithoutRequestNestedInput
    requestReactions?: RequestReactionUpdateManyWithoutRequestNestedInput
    requestApplyCreators?: RequestApplyCreatorUpdateManyWithoutRequestNestedInput
    requestPlatforms?: RequestPlatformUpdateManyWithoutRequestNestedInput
    requestComments?: RequestCommentUpdateManyWithoutRequestNestedInput
    requestBookmarks?: RequestBookmarkUpdateManyWithoutRequestNestedInput
    requestReports?: RequestReportUpdateManyWithoutRequestNestedInput
    requestInquirys?: RequestInquiryUpdateManyWithoutRequestNestedInput
    Log?: LogUpdateManyWithoutRequestNestedInput
  }

  export type RequestPostUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableEnumRequestCategoryTypeFieldUpdateOperationsInput | RequestCategoryType | null
    creatorId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalViews?: IntFieldUpdateOperationsInput | number
    status?: EnumRequestStatusTypeFieldUpdateOperationsInput | RequestStatusType
    solvedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    refusalReason?: NullableStringFieldUpdateOperationsInput | string | null
    totalQuantity?: IntFieldUpdateOperationsInput | number
    totalLikeScroe?: IntFieldUpdateOperationsInput | number
    isUnspecified?: BoolFieldUpdateOperationsInput | boolean
    requestFundings?: RequestFundingUncheckedUpdateManyWithoutRequestNestedInput
    requestReactions?: RequestReactionUncheckedUpdateManyWithoutRequestNestedInput
    requestApplyCreators?: RequestApplyCreatorUncheckedUpdateManyWithoutRequestNestedInput
    requestPlatforms?: RequestPlatformUncheckedUpdateManyWithoutRequestNestedInput
    requestComments?: RequestCommentUncheckedUpdateManyWithoutRequestNestedInput
    requestBookmarks?: RequestBookmarkUncheckedUpdateManyWithoutRequestNestedInput
    requestReports?: RequestReportUncheckedUpdateManyWithoutRequestNestedInput
    requestInquirys?: RequestInquiryUncheckedUpdateManyWithoutRequestNestedInput
    Log?: LogUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type RequestPostCreateManyInput = {
    id?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    title: string
    content: string
    category?: RequestCategoryType | null
    creatorId?: bigint | number | null
    expires?: Date | string | null
    totalViews?: number
    status?: RequestStatusType
    solvedUrl?: string | null
    thumbnailUrl?: string | null
    refusalReason?: string | null
    totalQuantity?: number
    totalLikeScroe?: number
    isUnspecified?: boolean
  }

  export type RequestPostUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableEnumRequestCategoryTypeFieldUpdateOperationsInput | RequestCategoryType | null
    expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalViews?: IntFieldUpdateOperationsInput | number
    status?: EnumRequestStatusTypeFieldUpdateOperationsInput | RequestStatusType
    solvedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    refusalReason?: NullableStringFieldUpdateOperationsInput | string | null
    totalQuantity?: IntFieldUpdateOperationsInput | number
    totalLikeScroe?: IntFieldUpdateOperationsInput | number
    isUnspecified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RequestPostUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableEnumRequestCategoryTypeFieldUpdateOperationsInput | RequestCategoryType | null
    creatorId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalViews?: IntFieldUpdateOperationsInput | number
    status?: EnumRequestStatusTypeFieldUpdateOperationsInput | RequestStatusType
    solvedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    refusalReason?: NullableStringFieldUpdateOperationsInput | string | null
    totalQuantity?: IntFieldUpdateOperationsInput | number
    totalLikeScroe?: IntFieldUpdateOperationsInput | number
    isUnspecified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RequestFundingCreateInput = {
    id?: bigint | number
    user?: UserCreateNestedOneWithoutRequestFundingsInput
    quantity: number
    request?: RequestPostCreateNestedOneWithoutRequestFundingsInput
    createdAt?: Date | string
    status?: RequestFundingStatus
  }

  export type RequestFundingUncheckedCreateInput = {
    id?: bigint | number
    userId?: string | null
    quantity: number
    requestId?: bigint | number | null
    createdAt?: Date | string
    status?: RequestFundingStatus
  }

  export type RequestFundingUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user?: UserUpdateOneWithoutRequestFundingsNestedInput
    quantity?: IntFieldUpdateOperationsInput | number
    request?: RequestPostUpdateOneWithoutRequestFundingsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRequestFundingStatusFieldUpdateOperationsInput | RequestFundingStatus
  }

  export type RequestFundingUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    requestId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRequestFundingStatusFieldUpdateOperationsInput | RequestFundingStatus
  }

  export type RequestFundingCreateManyInput = {
    id?: bigint | number
    userId?: string | null
    quantity: number
    requestId?: bigint | number | null
    createdAt?: Date | string
    status?: RequestFundingStatus
  }

  export type RequestFundingUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRequestFundingStatusFieldUpdateOperationsInput | RequestFundingStatus
  }

  export type RequestFundingUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    requestId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRequestFundingStatusFieldUpdateOperationsInput | RequestFundingStatus
  }

  export type RequestReactionCreateInput = {
    id?: bigint | number
    user: UserCreateNestedOneWithoutRequestReactionsInput
    type: ReactionType
    request: RequestPostCreateNestedOneWithoutRequestReactionsInput
    createdAt?: Date | string
  }

  export type RequestReactionUncheckedCreateInput = {
    id?: bigint | number
    userId: string
    type: ReactionType
    requestId: bigint | number
    createdAt?: Date | string
  }

  export type RequestReactionUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user?: UserUpdateOneRequiredWithoutRequestReactionsNestedInput
    type?: EnumReactionTypeFieldUpdateOperationsInput | ReactionType
    request?: RequestPostUpdateOneRequiredWithoutRequestReactionsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestReactionUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | ReactionType
    requestId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestReactionCreateManyInput = {
    id?: bigint | number
    userId: string
    type: ReactionType
    requestId: bigint | number
    createdAt?: Date | string
  }

  export type RequestReactionUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    type?: EnumReactionTypeFieldUpdateOperationsInput | ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestReactionUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | ReactionType
    requestId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestCommentCreateInput = {
    id?: bigint | number
    request: RequestPostCreateNestedOneWithoutRequestCommentsInput
    user?: UserCreateNestedOneWithoutRequestCommentsInput
    parentComment?: RequestCommentCreateNestedOneWithoutChildrenCommentsInput
    rootId?: bigint | number | null
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    hearts?: RequestCommentHeartCreateNestedManyWithoutRequestCommentInput
    childrenComments?: RequestCommentCreateNestedManyWithoutParentCommentInput
  }

  export type RequestCommentUncheckedCreateInput = {
    id?: bigint | number
    requestId: bigint | number
    userId?: string | null
    parentId?: bigint | number | null
    rootId?: bigint | number | null
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    hearts?: RequestCommentHeartUncheckedCreateNestedManyWithoutRequestCommentInput
    childrenComments?: RequestCommentUncheckedCreateNestedManyWithoutParentCommentInput
  }

  export type RequestCommentUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    request?: RequestPostUpdateOneRequiredWithoutRequestCommentsNestedInput
    user?: UserUpdateOneWithoutRequestCommentsNestedInput
    parentComment?: RequestCommentUpdateOneWithoutChildrenCommentsNestedInput
    rootId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hearts?: RequestCommentHeartUpdateManyWithoutRequestCommentNestedInput
    childrenComments?: RequestCommentUpdateManyWithoutParentCommentNestedInput
  }

  export type RequestCommentUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    requestId?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    rootId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hearts?: RequestCommentHeartUncheckedUpdateManyWithoutRequestCommentNestedInput
    childrenComments?: RequestCommentUncheckedUpdateManyWithoutParentCommentNestedInput
  }

  export type RequestCommentCreateManyInput = {
    id?: bigint | number
    requestId: bigint | number
    userId?: string | null
    parentId?: bigint | number | null
    rootId?: bigint | number | null
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequestCommentUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    rootId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestCommentUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    requestId?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    rootId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestCommentHeartCreateInput = {
    id?: bigint | number
    requestComment: RequestCommentCreateNestedOneWithoutHeartsInput
    user: UserCreateNestedOneWithoutRequestCommentHeartsInput
    createdAt?: Date | string
  }

  export type RequestCommentHeartUncheckedCreateInput = {
    id?: bigint | number
    requestCommentId: bigint | number
    userId: string
    createdAt?: Date | string
  }

  export type RequestCommentHeartUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    requestComment?: RequestCommentUpdateOneRequiredWithoutHeartsNestedInput
    user?: UserUpdateOneRequiredWithoutRequestCommentHeartsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestCommentHeartUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    requestCommentId?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestCommentHeartCreateManyInput = {
    id?: bigint | number
    requestCommentId: bigint | number
    userId: string
    createdAt?: Date | string
  }

  export type RequestCommentHeartUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestCommentHeartUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    requestCommentId?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestBookmarkCreateInput = {
    id?: bigint | number
    request?: RequestPostCreateNestedOneWithoutRequestBookmarksInput
    user: UserCreateNestedOneWithoutRequestBookmarksInput
    createdAt?: Date | string
  }

  export type RequestBookmarkUncheckedCreateInput = {
    id?: bigint | number
    requestId?: bigint | number | null
    userId: string
    createdAt?: Date | string
  }

  export type RequestBookmarkUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    request?: RequestPostUpdateOneWithoutRequestBookmarksNestedInput
    user?: UserUpdateOneRequiredWithoutRequestBookmarksNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestBookmarkUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    requestId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestBookmarkCreateManyInput = {
    id?: bigint | number
    requestId?: bigint | number | null
    userId: string
    createdAt?: Date | string
  }

  export type RequestBookmarkUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestBookmarkUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    requestId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestPlatformCreateInput = {
    id?: bigint | number
    request: RequestPostCreateNestedOneWithoutRequestPlatformsInput
    name: RequestPlatformType
  }

  export type RequestPlatformUncheckedCreateInput = {
    id?: bigint | number
    requestId: bigint | number
    name: RequestPlatformType
  }

  export type RequestPlatformUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    request?: RequestPostUpdateOneRequiredWithoutRequestPlatformsNestedInput
    name?: EnumRequestPlatformTypeFieldUpdateOperationsInput | RequestPlatformType
  }

  export type RequestPlatformUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    requestId?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: EnumRequestPlatformTypeFieldUpdateOperationsInput | RequestPlatformType
  }

  export type RequestPlatformCreateManyInput = {
    id?: bigint | number
    requestId: bigint | number
    name: RequestPlatformType
  }

  export type RequestPlatformUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: EnumRequestPlatformTypeFieldUpdateOperationsInput | RequestPlatformType
  }

  export type RequestPlatformUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    requestId?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: EnumRequestPlatformTypeFieldUpdateOperationsInput | RequestPlatformType
  }

  export type RequestApplyCreatorCreateInput = {
    id?: bigint | number
    request: RequestPostCreateNestedOneWithoutRequestApplyCreatorsInput
    creator?: CreatorCreateNestedOneWithoutRequestApplyCreatorsInput
  }

  export type RequestApplyCreatorUncheckedCreateInput = {
    id?: bigint | number
    requestId: bigint | number
    creatorId?: bigint | number | null
  }

  export type RequestApplyCreatorUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    request?: RequestPostUpdateOneRequiredWithoutRequestApplyCreatorsNestedInput
    creator?: CreatorUpdateOneWithoutRequestApplyCreatorsNestedInput
  }

  export type RequestApplyCreatorUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    requestId?: BigIntFieldUpdateOperationsInput | bigint | number
    creatorId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type RequestApplyCreatorCreateManyInput = {
    id?: bigint | number
    requestId: bigint | number
    creatorId?: bigint | number | null
  }

  export type RequestApplyCreatorUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type RequestApplyCreatorUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    requestId?: BigIntFieldUpdateOperationsInput | bigint | number
    creatorId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type RequestReportCreateInput = {
    id?: bigint | number
    request: RequestPostCreateNestedOneWithoutRequestReportsInput
    user?: UserCreateNestedOneWithoutRequestReportsInput
    content: string
    type: RequestReportType
    status: RequestReportStatus
    createdAt?: Date | string
  }

  export type RequestReportUncheckedCreateInput = {
    id?: bigint | number
    requestId: bigint | number
    userId?: string | null
    content: string
    type: RequestReportType
    status: RequestReportStatus
    createdAt?: Date | string
  }

  export type RequestReportUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    request?: RequestPostUpdateOneRequiredWithoutRequestReportsNestedInput
    user?: UserUpdateOneWithoutRequestReportsNestedInput
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumRequestReportTypeFieldUpdateOperationsInput | RequestReportType
    status?: EnumRequestReportStatusFieldUpdateOperationsInput | RequestReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestReportUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    requestId?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumRequestReportTypeFieldUpdateOperationsInput | RequestReportType
    status?: EnumRequestReportStatusFieldUpdateOperationsInput | RequestReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestReportCreateManyInput = {
    id?: bigint | number
    requestId: bigint | number
    userId?: string | null
    content: string
    type: RequestReportType
    status: RequestReportStatus
    createdAt?: Date | string
  }

  export type RequestReportUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumRequestReportTypeFieldUpdateOperationsInput | RequestReportType
    status?: EnumRequestReportStatusFieldUpdateOperationsInput | RequestReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestReportUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    requestId?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumRequestReportTypeFieldUpdateOperationsInput | RequestReportType
    status?: EnumRequestReportStatusFieldUpdateOperationsInput | RequestReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestInquiryCreateInput = {
    id?: bigint | number
    request: RequestPostCreateNestedOneWithoutRequestInquirysInput
    creator?: CreatorCreateNestedOneWithoutRequestInquiriesInput
    user?: UserCreateNestedOneWithoutRequestInquiriesInput
    requestInquiryMessages?: RequestInquiryMessageCreateNestedManyWithoutRoomInput
    createdAt?: Date | string
  }

  export type RequestInquiryUncheckedCreateInput = {
    id?: bigint | number
    requestId: bigint | number
    creatorId?: bigint | number | null
    userId?: string | null
    requestInquiryMessages?: RequestInquiryMessageUncheckedCreateNestedManyWithoutRoomInput
    createdAt?: Date | string
  }

  export type RequestInquiryUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    request?: RequestPostUpdateOneRequiredWithoutRequestInquirysNestedInput
    creator?: CreatorUpdateOneWithoutRequestInquiriesNestedInput
    user?: UserUpdateOneWithoutRequestInquiriesNestedInput
    requestInquiryMessages?: RequestInquiryMessageUpdateManyWithoutRoomNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestInquiryUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    requestId?: BigIntFieldUpdateOperationsInput | bigint | number
    creatorId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    requestInquiryMessages?: RequestInquiryMessageUncheckedUpdateManyWithoutRoomNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestInquiryCreateManyInput = {
    id?: bigint | number
    requestId: bigint | number
    creatorId?: bigint | number | null
    userId?: string | null
    createdAt?: Date | string
  }

  export type RequestInquiryUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestInquiryUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    requestId?: BigIntFieldUpdateOperationsInput | bigint | number
    creatorId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestInquiryMessageCreateInput = {
    id?: bigint | number
    room: RequestInquiryCreateNestedOneWithoutRequestInquiryMessagesInput
    from: UserCreateNestedOneWithoutRequestinquiryMessagesInput
    text: string
    fileUrl?: string | null
    type?: MessageType
    isRead?: boolean | null
    createdAt?: Date | string
  }

  export type RequestInquiryMessageUncheckedCreateInput = {
    id?: bigint | number
    roomId: bigint | number
    fromId: string
    text: string
    fileUrl?: string | null
    type?: MessageType
    isRead?: boolean | null
    createdAt?: Date | string
  }

  export type RequestInquiryMessageUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    room?: RequestInquiryUpdateOneRequiredWithoutRequestInquiryMessagesNestedInput
    from?: UserUpdateOneRequiredWithoutRequestinquiryMessagesNestedInput
    text?: StringFieldUpdateOperationsInput | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMessageTypeFieldUpdateOperationsInput | MessageType
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestInquiryMessageUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    roomId?: BigIntFieldUpdateOperationsInput | bigint | number
    fromId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMessageTypeFieldUpdateOperationsInput | MessageType
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestInquiryMessageCreateManyInput = {
    id?: bigint | number
    roomId: bigint | number
    fromId: string
    text: string
    fileUrl?: string | null
    type?: MessageType
    isRead?: boolean | null
    createdAt?: Date | string
  }

  export type RequestInquiryMessageUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    text?: StringFieldUpdateOperationsInput | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMessageTypeFieldUpdateOperationsInput | MessageType
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestInquiryMessageUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    roomId?: BigIntFieldUpdateOperationsInput | bigint | number
    fromId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMessageTypeFieldUpdateOperationsInput | MessageType
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointCreateInput = {
    id?: bigint | number
    user: UserCreateNestedOneWithoutPointsInput
    quantity: number
    type: PoinType
    createdAt?: Date | string
  }

  export type PointUncheckedCreateInput = {
    id?: bigint | number
    userId: string
    quantity: number
    type: PoinType
    createdAt?: Date | string
  }

  export type PointUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user?: UserUpdateOneRequiredWithoutPointsNestedInput
    quantity?: IntFieldUpdateOperationsInput | number
    type?: EnumPoinTypeFieldUpdateOperationsInput | PoinType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    type?: EnumPoinTypeFieldUpdateOperationsInput | PoinType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointCreateManyInput = {
    id?: bigint | number
    userId: string
    quantity: number
    type: PoinType
    createdAt?: Date | string
  }

  export type PointUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: IntFieldUpdateOperationsInput | number
    type?: EnumPoinTypeFieldUpdateOperationsInput | PoinType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    type?: EnumPoinTypeFieldUpdateOperationsInput | PoinType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RankingCreateInput = {
    user?: UserCreateNestedOneWithoutRankingsInput
    ranking: number
    type: RankingType
    score: bigint | number
    change: number
    createdAt?: Date | string
  }

  export type RankingUncheckedCreateInput = {
    id?: number
    userId?: string | null
    ranking: number
    type: RankingType
    score: bigint | number
    change: number
    createdAt?: Date | string
  }

  export type RankingUpdateInput = {
    user?: UserUpdateOneWithoutRankingsNestedInput
    ranking?: IntFieldUpdateOperationsInput | number
    type?: EnumRankingTypeFieldUpdateOperationsInput | RankingType
    score?: BigIntFieldUpdateOperationsInput | bigint | number
    change?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RankingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    ranking?: IntFieldUpdateOperationsInput | number
    type?: EnumRankingTypeFieldUpdateOperationsInput | RankingType
    score?: BigIntFieldUpdateOperationsInput | bigint | number
    change?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RankingCreateManyInput = {
    id?: number
    userId?: string | null
    ranking: number
    type: RankingType
    score: bigint | number
    change: number
    createdAt?: Date | string
  }

  export type RankingUpdateManyMutationInput = {
    ranking?: IntFieldUpdateOperationsInput | number
    type?: EnumRankingTypeFieldUpdateOperationsInput | RankingType
    score?: BigIntFieldUpdateOperationsInput | bigint | number
    change?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RankingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    ranking?: IntFieldUpdateOperationsInput | number
    type?: EnumRankingTypeFieldUpdateOperationsInput | RankingType
    score?: BigIntFieldUpdateOperationsInput | bigint | number
    change?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FaqCreateInput = {
    type: FaqType
    title: string
    content: string
    createdAt?: Date | string
  }

  export type FaqUncheckedCreateInput = {
    id?: number
    type: FaqType
    title: string
    content: string
    createdAt?: Date | string
  }

  export type FaqUpdateInput = {
    type?: EnumFaqTypeFieldUpdateOperationsInput | FaqType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FaqUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumFaqTypeFieldUpdateOperationsInput | FaqType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FaqCreateManyInput = {
    id?: number
    type: FaqType
    title: string
    content: string
    createdAt?: Date | string
  }

  export type FaqUpdateManyMutationInput = {
    type?: EnumFaqTypeFieldUpdateOperationsInput | FaqType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FaqUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumFaqTypeFieldUpdateOperationsInput | FaqType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoticeCreateInput = {
    title: string
    content: string
    createdAt?: Date | string
  }

  export type NoticeUncheckedCreateInput = {
    id?: number
    title: string
    content: string
    createdAt?: Date | string
  }

  export type NoticeUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoticeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoticeCreateManyInput = {
    id?: number
    title: string
    content: string
    createdAt?: Date | string
  }

  export type NoticeUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoticeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreatorCreateInput = {
    id?: bigint | number
    user: UserCreateNestedOneWithoutCreatorInput
    createdAt?: Date | string
    requestPosts?: RequestPostCreateNestedManyWithoutCreatorInput
    requestApplyCreators?: RequestApplyCreatorCreateNestedManyWithoutCreatorInput
    requestInquiries?: RequestInquiryCreateNestedManyWithoutCreatorInput
    creatorAuths?: CreatorAuthCreateNestedManyWithoutCreatorInput
    creatorReviews?: CreatorReviewCreateNestedManyWithoutCreatorInput
  }

  export type CreatorUncheckedCreateInput = {
    id?: bigint | number
    userId: string
    createdAt?: Date | string
    requestPosts?: RequestPostUncheckedCreateNestedManyWithoutCreatorInput
    requestApplyCreators?: RequestApplyCreatorUncheckedCreateNestedManyWithoutCreatorInput
    requestInquiries?: RequestInquiryUncheckedCreateNestedManyWithoutCreatorInput
    creatorAuths?: CreatorAuthUncheckedCreateNestedManyWithoutCreatorInput
    creatorReviews?: CreatorReviewUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type CreatorUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user?: UserUpdateOneRequiredWithoutCreatorNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestPosts?: RequestPostUpdateManyWithoutCreatorNestedInput
    requestApplyCreators?: RequestApplyCreatorUpdateManyWithoutCreatorNestedInput
    requestInquiries?: RequestInquiryUpdateManyWithoutCreatorNestedInput
    creatorAuths?: CreatorAuthUpdateManyWithoutCreatorNestedInput
    creatorReviews?: CreatorReviewUpdateManyWithoutCreatorNestedInput
  }

  export type CreatorUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestPosts?: RequestPostUncheckedUpdateManyWithoutCreatorNestedInput
    requestApplyCreators?: RequestApplyCreatorUncheckedUpdateManyWithoutCreatorNestedInput
    requestInquiries?: RequestInquiryUncheckedUpdateManyWithoutCreatorNestedInput
    creatorAuths?: CreatorAuthUncheckedUpdateManyWithoutCreatorNestedInput
    creatorReviews?: CreatorReviewUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type CreatorCreateManyInput = {
    id?: bigint | number
    userId: string
    createdAt?: Date | string
  }

  export type CreatorUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreatorUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreatorAuthCreateInput = {
    id?: bigint | number
    creator: CreatorCreateNestedOneWithoutCreatorAuthsInput
    isMain?: boolean
    profileUrl?: string | null
    platform: AuthPlatformType
    createdAt?: Date | string
  }

  export type CreatorAuthUncheckedCreateInput = {
    id?: bigint | number
    creatorId: bigint | number
    isMain?: boolean
    profileUrl?: string | null
    platform: AuthPlatformType
    createdAt?: Date | string
  }

  export type CreatorAuthUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    creator?: CreatorUpdateOneRequiredWithoutCreatorAuthsNestedInput
    isMain?: BoolFieldUpdateOperationsInput | boolean
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: EnumAuthPlatformTypeFieldUpdateOperationsInput | AuthPlatformType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreatorAuthUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    creatorId?: BigIntFieldUpdateOperationsInput | bigint | number
    isMain?: BoolFieldUpdateOperationsInput | boolean
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: EnumAuthPlatformTypeFieldUpdateOperationsInput | AuthPlatformType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreatorAuthCreateManyInput = {
    id?: bigint | number
    creatorId: bigint | number
    isMain?: boolean
    profileUrl?: string | null
    platform: AuthPlatformType
    createdAt?: Date | string
  }

  export type CreatorAuthUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    isMain?: BoolFieldUpdateOperationsInput | boolean
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: EnumAuthPlatformTypeFieldUpdateOperationsInput | AuthPlatformType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreatorAuthUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    creatorId?: BigIntFieldUpdateOperationsInput | bigint | number
    isMain?: BoolFieldUpdateOperationsInput | boolean
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: EnumAuthPlatformTypeFieldUpdateOperationsInput | AuthPlatformType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreatorReviewCreateInput = {
    id?: bigint | number
    creator: CreatorCreateNestedOneWithoutCreatorReviewsInput
    user?: UserCreateNestedOneWithoutCreatorReviewsInput
    reviewItems?: CreatorReviewItemCreateNestedManyWithoutReviewInput
    content?: string | null
    createdAt?: Date | string
  }

  export type CreatorReviewUncheckedCreateInput = {
    id?: bigint | number
    creatorId: bigint | number
    userId?: string | null
    reviewItems?: CreatorReviewItemUncheckedCreateNestedManyWithoutReviewInput
    content?: string | null
    createdAt?: Date | string
  }

  export type CreatorReviewUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    creator?: CreatorUpdateOneRequiredWithoutCreatorReviewsNestedInput
    user?: UserUpdateOneWithoutCreatorReviewsNestedInput
    reviewItems?: CreatorReviewItemUpdateManyWithoutReviewNestedInput
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreatorReviewUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    creatorId?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewItems?: CreatorReviewItemUncheckedUpdateManyWithoutReviewNestedInput
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreatorReviewCreateManyInput = {
    id?: bigint | number
    creatorId: bigint | number
    userId?: string | null
    content?: string | null
    createdAt?: Date | string
  }

  export type CreatorReviewUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreatorReviewUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    creatorId?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreatorReviewItemCreateInput = {
    id?: bigint | number
    review: CreatorReviewCreateNestedOneWithoutReviewItemsInput
    content: string
    isChecked?: boolean
  }

  export type CreatorReviewItemUncheckedCreateInput = {
    id?: bigint | number
    reviewId: bigint | number
    content: string
    isChecked?: boolean
  }

  export type CreatorReviewItemUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    review?: CreatorReviewUpdateOneRequiredWithoutReviewItemsNestedInput
    content?: StringFieldUpdateOperationsInput | string
    isChecked?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CreatorReviewItemUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    reviewId?: BigIntFieldUpdateOperationsInput | bigint | number
    content?: StringFieldUpdateOperationsInput | string
    isChecked?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CreatorReviewItemCreateManyInput = {
    id?: bigint | number
    reviewId: bigint | number
    content: string
    isChecked?: boolean
  }

  export type CreatorReviewItemUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    content?: StringFieldUpdateOperationsInput | string
    isChecked?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CreatorReviewItemUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    reviewId?: BigIntFieldUpdateOperationsInput | bigint | number
    content?: StringFieldUpdateOperationsInput | string
    isChecked?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LogCreateInput = {
    id?: bigint | number
    logType: LogType
    message?: string | null
    sender?: UserCreateNestedOneWithoutLogInput
    isRead?: boolean | null
    receiver?: UserCreateNestedManyWithoutLogsInput
    request?: RequestPostCreateNestedOneWithoutLogInput
    createdAt?: Date | string
  }

  export type LogUncheckedCreateInput = {
    id?: bigint | number
    logType: LogType
    message?: string | null
    senderId?: string | null
    isRead?: boolean | null
    receiver?: UserUncheckedCreateNestedManyWithoutLogsInput
    requestId?: bigint | number | null
    createdAt?: Date | string
  }

  export type LogUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    logType?: EnumLogTypeFieldUpdateOperationsInput | LogType
    message?: NullableStringFieldUpdateOperationsInput | string | null
    sender?: UserUpdateOneWithoutLogNestedInput
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiver?: UserUpdateManyWithoutLogsNestedInput
    request?: RequestPostUpdateOneWithoutLogNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    logType?: EnumLogTypeFieldUpdateOperationsInput | LogType
    message?: NullableStringFieldUpdateOperationsInput | string | null
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiver?: UserUncheckedUpdateManyWithoutLogsNestedInput
    requestId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogCreateManyInput = {
    id?: bigint | number
    logType: LogType
    message?: string | null
    senderId?: string | null
    isRead?: boolean | null
    requestId?: bigint | number | null
    createdAt?: Date | string
  }

  export type LogUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    logType?: EnumLogTypeFieldUpdateOperationsInput | LogType
    message?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    logType?: EnumLogTypeFieldUpdateOperationsInput | LogType
    message?: NullableStringFieldUpdateOperationsInput | string | null
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    requestId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    not?: NestedStringFilter | string
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AccountOrderByRelevanceInput = {
    fields: Enumerable<AccountOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type SessionOrderByRelevanceInput = {
    fields: Enumerable<SessionOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type RequestPostListRelationFilter = {
    every?: RequestPostWhereInput
    some?: RequestPostWhereInput
    none?: RequestPostWhereInput
  }

  export type RequestFundingListRelationFilter = {
    every?: RequestFundingWhereInput
    some?: RequestFundingWhereInput
    none?: RequestFundingWhereInput
  }

  export type RequestCommentListRelationFilter = {
    every?: RequestCommentWhereInput
    some?: RequestCommentWhereInput
    none?: RequestCommentWhereInput
  }

  export type RequestReactionListRelationFilter = {
    every?: RequestReactionWhereInput
    some?: RequestReactionWhereInput
    none?: RequestReactionWhereInput
  }

  export type RequestBookmarkListRelationFilter = {
    every?: RequestBookmarkWhereInput
    some?: RequestBookmarkWhereInput
    none?: RequestBookmarkWhereInput
  }

  export type RequestReportListRelationFilter = {
    every?: RequestReportWhereInput
    some?: RequestReportWhereInput
    none?: RequestReportWhereInput
  }

  export type RequestInquiryListRelationFilter = {
    every?: RequestInquiryWhereInput
    some?: RequestInquiryWhereInput
    none?: RequestInquiryWhereInput
  }

  export type RequestInquiryMessageListRelationFilter = {
    every?: RequestInquiryMessageWhereInput
    some?: RequestInquiryMessageWhereInput
    none?: RequestInquiryMessageWhereInput
  }

  export type RequestCommentHeartListRelationFilter = {
    every?: RequestCommentHeartWhereInput
    some?: RequestCommentHeartWhereInput
    none?: RequestCommentHeartWhereInput
  }

  export type LogListRelationFilter = {
    every?: LogWhereInput
    some?: LogWhereInput
    none?: LogWhereInput
  }

  export type PointListRelationFilter = {
    every?: PointWhereInput
    some?: PointWhereInput
    none?: PointWhereInput
  }

  export type RankingListRelationFilter = {
    every?: RankingWhereInput
    some?: RankingWhereInput
    none?: RankingWhereInput
  }

  export type CreatorReviewListRelationFilter = {
    every?: CreatorReviewWhereInput
    some?: CreatorReviewWhereInput
    none?: CreatorReviewWhereInput
  }

  export type CreatorRelationFilter = {
    is?: CreatorWhereInput | null
    isNot?: CreatorWhereInput | null
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RequestPostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RequestFundingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RequestCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RequestReactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RequestBookmarkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RequestReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RequestInquiryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RequestInquiryMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RequestCommentHeartOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PointOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RankingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CreatorReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelevanceInput = {
    fields: Enumerable<UserOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    introduction?: SortOrder
    totalPoint?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    totalPoint?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    introduction?: SortOrder
    totalPoint?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    introduction?: SortOrder
    totalPoint?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    totalPoint?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type VerificationTokenOrderByRelevanceInput = {
    fields: Enumerable<VerificationTokenOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type BigIntFilter = {
    equals?: bigint | number
    in?: Enumerable<bigint> | Enumerable<number>
    notIn?: Enumerable<bigint> | Enumerable<number>
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntFilter | bigint | number
  }

  export type EnumRequestCategoryTypeNullableFilter = {
    equals?: RequestCategoryType | null
    in?: Enumerable<RequestCategoryType> | null
    notIn?: Enumerable<RequestCategoryType> | null
    not?: NestedEnumRequestCategoryTypeNullableFilter | RequestCategoryType | null
  }

  export type BigIntNullableFilter = {
    equals?: bigint | number | null
    in?: Enumerable<bigint> | Enumerable<number> | null
    notIn?: Enumerable<bigint> | Enumerable<number> | null
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntNullableFilter | bigint | number | null
  }

  export type EnumRequestStatusTypeFilter = {
    equals?: RequestStatusType
    in?: Enumerable<RequestStatusType>
    notIn?: Enumerable<RequestStatusType>
    not?: NestedEnumRequestStatusTypeFilter | RequestStatusType
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type RequestApplyCreatorListRelationFilter = {
    every?: RequestApplyCreatorWhereInput
    some?: RequestApplyCreatorWhereInput
    none?: RequestApplyCreatorWhereInput
  }

  export type RequestPlatformListRelationFilter = {
    every?: RequestPlatformWhereInput
    some?: RequestPlatformWhereInput
    none?: RequestPlatformWhereInput
  }

  export type RequestApplyCreatorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RequestPlatformOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RequestPostOrderByRelevanceInput = {
    fields: Enumerable<RequestPostOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type RequestPostCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    category?: SortOrder
    creatorId?: SortOrder
    expires?: SortOrder
    totalViews?: SortOrder
    status?: SortOrder
    solvedUrl?: SortOrder
    thumbnailUrl?: SortOrder
    refusalReason?: SortOrder
    totalQuantity?: SortOrder
    totalLikeScroe?: SortOrder
    isUnspecified?: SortOrder
  }

  export type RequestPostAvgOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    totalViews?: SortOrder
    totalQuantity?: SortOrder
    totalLikeScroe?: SortOrder
  }

  export type RequestPostMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    category?: SortOrder
    creatorId?: SortOrder
    expires?: SortOrder
    totalViews?: SortOrder
    status?: SortOrder
    solvedUrl?: SortOrder
    thumbnailUrl?: SortOrder
    refusalReason?: SortOrder
    totalQuantity?: SortOrder
    totalLikeScroe?: SortOrder
    isUnspecified?: SortOrder
  }

  export type RequestPostMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    category?: SortOrder
    creatorId?: SortOrder
    expires?: SortOrder
    totalViews?: SortOrder
    status?: SortOrder
    solvedUrl?: SortOrder
    thumbnailUrl?: SortOrder
    refusalReason?: SortOrder
    totalQuantity?: SortOrder
    totalLikeScroe?: SortOrder
    isUnspecified?: SortOrder
  }

  export type RequestPostSumOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    totalViews?: SortOrder
    totalQuantity?: SortOrder
    totalLikeScroe?: SortOrder
  }

  export type BigIntWithAggregatesFilter = {
    equals?: bigint | number
    in?: Enumerable<bigint> | Enumerable<number>
    notIn?: Enumerable<bigint> | Enumerable<number>
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntWithAggregatesFilter | bigint | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedBigIntFilter
    _min?: NestedBigIntFilter
    _max?: NestedBigIntFilter
  }

  export type EnumRequestCategoryTypeNullableWithAggregatesFilter = {
    equals?: RequestCategoryType | null
    in?: Enumerable<RequestCategoryType> | null
    notIn?: Enumerable<RequestCategoryType> | null
    not?: NestedEnumRequestCategoryTypeNullableWithAggregatesFilter | RequestCategoryType | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumRequestCategoryTypeNullableFilter
    _max?: NestedEnumRequestCategoryTypeNullableFilter
  }

  export type BigIntNullableWithAggregatesFilter = {
    equals?: bigint | number | null
    in?: Enumerable<bigint> | Enumerable<number> | null
    notIn?: Enumerable<bigint> | Enumerable<number> | null
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntNullableWithAggregatesFilter | bigint | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedBigIntNullableFilter
    _min?: NestedBigIntNullableFilter
    _max?: NestedBigIntNullableFilter
  }

  export type EnumRequestStatusTypeWithAggregatesFilter = {
    equals?: RequestStatusType
    in?: Enumerable<RequestStatusType>
    notIn?: Enumerable<RequestStatusType>
    not?: NestedEnumRequestStatusTypeWithAggregatesFilter | RequestStatusType
    _count?: NestedIntFilter
    _min?: NestedEnumRequestStatusTypeFilter
    _max?: NestedEnumRequestStatusTypeFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type RequestPostRelationFilter = {
    is?: RequestPostWhereInput
    isNot?: RequestPostWhereInput
  }

  export type EnumRequestFundingStatusFilter = {
    equals?: RequestFundingStatus
    in?: Enumerable<RequestFundingStatus>
    notIn?: Enumerable<RequestFundingStatus>
    not?: NestedEnumRequestFundingStatusFilter | RequestFundingStatus
  }

  export type RequestFundingOrderByRelevanceInput = {
    fields: Enumerable<RequestFundingOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type RequestFundingCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    quantity?: SortOrder
    requestId?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
  }

  export type RequestFundingAvgOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    requestId?: SortOrder
  }

  export type RequestFundingMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    quantity?: SortOrder
    requestId?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
  }

  export type RequestFundingMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    quantity?: SortOrder
    requestId?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
  }

  export type RequestFundingSumOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    requestId?: SortOrder
  }

  export type EnumRequestFundingStatusWithAggregatesFilter = {
    equals?: RequestFundingStatus
    in?: Enumerable<RequestFundingStatus>
    notIn?: Enumerable<RequestFundingStatus>
    not?: NestedEnumRequestFundingStatusWithAggregatesFilter | RequestFundingStatus
    _count?: NestedIntFilter
    _min?: NestedEnumRequestFundingStatusFilter
    _max?: NestedEnumRequestFundingStatusFilter
  }

  export type EnumReactionTypeFilter = {
    equals?: ReactionType
    in?: Enumerable<ReactionType>
    notIn?: Enumerable<ReactionType>
    not?: NestedEnumReactionTypeFilter | ReactionType
  }

  export type RequestReactionOrderByRelevanceInput = {
    fields: Enumerable<RequestReactionOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type RequestReactionUserIdRequestIdCompoundUniqueInput = {
    userId: string
    requestId: bigint | number
  }

  export type RequestReactionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    requestId?: SortOrder
    createdAt?: SortOrder
  }

  export type RequestReactionAvgOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
  }

  export type RequestReactionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    requestId?: SortOrder
    createdAt?: SortOrder
  }

  export type RequestReactionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    requestId?: SortOrder
    createdAt?: SortOrder
  }

  export type RequestReactionSumOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
  }

  export type EnumReactionTypeWithAggregatesFilter = {
    equals?: ReactionType
    in?: Enumerable<ReactionType>
    notIn?: Enumerable<ReactionType>
    not?: NestedEnumReactionTypeWithAggregatesFilter | ReactionType
    _count?: NestedIntFilter
    _min?: NestedEnumReactionTypeFilter
    _max?: NestedEnumReactionTypeFilter
  }

  export type RequestCommentRelationFilter = {
    is?: RequestCommentWhereInput | null
    isNot?: RequestCommentWhereInput | null
  }

  export type RequestCommentOrderByRelevanceInput = {
    fields: Enumerable<RequestCommentOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type RequestCommentCountOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    userId?: SortOrder
    parentId?: SortOrder
    rootId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RequestCommentAvgOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    parentId?: SortOrder
    rootId?: SortOrder
  }

  export type RequestCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    userId?: SortOrder
    parentId?: SortOrder
    rootId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RequestCommentMinOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    userId?: SortOrder
    parentId?: SortOrder
    rootId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RequestCommentSumOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    parentId?: SortOrder
    rootId?: SortOrder
  }

  export type RequestCommentHeartOrderByRelevanceInput = {
    fields: Enumerable<RequestCommentHeartOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type RequestCommentHeartRequestCommentIdUserIdCompoundUniqueInput = {
    requestCommentId: bigint | number
    userId: string
  }

  export type RequestCommentHeartCountOrderByAggregateInput = {
    id?: SortOrder
    requestCommentId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type RequestCommentHeartAvgOrderByAggregateInput = {
    id?: SortOrder
    requestCommentId?: SortOrder
  }

  export type RequestCommentHeartMaxOrderByAggregateInput = {
    id?: SortOrder
    requestCommentId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type RequestCommentHeartMinOrderByAggregateInput = {
    id?: SortOrder
    requestCommentId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type RequestCommentHeartSumOrderByAggregateInput = {
    id?: SortOrder
    requestCommentId?: SortOrder
  }

  export type RequestBookmarkOrderByRelevanceInput = {
    fields: Enumerable<RequestBookmarkOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type RequestBookmarkCountOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type RequestBookmarkAvgOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
  }

  export type RequestBookmarkMaxOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type RequestBookmarkMinOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type RequestBookmarkSumOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
  }

  export type EnumRequestPlatformTypeFilter = {
    equals?: RequestPlatformType
    in?: Enumerable<RequestPlatformType>
    notIn?: Enumerable<RequestPlatformType>
    not?: NestedEnumRequestPlatformTypeFilter | RequestPlatformType
  }

  export type RequestPlatformCountOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    name?: SortOrder
  }

  export type RequestPlatformAvgOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
  }

  export type RequestPlatformMaxOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    name?: SortOrder
  }

  export type RequestPlatformMinOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    name?: SortOrder
  }

  export type RequestPlatformSumOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
  }

  export type EnumRequestPlatformTypeWithAggregatesFilter = {
    equals?: RequestPlatformType
    in?: Enumerable<RequestPlatformType>
    notIn?: Enumerable<RequestPlatformType>
    not?: NestedEnumRequestPlatformTypeWithAggregatesFilter | RequestPlatformType
    _count?: NestedIntFilter
    _min?: NestedEnumRequestPlatformTypeFilter
    _max?: NestedEnumRequestPlatformTypeFilter
  }

  export type RequestApplyCreatorCountOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    creatorId?: SortOrder
  }

  export type RequestApplyCreatorAvgOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    creatorId?: SortOrder
  }

  export type RequestApplyCreatorMaxOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    creatorId?: SortOrder
  }

  export type RequestApplyCreatorMinOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    creatorId?: SortOrder
  }

  export type RequestApplyCreatorSumOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    creatorId?: SortOrder
  }

  export type EnumRequestReportTypeFilter = {
    equals?: RequestReportType
    in?: Enumerable<RequestReportType>
    notIn?: Enumerable<RequestReportType>
    not?: NestedEnumRequestReportTypeFilter | RequestReportType
  }

  export type EnumRequestReportStatusFilter = {
    equals?: RequestReportStatus
    in?: Enumerable<RequestReportStatus>
    notIn?: Enumerable<RequestReportStatus>
    not?: NestedEnumRequestReportStatusFilter | RequestReportStatus
  }

  export type RequestReportOrderByRelevanceInput = {
    fields: Enumerable<RequestReportOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type RequestReportCountOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type RequestReportAvgOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
  }

  export type RequestReportMaxOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type RequestReportMinOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type RequestReportSumOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
  }

  export type EnumRequestReportTypeWithAggregatesFilter = {
    equals?: RequestReportType
    in?: Enumerable<RequestReportType>
    notIn?: Enumerable<RequestReportType>
    not?: NestedEnumRequestReportTypeWithAggregatesFilter | RequestReportType
    _count?: NestedIntFilter
    _min?: NestedEnumRequestReportTypeFilter
    _max?: NestedEnumRequestReportTypeFilter
  }

  export type EnumRequestReportStatusWithAggregatesFilter = {
    equals?: RequestReportStatus
    in?: Enumerable<RequestReportStatus>
    notIn?: Enumerable<RequestReportStatus>
    not?: NestedEnumRequestReportStatusWithAggregatesFilter | RequestReportStatus
    _count?: NestedIntFilter
    _min?: NestedEnumRequestReportStatusFilter
    _max?: NestedEnumRequestReportStatusFilter
  }

  export type RequestInquiryOrderByRelevanceInput = {
    fields: Enumerable<RequestInquiryOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type RequestInquiryCountOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    creatorId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type RequestInquiryAvgOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    creatorId?: SortOrder
  }

  export type RequestInquiryMaxOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    creatorId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type RequestInquiryMinOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    creatorId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type RequestInquirySumOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    creatorId?: SortOrder
  }

  export type RequestInquiryRelationFilter = {
    is?: RequestInquiryWhereInput
    isNot?: RequestInquiryWhereInput
  }

  export type EnumMessageTypeFilter = {
    equals?: MessageType
    in?: Enumerable<MessageType>
    notIn?: Enumerable<MessageType>
    not?: NestedEnumMessageTypeFilter | MessageType
  }

  export type BoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type RequestInquiryMessageOrderByRelevanceInput = {
    fields: Enumerable<RequestInquiryMessageOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type RequestInquiryMessageCountOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    fromId?: SortOrder
    text?: SortOrder
    fileUrl?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type RequestInquiryMessageAvgOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
  }

  export type RequestInquiryMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    fromId?: SortOrder
    text?: SortOrder
    fileUrl?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type RequestInquiryMessageMinOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    fromId?: SortOrder
    text?: SortOrder
    fileUrl?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type RequestInquiryMessageSumOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
  }

  export type EnumMessageTypeWithAggregatesFilter = {
    equals?: MessageType
    in?: Enumerable<MessageType>
    notIn?: Enumerable<MessageType>
    not?: NestedEnumMessageTypeWithAggregatesFilter | MessageType
    _count?: NestedIntFilter
    _min?: NestedEnumMessageTypeFilter
    _max?: NestedEnumMessageTypeFilter
  }

  export type BoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type EnumPoinTypeFilter = {
    equals?: PoinType
    in?: Enumerable<PoinType>
    notIn?: Enumerable<PoinType>
    not?: NestedEnumPoinTypeFilter | PoinType
  }

  export type PointOrderByRelevanceInput = {
    fields: Enumerable<PointOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type PointCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    quantity?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type PointAvgOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
  }

  export type PointMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    quantity?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type PointMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    quantity?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type PointSumOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
  }

  export type EnumPoinTypeWithAggregatesFilter = {
    equals?: PoinType
    in?: Enumerable<PoinType>
    notIn?: Enumerable<PoinType>
    not?: NestedEnumPoinTypeWithAggregatesFilter | PoinType
    _count?: NestedIntFilter
    _min?: NestedEnumPoinTypeFilter
    _max?: NestedEnumPoinTypeFilter
  }

  export type EnumRankingTypeFilter = {
    equals?: RankingType
    in?: Enumerable<RankingType>
    notIn?: Enumerable<RankingType>
    not?: NestedEnumRankingTypeFilter | RankingType
  }

  export type RankingOrderByRelevanceInput = {
    fields: Enumerable<RankingOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type RankingCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    ranking?: SortOrder
    type?: SortOrder
    score?: SortOrder
    change?: SortOrder
    createdAt?: SortOrder
  }

  export type RankingAvgOrderByAggregateInput = {
    id?: SortOrder
    ranking?: SortOrder
    score?: SortOrder
    change?: SortOrder
  }

  export type RankingMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    ranking?: SortOrder
    type?: SortOrder
    score?: SortOrder
    change?: SortOrder
    createdAt?: SortOrder
  }

  export type RankingMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    ranking?: SortOrder
    type?: SortOrder
    score?: SortOrder
    change?: SortOrder
    createdAt?: SortOrder
  }

  export type RankingSumOrderByAggregateInput = {
    id?: SortOrder
    ranking?: SortOrder
    score?: SortOrder
    change?: SortOrder
  }

  export type EnumRankingTypeWithAggregatesFilter = {
    equals?: RankingType
    in?: Enumerable<RankingType>
    notIn?: Enumerable<RankingType>
    not?: NestedEnumRankingTypeWithAggregatesFilter | RankingType
    _count?: NestedIntFilter
    _min?: NestedEnumRankingTypeFilter
    _max?: NestedEnumRankingTypeFilter
  }

  export type EnumFaqTypeFilter = {
    equals?: FaqType
    in?: Enumerable<FaqType>
    notIn?: Enumerable<FaqType>
    not?: NestedEnumFaqTypeFilter | FaqType
  }

  export type FaqOrderByRelevanceInput = {
    fields: Enumerable<FaqOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type FaqCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type FaqAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FaqMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type FaqMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type FaqSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumFaqTypeWithAggregatesFilter = {
    equals?: FaqType
    in?: Enumerable<FaqType>
    notIn?: Enumerable<FaqType>
    not?: NestedEnumFaqTypeWithAggregatesFilter | FaqType
    _count?: NestedIntFilter
    _min?: NestedEnumFaqTypeFilter
    _max?: NestedEnumFaqTypeFilter
  }

  export type NoticeOrderByRelevanceInput = {
    fields: Enumerable<NoticeOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type NoticeCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type NoticeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type NoticeMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type NoticeMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type NoticeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CreatorAuthListRelationFilter = {
    every?: CreatorAuthWhereInput
    some?: CreatorAuthWhereInput
    none?: CreatorAuthWhereInput
  }

  export type CreatorAuthOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CreatorOrderByRelevanceInput = {
    fields: Enumerable<CreatorOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type CreatorCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type CreatorAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CreatorMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type CreatorMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type CreatorSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumAuthPlatformTypeFilter = {
    equals?: AuthPlatformType
    in?: Enumerable<AuthPlatformType>
    notIn?: Enumerable<AuthPlatformType>
    not?: NestedEnumAuthPlatformTypeFilter | AuthPlatformType
  }

  export type CreatorAuthOrderByRelevanceInput = {
    fields: Enumerable<CreatorAuthOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type CreatorAuthCountOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    isMain?: SortOrder
    profileUrl?: SortOrder
    platform?: SortOrder
    createdAt?: SortOrder
  }

  export type CreatorAuthAvgOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
  }

  export type CreatorAuthMaxOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    isMain?: SortOrder
    profileUrl?: SortOrder
    platform?: SortOrder
    createdAt?: SortOrder
  }

  export type CreatorAuthMinOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    isMain?: SortOrder
    profileUrl?: SortOrder
    platform?: SortOrder
    createdAt?: SortOrder
  }

  export type CreatorAuthSumOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
  }

  export type EnumAuthPlatformTypeWithAggregatesFilter = {
    equals?: AuthPlatformType
    in?: Enumerable<AuthPlatformType>
    notIn?: Enumerable<AuthPlatformType>
    not?: NestedEnumAuthPlatformTypeWithAggregatesFilter | AuthPlatformType
    _count?: NestedIntFilter
    _min?: NestedEnumAuthPlatformTypeFilter
    _max?: NestedEnumAuthPlatformTypeFilter
  }

  export type CreatorReviewItemListRelationFilter = {
    every?: CreatorReviewItemWhereInput
    some?: CreatorReviewItemWhereInput
    none?: CreatorReviewItemWhereInput
  }

  export type CreatorReviewItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CreatorReviewOrderByRelevanceInput = {
    fields: Enumerable<CreatorReviewOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type CreatorReviewCountOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type CreatorReviewAvgOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
  }

  export type CreatorReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type CreatorReviewMinOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type CreatorReviewSumOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
  }

  export type CreatorReviewRelationFilter = {
    is?: CreatorReviewWhereInput
    isNot?: CreatorReviewWhereInput
  }

  export type CreatorReviewItemOrderByRelevanceInput = {
    fields: Enumerable<CreatorReviewItemOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type CreatorReviewItemCountOrderByAggregateInput = {
    id?: SortOrder
    reviewId?: SortOrder
    content?: SortOrder
    isChecked?: SortOrder
  }

  export type CreatorReviewItemAvgOrderByAggregateInput = {
    id?: SortOrder
    reviewId?: SortOrder
  }

  export type CreatorReviewItemMaxOrderByAggregateInput = {
    id?: SortOrder
    reviewId?: SortOrder
    content?: SortOrder
    isChecked?: SortOrder
  }

  export type CreatorReviewItemMinOrderByAggregateInput = {
    id?: SortOrder
    reviewId?: SortOrder
    content?: SortOrder
    isChecked?: SortOrder
  }

  export type CreatorReviewItemSumOrderByAggregateInput = {
    id?: SortOrder
    reviewId?: SortOrder
  }

  export type EnumLogTypeFilter = {
    equals?: LogType
    in?: Enumerable<LogType>
    notIn?: Enumerable<LogType>
    not?: NestedEnumLogTypeFilter | LogType
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LogOrderByRelevanceInput = {
    fields: Enumerable<LogOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type LogCountOrderByAggregateInput = {
    id?: SortOrder
    logType?: SortOrder
    message?: SortOrder
    senderId?: SortOrder
    isRead?: SortOrder
    requestId?: SortOrder
    createdAt?: SortOrder
  }

  export type LogAvgOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
  }

  export type LogMaxOrderByAggregateInput = {
    id?: SortOrder
    logType?: SortOrder
    message?: SortOrder
    senderId?: SortOrder
    isRead?: SortOrder
    requestId?: SortOrder
    createdAt?: SortOrder
  }

  export type LogMinOrderByAggregateInput = {
    id?: SortOrder
    logType?: SortOrder
    message?: SortOrder
    senderId?: SortOrder
    isRead?: SortOrder
    requestId?: SortOrder
    createdAt?: SortOrder
  }

  export type LogSumOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
  }

  export type EnumLogTypeWithAggregatesFilter = {
    equals?: LogType
    in?: Enumerable<LogType>
    notIn?: Enumerable<LogType>
    not?: NestedEnumLogTypeWithAggregatesFilter | LogType
    _count?: NestedIntFilter
    _min?: NestedEnumLogTypeFilter
    _max?: NestedEnumLogTypeFilter
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AccountCreateWithoutUserInput>, Enumerable<AccountUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AccountCreateOrConnectWithoutUserInput>
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: Enumerable<AccountWhereUniqueInput>
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<SessionCreateWithoutUserInput>, Enumerable<SessionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SessionCreateOrConnectWithoutUserInput>
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: Enumerable<SessionWhereUniqueInput>
  }

  export type RequestPostCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<RequestPostCreateWithoutUserInput>, Enumerable<RequestPostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RequestPostCreateOrConnectWithoutUserInput>
    createMany?: RequestPostCreateManyUserInputEnvelope
    connect?: Enumerable<RequestPostWhereUniqueInput>
  }

  export type RequestFundingCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<RequestFundingCreateWithoutUserInput>, Enumerable<RequestFundingUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RequestFundingCreateOrConnectWithoutUserInput>
    createMany?: RequestFundingCreateManyUserInputEnvelope
    connect?: Enumerable<RequestFundingWhereUniqueInput>
  }

  export type RequestCommentCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<RequestCommentCreateWithoutUserInput>, Enumerable<RequestCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RequestCommentCreateOrConnectWithoutUserInput>
    createMany?: RequestCommentCreateManyUserInputEnvelope
    connect?: Enumerable<RequestCommentWhereUniqueInput>
  }

  export type RequestReactionCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<RequestReactionCreateWithoutUserInput>, Enumerable<RequestReactionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RequestReactionCreateOrConnectWithoutUserInput>
    createMany?: RequestReactionCreateManyUserInputEnvelope
    connect?: Enumerable<RequestReactionWhereUniqueInput>
  }

  export type RequestBookmarkCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<RequestBookmarkCreateWithoutUserInput>, Enumerable<RequestBookmarkUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RequestBookmarkCreateOrConnectWithoutUserInput>
    createMany?: RequestBookmarkCreateManyUserInputEnvelope
    connect?: Enumerable<RequestBookmarkWhereUniqueInput>
  }

  export type RequestReportCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<RequestReportCreateWithoutUserInput>, Enumerable<RequestReportUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RequestReportCreateOrConnectWithoutUserInput>
    createMany?: RequestReportCreateManyUserInputEnvelope
    connect?: Enumerable<RequestReportWhereUniqueInput>
  }

  export type RequestInquiryCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<RequestInquiryCreateWithoutUserInput>, Enumerable<RequestInquiryUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RequestInquiryCreateOrConnectWithoutUserInput>
    createMany?: RequestInquiryCreateManyUserInputEnvelope
    connect?: Enumerable<RequestInquiryWhereUniqueInput>
  }

  export type RequestInquiryMessageCreateNestedManyWithoutFromInput = {
    create?: XOR<Enumerable<RequestInquiryMessageCreateWithoutFromInput>, Enumerable<RequestInquiryMessageUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<RequestInquiryMessageCreateOrConnectWithoutFromInput>
    createMany?: RequestInquiryMessageCreateManyFromInputEnvelope
    connect?: Enumerable<RequestInquiryMessageWhereUniqueInput>
  }

  export type RequestCommentHeartCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<RequestCommentHeartCreateWithoutUserInput>, Enumerable<RequestCommentHeartUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RequestCommentHeartCreateOrConnectWithoutUserInput>
    createMany?: RequestCommentHeartCreateManyUserInputEnvelope
    connect?: Enumerable<RequestCommentHeartWhereUniqueInput>
  }

  export type LogCreateNestedManyWithoutReceiverInput = {
    create?: XOR<Enumerable<LogCreateWithoutReceiverInput>, Enumerable<LogUncheckedCreateWithoutReceiverInput>>
    connectOrCreate?: Enumerable<LogCreateOrConnectWithoutReceiverInput>
    connect?: Enumerable<LogWhereUniqueInput>
  }

  export type PointCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<PointCreateWithoutUserInput>, Enumerable<PointUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PointCreateOrConnectWithoutUserInput>
    createMany?: PointCreateManyUserInputEnvelope
    connect?: Enumerable<PointWhereUniqueInput>
  }

  export type RankingCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<RankingCreateWithoutUserInput>, Enumerable<RankingUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RankingCreateOrConnectWithoutUserInput>
    createMany?: RankingCreateManyUserInputEnvelope
    connect?: Enumerable<RankingWhereUniqueInput>
  }

  export type CreatorReviewCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CreatorReviewCreateWithoutUserInput>, Enumerable<CreatorReviewUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CreatorReviewCreateOrConnectWithoutUserInput>
    createMany?: CreatorReviewCreateManyUserInputEnvelope
    connect?: Enumerable<CreatorReviewWhereUniqueInput>
  }

  export type CreatorCreateNestedOneWithoutUserInput = {
    create?: XOR<CreatorCreateWithoutUserInput, CreatorUncheckedCreateWithoutUserInput>
    connectOrCreate?: CreatorCreateOrConnectWithoutUserInput
    connect?: CreatorWhereUniqueInput
  }

  export type LogCreateNestedManyWithoutSenderInput = {
    create?: XOR<Enumerable<LogCreateWithoutSenderInput>, Enumerable<LogUncheckedCreateWithoutSenderInput>>
    connectOrCreate?: Enumerable<LogCreateOrConnectWithoutSenderInput>
    createMany?: LogCreateManySenderInputEnvelope
    connect?: Enumerable<LogWhereUniqueInput>
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AccountCreateWithoutUserInput>, Enumerable<AccountUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AccountCreateOrConnectWithoutUserInput>
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: Enumerable<AccountWhereUniqueInput>
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<SessionCreateWithoutUserInput>, Enumerable<SessionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SessionCreateOrConnectWithoutUserInput>
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: Enumerable<SessionWhereUniqueInput>
  }

  export type RequestPostUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<RequestPostCreateWithoutUserInput>, Enumerable<RequestPostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RequestPostCreateOrConnectWithoutUserInput>
    createMany?: RequestPostCreateManyUserInputEnvelope
    connect?: Enumerable<RequestPostWhereUniqueInput>
  }

  export type RequestFundingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<RequestFundingCreateWithoutUserInput>, Enumerable<RequestFundingUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RequestFundingCreateOrConnectWithoutUserInput>
    createMany?: RequestFundingCreateManyUserInputEnvelope
    connect?: Enumerable<RequestFundingWhereUniqueInput>
  }

  export type RequestCommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<RequestCommentCreateWithoutUserInput>, Enumerable<RequestCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RequestCommentCreateOrConnectWithoutUserInput>
    createMany?: RequestCommentCreateManyUserInputEnvelope
    connect?: Enumerable<RequestCommentWhereUniqueInput>
  }

  export type RequestReactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<RequestReactionCreateWithoutUserInput>, Enumerable<RequestReactionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RequestReactionCreateOrConnectWithoutUserInput>
    createMany?: RequestReactionCreateManyUserInputEnvelope
    connect?: Enumerable<RequestReactionWhereUniqueInput>
  }

  export type RequestBookmarkUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<RequestBookmarkCreateWithoutUserInput>, Enumerable<RequestBookmarkUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RequestBookmarkCreateOrConnectWithoutUserInput>
    createMany?: RequestBookmarkCreateManyUserInputEnvelope
    connect?: Enumerable<RequestBookmarkWhereUniqueInput>
  }

  export type RequestReportUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<RequestReportCreateWithoutUserInput>, Enumerable<RequestReportUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RequestReportCreateOrConnectWithoutUserInput>
    createMany?: RequestReportCreateManyUserInputEnvelope
    connect?: Enumerable<RequestReportWhereUniqueInput>
  }

  export type RequestInquiryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<RequestInquiryCreateWithoutUserInput>, Enumerable<RequestInquiryUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RequestInquiryCreateOrConnectWithoutUserInput>
    createMany?: RequestInquiryCreateManyUserInputEnvelope
    connect?: Enumerable<RequestInquiryWhereUniqueInput>
  }

  export type RequestInquiryMessageUncheckedCreateNestedManyWithoutFromInput = {
    create?: XOR<Enumerable<RequestInquiryMessageCreateWithoutFromInput>, Enumerable<RequestInquiryMessageUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<RequestInquiryMessageCreateOrConnectWithoutFromInput>
    createMany?: RequestInquiryMessageCreateManyFromInputEnvelope
    connect?: Enumerable<RequestInquiryMessageWhereUniqueInput>
  }

  export type RequestCommentHeartUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<RequestCommentHeartCreateWithoutUserInput>, Enumerable<RequestCommentHeartUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RequestCommentHeartCreateOrConnectWithoutUserInput>
    createMany?: RequestCommentHeartCreateManyUserInputEnvelope
    connect?: Enumerable<RequestCommentHeartWhereUniqueInput>
  }

  export type LogUncheckedCreateNestedManyWithoutReceiverInput = {
    create?: XOR<Enumerable<LogCreateWithoutReceiverInput>, Enumerable<LogUncheckedCreateWithoutReceiverInput>>
    connectOrCreate?: Enumerable<LogCreateOrConnectWithoutReceiverInput>
    connect?: Enumerable<LogWhereUniqueInput>
  }

  export type PointUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<PointCreateWithoutUserInput>, Enumerable<PointUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PointCreateOrConnectWithoutUserInput>
    createMany?: PointCreateManyUserInputEnvelope
    connect?: Enumerable<PointWhereUniqueInput>
  }

  export type RankingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<RankingCreateWithoutUserInput>, Enumerable<RankingUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RankingCreateOrConnectWithoutUserInput>
    createMany?: RankingCreateManyUserInputEnvelope
    connect?: Enumerable<RankingWhereUniqueInput>
  }

  export type CreatorReviewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CreatorReviewCreateWithoutUserInput>, Enumerable<CreatorReviewUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CreatorReviewCreateOrConnectWithoutUserInput>
    createMany?: CreatorReviewCreateManyUserInputEnvelope
    connect?: Enumerable<CreatorReviewWhereUniqueInput>
  }

  export type CreatorUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<CreatorCreateWithoutUserInput, CreatorUncheckedCreateWithoutUserInput>
    connectOrCreate?: CreatorCreateOrConnectWithoutUserInput
    connect?: CreatorWhereUniqueInput
  }

  export type LogUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<Enumerable<LogCreateWithoutSenderInput>, Enumerable<LogUncheckedCreateWithoutSenderInput>>
    connectOrCreate?: Enumerable<LogCreateOrConnectWithoutSenderInput>
    createMany?: LogCreateManySenderInputEnvelope
    connect?: Enumerable<LogWhereUniqueInput>
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<AccountCreateWithoutUserInput>, Enumerable<AccountUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AccountCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AccountUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AccountCreateManyUserInputEnvelope
    set?: Enumerable<AccountWhereUniqueInput>
    disconnect?: Enumerable<AccountWhereUniqueInput>
    delete?: Enumerable<AccountWhereUniqueInput>
    connect?: Enumerable<AccountWhereUniqueInput>
    update?: Enumerable<AccountUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AccountUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AccountScalarWhereInput>
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<SessionCreateWithoutUserInput>, Enumerable<SessionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SessionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<SessionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: SessionCreateManyUserInputEnvelope
    set?: Enumerable<SessionWhereUniqueInput>
    disconnect?: Enumerable<SessionWhereUniqueInput>
    delete?: Enumerable<SessionWhereUniqueInput>
    connect?: Enumerable<SessionWhereUniqueInput>
    update?: Enumerable<SessionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<SessionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<SessionScalarWhereInput>
  }

  export type RequestPostUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<RequestPostCreateWithoutUserInput>, Enumerable<RequestPostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RequestPostCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<RequestPostUpsertWithWhereUniqueWithoutUserInput>
    createMany?: RequestPostCreateManyUserInputEnvelope
    set?: Enumerable<RequestPostWhereUniqueInput>
    disconnect?: Enumerable<RequestPostWhereUniqueInput>
    delete?: Enumerable<RequestPostWhereUniqueInput>
    connect?: Enumerable<RequestPostWhereUniqueInput>
    update?: Enumerable<RequestPostUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<RequestPostUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<RequestPostScalarWhereInput>
  }

  export type RequestFundingUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<RequestFundingCreateWithoutUserInput>, Enumerable<RequestFundingUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RequestFundingCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<RequestFundingUpsertWithWhereUniqueWithoutUserInput>
    createMany?: RequestFundingCreateManyUserInputEnvelope
    set?: Enumerable<RequestFundingWhereUniqueInput>
    disconnect?: Enumerable<RequestFundingWhereUniqueInput>
    delete?: Enumerable<RequestFundingWhereUniqueInput>
    connect?: Enumerable<RequestFundingWhereUniqueInput>
    update?: Enumerable<RequestFundingUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<RequestFundingUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<RequestFundingScalarWhereInput>
  }

  export type RequestCommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<RequestCommentCreateWithoutUserInput>, Enumerable<RequestCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RequestCommentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<RequestCommentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: RequestCommentCreateManyUserInputEnvelope
    set?: Enumerable<RequestCommentWhereUniqueInput>
    disconnect?: Enumerable<RequestCommentWhereUniqueInput>
    delete?: Enumerable<RequestCommentWhereUniqueInput>
    connect?: Enumerable<RequestCommentWhereUniqueInput>
    update?: Enumerable<RequestCommentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<RequestCommentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<RequestCommentScalarWhereInput>
  }

  export type RequestReactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<RequestReactionCreateWithoutUserInput>, Enumerable<RequestReactionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RequestReactionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<RequestReactionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: RequestReactionCreateManyUserInputEnvelope
    set?: Enumerable<RequestReactionWhereUniqueInput>
    disconnect?: Enumerable<RequestReactionWhereUniqueInput>
    delete?: Enumerable<RequestReactionWhereUniqueInput>
    connect?: Enumerable<RequestReactionWhereUniqueInput>
    update?: Enumerable<RequestReactionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<RequestReactionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<RequestReactionScalarWhereInput>
  }

  export type RequestBookmarkUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<RequestBookmarkCreateWithoutUserInput>, Enumerable<RequestBookmarkUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RequestBookmarkCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<RequestBookmarkUpsertWithWhereUniqueWithoutUserInput>
    createMany?: RequestBookmarkCreateManyUserInputEnvelope
    set?: Enumerable<RequestBookmarkWhereUniqueInput>
    disconnect?: Enumerable<RequestBookmarkWhereUniqueInput>
    delete?: Enumerable<RequestBookmarkWhereUniqueInput>
    connect?: Enumerable<RequestBookmarkWhereUniqueInput>
    update?: Enumerable<RequestBookmarkUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<RequestBookmarkUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<RequestBookmarkScalarWhereInput>
  }

  export type RequestReportUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<RequestReportCreateWithoutUserInput>, Enumerable<RequestReportUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RequestReportCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<RequestReportUpsertWithWhereUniqueWithoutUserInput>
    createMany?: RequestReportCreateManyUserInputEnvelope
    set?: Enumerable<RequestReportWhereUniqueInput>
    disconnect?: Enumerable<RequestReportWhereUniqueInput>
    delete?: Enumerable<RequestReportWhereUniqueInput>
    connect?: Enumerable<RequestReportWhereUniqueInput>
    update?: Enumerable<RequestReportUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<RequestReportUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<RequestReportScalarWhereInput>
  }

  export type RequestInquiryUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<RequestInquiryCreateWithoutUserInput>, Enumerable<RequestInquiryUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RequestInquiryCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<RequestInquiryUpsertWithWhereUniqueWithoutUserInput>
    createMany?: RequestInquiryCreateManyUserInputEnvelope
    set?: Enumerable<RequestInquiryWhereUniqueInput>
    disconnect?: Enumerable<RequestInquiryWhereUniqueInput>
    delete?: Enumerable<RequestInquiryWhereUniqueInput>
    connect?: Enumerable<RequestInquiryWhereUniqueInput>
    update?: Enumerable<RequestInquiryUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<RequestInquiryUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<RequestInquiryScalarWhereInput>
  }

  export type RequestInquiryMessageUpdateManyWithoutFromNestedInput = {
    create?: XOR<Enumerable<RequestInquiryMessageCreateWithoutFromInput>, Enumerable<RequestInquiryMessageUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<RequestInquiryMessageCreateOrConnectWithoutFromInput>
    upsert?: Enumerable<RequestInquiryMessageUpsertWithWhereUniqueWithoutFromInput>
    createMany?: RequestInquiryMessageCreateManyFromInputEnvelope
    set?: Enumerable<RequestInquiryMessageWhereUniqueInput>
    disconnect?: Enumerable<RequestInquiryMessageWhereUniqueInput>
    delete?: Enumerable<RequestInquiryMessageWhereUniqueInput>
    connect?: Enumerable<RequestInquiryMessageWhereUniqueInput>
    update?: Enumerable<RequestInquiryMessageUpdateWithWhereUniqueWithoutFromInput>
    updateMany?: Enumerable<RequestInquiryMessageUpdateManyWithWhereWithoutFromInput>
    deleteMany?: Enumerable<RequestInquiryMessageScalarWhereInput>
  }

  export type RequestCommentHeartUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<RequestCommentHeartCreateWithoutUserInput>, Enumerable<RequestCommentHeartUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RequestCommentHeartCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<RequestCommentHeartUpsertWithWhereUniqueWithoutUserInput>
    createMany?: RequestCommentHeartCreateManyUserInputEnvelope
    set?: Enumerable<RequestCommentHeartWhereUniqueInput>
    disconnect?: Enumerable<RequestCommentHeartWhereUniqueInput>
    delete?: Enumerable<RequestCommentHeartWhereUniqueInput>
    connect?: Enumerable<RequestCommentHeartWhereUniqueInput>
    update?: Enumerable<RequestCommentHeartUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<RequestCommentHeartUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<RequestCommentHeartScalarWhereInput>
  }

  export type LogUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<Enumerable<LogCreateWithoutReceiverInput>, Enumerable<LogUncheckedCreateWithoutReceiverInput>>
    connectOrCreate?: Enumerable<LogCreateOrConnectWithoutReceiverInput>
    upsert?: Enumerable<LogUpsertWithWhereUniqueWithoutReceiverInput>
    set?: Enumerable<LogWhereUniqueInput>
    disconnect?: Enumerable<LogWhereUniqueInput>
    delete?: Enumerable<LogWhereUniqueInput>
    connect?: Enumerable<LogWhereUniqueInput>
    update?: Enumerable<LogUpdateWithWhereUniqueWithoutReceiverInput>
    updateMany?: Enumerable<LogUpdateManyWithWhereWithoutReceiverInput>
    deleteMany?: Enumerable<LogScalarWhereInput>
  }

  export type PointUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<PointCreateWithoutUserInput>, Enumerable<PointUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PointCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<PointUpsertWithWhereUniqueWithoutUserInput>
    createMany?: PointCreateManyUserInputEnvelope
    set?: Enumerable<PointWhereUniqueInput>
    disconnect?: Enumerable<PointWhereUniqueInput>
    delete?: Enumerable<PointWhereUniqueInput>
    connect?: Enumerable<PointWhereUniqueInput>
    update?: Enumerable<PointUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<PointUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<PointScalarWhereInput>
  }

  export type RankingUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<RankingCreateWithoutUserInput>, Enumerable<RankingUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RankingCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<RankingUpsertWithWhereUniqueWithoutUserInput>
    createMany?: RankingCreateManyUserInputEnvelope
    set?: Enumerable<RankingWhereUniqueInput>
    disconnect?: Enumerable<RankingWhereUniqueInput>
    delete?: Enumerable<RankingWhereUniqueInput>
    connect?: Enumerable<RankingWhereUniqueInput>
    update?: Enumerable<RankingUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<RankingUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<RankingScalarWhereInput>
  }

  export type CreatorReviewUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<CreatorReviewCreateWithoutUserInput>, Enumerable<CreatorReviewUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CreatorReviewCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<CreatorReviewUpsertWithWhereUniqueWithoutUserInput>
    createMany?: CreatorReviewCreateManyUserInputEnvelope
    set?: Enumerable<CreatorReviewWhereUniqueInput>
    disconnect?: Enumerable<CreatorReviewWhereUniqueInput>
    delete?: Enumerable<CreatorReviewWhereUniqueInput>
    connect?: Enumerable<CreatorReviewWhereUniqueInput>
    update?: Enumerable<CreatorReviewUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CreatorReviewUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CreatorReviewScalarWhereInput>
  }

  export type CreatorUpdateOneWithoutUserNestedInput = {
    create?: XOR<CreatorCreateWithoutUserInput, CreatorUncheckedCreateWithoutUserInput>
    connectOrCreate?: CreatorCreateOrConnectWithoutUserInput
    upsert?: CreatorUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: CreatorWhereUniqueInput
    update?: XOR<CreatorUpdateWithoutUserInput, CreatorUncheckedUpdateWithoutUserInput>
  }

  export type LogUpdateManyWithoutSenderNestedInput = {
    create?: XOR<Enumerable<LogCreateWithoutSenderInput>, Enumerable<LogUncheckedCreateWithoutSenderInput>>
    connectOrCreate?: Enumerable<LogCreateOrConnectWithoutSenderInput>
    upsert?: Enumerable<LogUpsertWithWhereUniqueWithoutSenderInput>
    createMany?: LogCreateManySenderInputEnvelope
    set?: Enumerable<LogWhereUniqueInput>
    disconnect?: Enumerable<LogWhereUniqueInput>
    delete?: Enumerable<LogWhereUniqueInput>
    connect?: Enumerable<LogWhereUniqueInput>
    update?: Enumerable<LogUpdateWithWhereUniqueWithoutSenderInput>
    updateMany?: Enumerable<LogUpdateManyWithWhereWithoutSenderInput>
    deleteMany?: Enumerable<LogScalarWhereInput>
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<AccountCreateWithoutUserInput>, Enumerable<AccountUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AccountCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AccountUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AccountCreateManyUserInputEnvelope
    set?: Enumerable<AccountWhereUniqueInput>
    disconnect?: Enumerable<AccountWhereUniqueInput>
    delete?: Enumerable<AccountWhereUniqueInput>
    connect?: Enumerable<AccountWhereUniqueInput>
    update?: Enumerable<AccountUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AccountUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AccountScalarWhereInput>
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<SessionCreateWithoutUserInput>, Enumerable<SessionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SessionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<SessionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: SessionCreateManyUserInputEnvelope
    set?: Enumerable<SessionWhereUniqueInput>
    disconnect?: Enumerable<SessionWhereUniqueInput>
    delete?: Enumerable<SessionWhereUniqueInput>
    connect?: Enumerable<SessionWhereUniqueInput>
    update?: Enumerable<SessionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<SessionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<SessionScalarWhereInput>
  }

  export type RequestPostUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<RequestPostCreateWithoutUserInput>, Enumerable<RequestPostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RequestPostCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<RequestPostUpsertWithWhereUniqueWithoutUserInput>
    createMany?: RequestPostCreateManyUserInputEnvelope
    set?: Enumerable<RequestPostWhereUniqueInput>
    disconnect?: Enumerable<RequestPostWhereUniqueInput>
    delete?: Enumerable<RequestPostWhereUniqueInput>
    connect?: Enumerable<RequestPostWhereUniqueInput>
    update?: Enumerable<RequestPostUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<RequestPostUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<RequestPostScalarWhereInput>
  }

  export type RequestFundingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<RequestFundingCreateWithoutUserInput>, Enumerable<RequestFundingUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RequestFundingCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<RequestFundingUpsertWithWhereUniqueWithoutUserInput>
    createMany?: RequestFundingCreateManyUserInputEnvelope
    set?: Enumerable<RequestFundingWhereUniqueInput>
    disconnect?: Enumerable<RequestFundingWhereUniqueInput>
    delete?: Enumerable<RequestFundingWhereUniqueInput>
    connect?: Enumerable<RequestFundingWhereUniqueInput>
    update?: Enumerable<RequestFundingUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<RequestFundingUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<RequestFundingScalarWhereInput>
  }

  export type RequestCommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<RequestCommentCreateWithoutUserInput>, Enumerable<RequestCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RequestCommentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<RequestCommentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: RequestCommentCreateManyUserInputEnvelope
    set?: Enumerable<RequestCommentWhereUniqueInput>
    disconnect?: Enumerable<RequestCommentWhereUniqueInput>
    delete?: Enumerable<RequestCommentWhereUniqueInput>
    connect?: Enumerable<RequestCommentWhereUniqueInput>
    update?: Enumerable<RequestCommentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<RequestCommentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<RequestCommentScalarWhereInput>
  }

  export type RequestReactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<RequestReactionCreateWithoutUserInput>, Enumerable<RequestReactionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RequestReactionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<RequestReactionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: RequestReactionCreateManyUserInputEnvelope
    set?: Enumerable<RequestReactionWhereUniqueInput>
    disconnect?: Enumerable<RequestReactionWhereUniqueInput>
    delete?: Enumerable<RequestReactionWhereUniqueInput>
    connect?: Enumerable<RequestReactionWhereUniqueInput>
    update?: Enumerable<RequestReactionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<RequestReactionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<RequestReactionScalarWhereInput>
  }

  export type RequestBookmarkUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<RequestBookmarkCreateWithoutUserInput>, Enumerable<RequestBookmarkUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RequestBookmarkCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<RequestBookmarkUpsertWithWhereUniqueWithoutUserInput>
    createMany?: RequestBookmarkCreateManyUserInputEnvelope
    set?: Enumerable<RequestBookmarkWhereUniqueInput>
    disconnect?: Enumerable<RequestBookmarkWhereUniqueInput>
    delete?: Enumerable<RequestBookmarkWhereUniqueInput>
    connect?: Enumerable<RequestBookmarkWhereUniqueInput>
    update?: Enumerable<RequestBookmarkUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<RequestBookmarkUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<RequestBookmarkScalarWhereInput>
  }

  export type RequestReportUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<RequestReportCreateWithoutUserInput>, Enumerable<RequestReportUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RequestReportCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<RequestReportUpsertWithWhereUniqueWithoutUserInput>
    createMany?: RequestReportCreateManyUserInputEnvelope
    set?: Enumerable<RequestReportWhereUniqueInput>
    disconnect?: Enumerable<RequestReportWhereUniqueInput>
    delete?: Enumerable<RequestReportWhereUniqueInput>
    connect?: Enumerable<RequestReportWhereUniqueInput>
    update?: Enumerable<RequestReportUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<RequestReportUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<RequestReportScalarWhereInput>
  }

  export type RequestInquiryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<RequestInquiryCreateWithoutUserInput>, Enumerable<RequestInquiryUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RequestInquiryCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<RequestInquiryUpsertWithWhereUniqueWithoutUserInput>
    createMany?: RequestInquiryCreateManyUserInputEnvelope
    set?: Enumerable<RequestInquiryWhereUniqueInput>
    disconnect?: Enumerable<RequestInquiryWhereUniqueInput>
    delete?: Enumerable<RequestInquiryWhereUniqueInput>
    connect?: Enumerable<RequestInquiryWhereUniqueInput>
    update?: Enumerable<RequestInquiryUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<RequestInquiryUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<RequestInquiryScalarWhereInput>
  }

  export type RequestInquiryMessageUncheckedUpdateManyWithoutFromNestedInput = {
    create?: XOR<Enumerable<RequestInquiryMessageCreateWithoutFromInput>, Enumerable<RequestInquiryMessageUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<RequestInquiryMessageCreateOrConnectWithoutFromInput>
    upsert?: Enumerable<RequestInquiryMessageUpsertWithWhereUniqueWithoutFromInput>
    createMany?: RequestInquiryMessageCreateManyFromInputEnvelope
    set?: Enumerable<RequestInquiryMessageWhereUniqueInput>
    disconnect?: Enumerable<RequestInquiryMessageWhereUniqueInput>
    delete?: Enumerable<RequestInquiryMessageWhereUniqueInput>
    connect?: Enumerable<RequestInquiryMessageWhereUniqueInput>
    update?: Enumerable<RequestInquiryMessageUpdateWithWhereUniqueWithoutFromInput>
    updateMany?: Enumerable<RequestInquiryMessageUpdateManyWithWhereWithoutFromInput>
    deleteMany?: Enumerable<RequestInquiryMessageScalarWhereInput>
  }

  export type RequestCommentHeartUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<RequestCommentHeartCreateWithoutUserInput>, Enumerable<RequestCommentHeartUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RequestCommentHeartCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<RequestCommentHeartUpsertWithWhereUniqueWithoutUserInput>
    createMany?: RequestCommentHeartCreateManyUserInputEnvelope
    set?: Enumerable<RequestCommentHeartWhereUniqueInput>
    disconnect?: Enumerable<RequestCommentHeartWhereUniqueInput>
    delete?: Enumerable<RequestCommentHeartWhereUniqueInput>
    connect?: Enumerable<RequestCommentHeartWhereUniqueInput>
    update?: Enumerable<RequestCommentHeartUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<RequestCommentHeartUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<RequestCommentHeartScalarWhereInput>
  }

  export type LogUncheckedUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<Enumerable<LogCreateWithoutReceiverInput>, Enumerable<LogUncheckedCreateWithoutReceiverInput>>
    connectOrCreate?: Enumerable<LogCreateOrConnectWithoutReceiverInput>
    upsert?: Enumerable<LogUpsertWithWhereUniqueWithoutReceiverInput>
    set?: Enumerable<LogWhereUniqueInput>
    disconnect?: Enumerable<LogWhereUniqueInput>
    delete?: Enumerable<LogWhereUniqueInput>
    connect?: Enumerable<LogWhereUniqueInput>
    update?: Enumerable<LogUpdateWithWhereUniqueWithoutReceiverInput>
    updateMany?: Enumerable<LogUpdateManyWithWhereWithoutReceiverInput>
    deleteMany?: Enumerable<LogScalarWhereInput>
  }

  export type PointUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<PointCreateWithoutUserInput>, Enumerable<PointUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PointCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<PointUpsertWithWhereUniqueWithoutUserInput>
    createMany?: PointCreateManyUserInputEnvelope
    set?: Enumerable<PointWhereUniqueInput>
    disconnect?: Enumerable<PointWhereUniqueInput>
    delete?: Enumerable<PointWhereUniqueInput>
    connect?: Enumerable<PointWhereUniqueInput>
    update?: Enumerable<PointUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<PointUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<PointScalarWhereInput>
  }

  export type RankingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<RankingCreateWithoutUserInput>, Enumerable<RankingUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RankingCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<RankingUpsertWithWhereUniqueWithoutUserInput>
    createMany?: RankingCreateManyUserInputEnvelope
    set?: Enumerable<RankingWhereUniqueInput>
    disconnect?: Enumerable<RankingWhereUniqueInput>
    delete?: Enumerable<RankingWhereUniqueInput>
    connect?: Enumerable<RankingWhereUniqueInput>
    update?: Enumerable<RankingUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<RankingUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<RankingScalarWhereInput>
  }

  export type CreatorReviewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<CreatorReviewCreateWithoutUserInput>, Enumerable<CreatorReviewUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CreatorReviewCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<CreatorReviewUpsertWithWhereUniqueWithoutUserInput>
    createMany?: CreatorReviewCreateManyUserInputEnvelope
    set?: Enumerable<CreatorReviewWhereUniqueInput>
    disconnect?: Enumerable<CreatorReviewWhereUniqueInput>
    delete?: Enumerable<CreatorReviewWhereUniqueInput>
    connect?: Enumerable<CreatorReviewWhereUniqueInput>
    update?: Enumerable<CreatorReviewUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CreatorReviewUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CreatorReviewScalarWhereInput>
  }

  export type CreatorUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<CreatorCreateWithoutUserInput, CreatorUncheckedCreateWithoutUserInput>
    connectOrCreate?: CreatorCreateOrConnectWithoutUserInput
    upsert?: CreatorUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: CreatorWhereUniqueInput
    update?: XOR<CreatorUpdateWithoutUserInput, CreatorUncheckedUpdateWithoutUserInput>
  }

  export type LogUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<Enumerable<LogCreateWithoutSenderInput>, Enumerable<LogUncheckedCreateWithoutSenderInput>>
    connectOrCreate?: Enumerable<LogCreateOrConnectWithoutSenderInput>
    upsert?: Enumerable<LogUpsertWithWhereUniqueWithoutSenderInput>
    createMany?: LogCreateManySenderInputEnvelope
    set?: Enumerable<LogWhereUniqueInput>
    disconnect?: Enumerable<LogWhereUniqueInput>
    delete?: Enumerable<LogWhereUniqueInput>
    connect?: Enumerable<LogWhereUniqueInput>
    update?: Enumerable<LogUpdateWithWhereUniqueWithoutSenderInput>
    updateMany?: Enumerable<LogUpdateManyWithWhereWithoutSenderInput>
    deleteMany?: Enumerable<LogScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutRequestPostsInput = {
    create?: XOR<UserCreateWithoutRequestPostsInput, UserUncheckedCreateWithoutRequestPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRequestPostsInput
    connect?: UserWhereUniqueInput
  }

  export type CreatorCreateNestedOneWithoutRequestPostsInput = {
    create?: XOR<CreatorCreateWithoutRequestPostsInput, CreatorUncheckedCreateWithoutRequestPostsInput>
    connectOrCreate?: CreatorCreateOrConnectWithoutRequestPostsInput
    connect?: CreatorWhereUniqueInput
  }

  export type RequestFundingCreateNestedManyWithoutRequestInput = {
    create?: XOR<Enumerable<RequestFundingCreateWithoutRequestInput>, Enumerable<RequestFundingUncheckedCreateWithoutRequestInput>>
    connectOrCreate?: Enumerable<RequestFundingCreateOrConnectWithoutRequestInput>
    createMany?: RequestFundingCreateManyRequestInputEnvelope
    connect?: Enumerable<RequestFundingWhereUniqueInput>
  }

  export type RequestReactionCreateNestedManyWithoutRequestInput = {
    create?: XOR<Enumerable<RequestReactionCreateWithoutRequestInput>, Enumerable<RequestReactionUncheckedCreateWithoutRequestInput>>
    connectOrCreate?: Enumerable<RequestReactionCreateOrConnectWithoutRequestInput>
    createMany?: RequestReactionCreateManyRequestInputEnvelope
    connect?: Enumerable<RequestReactionWhereUniqueInput>
  }

  export type RequestApplyCreatorCreateNestedManyWithoutRequestInput = {
    create?: XOR<Enumerable<RequestApplyCreatorCreateWithoutRequestInput>, Enumerable<RequestApplyCreatorUncheckedCreateWithoutRequestInput>>
    connectOrCreate?: Enumerable<RequestApplyCreatorCreateOrConnectWithoutRequestInput>
    createMany?: RequestApplyCreatorCreateManyRequestInputEnvelope
    connect?: Enumerable<RequestApplyCreatorWhereUniqueInput>
  }

  export type RequestPlatformCreateNestedManyWithoutRequestInput = {
    create?: XOR<Enumerable<RequestPlatformCreateWithoutRequestInput>, Enumerable<RequestPlatformUncheckedCreateWithoutRequestInput>>
    connectOrCreate?: Enumerable<RequestPlatformCreateOrConnectWithoutRequestInput>
    createMany?: RequestPlatformCreateManyRequestInputEnvelope
    connect?: Enumerable<RequestPlatformWhereUniqueInput>
  }

  export type RequestCommentCreateNestedManyWithoutRequestInput = {
    create?: XOR<Enumerable<RequestCommentCreateWithoutRequestInput>, Enumerable<RequestCommentUncheckedCreateWithoutRequestInput>>
    connectOrCreate?: Enumerable<RequestCommentCreateOrConnectWithoutRequestInput>
    createMany?: RequestCommentCreateManyRequestInputEnvelope
    connect?: Enumerable<RequestCommentWhereUniqueInput>
  }

  export type RequestBookmarkCreateNestedManyWithoutRequestInput = {
    create?: XOR<Enumerable<RequestBookmarkCreateWithoutRequestInput>, Enumerable<RequestBookmarkUncheckedCreateWithoutRequestInput>>
    connectOrCreate?: Enumerable<RequestBookmarkCreateOrConnectWithoutRequestInput>
    createMany?: RequestBookmarkCreateManyRequestInputEnvelope
    connect?: Enumerable<RequestBookmarkWhereUniqueInput>
  }

  export type RequestReportCreateNestedManyWithoutRequestInput = {
    create?: XOR<Enumerable<RequestReportCreateWithoutRequestInput>, Enumerable<RequestReportUncheckedCreateWithoutRequestInput>>
    connectOrCreate?: Enumerable<RequestReportCreateOrConnectWithoutRequestInput>
    createMany?: RequestReportCreateManyRequestInputEnvelope
    connect?: Enumerable<RequestReportWhereUniqueInput>
  }

  export type RequestInquiryCreateNestedManyWithoutRequestInput = {
    create?: XOR<Enumerable<RequestInquiryCreateWithoutRequestInput>, Enumerable<RequestInquiryUncheckedCreateWithoutRequestInput>>
    connectOrCreate?: Enumerable<RequestInquiryCreateOrConnectWithoutRequestInput>
    createMany?: RequestInquiryCreateManyRequestInputEnvelope
    connect?: Enumerable<RequestInquiryWhereUniqueInput>
  }

  export type LogCreateNestedManyWithoutRequestInput = {
    create?: XOR<Enumerable<LogCreateWithoutRequestInput>, Enumerable<LogUncheckedCreateWithoutRequestInput>>
    connectOrCreate?: Enumerable<LogCreateOrConnectWithoutRequestInput>
    createMany?: LogCreateManyRequestInputEnvelope
    connect?: Enumerable<LogWhereUniqueInput>
  }

  export type RequestFundingUncheckedCreateNestedManyWithoutRequestInput = {
    create?: XOR<Enumerable<RequestFundingCreateWithoutRequestInput>, Enumerable<RequestFundingUncheckedCreateWithoutRequestInput>>
    connectOrCreate?: Enumerable<RequestFundingCreateOrConnectWithoutRequestInput>
    createMany?: RequestFundingCreateManyRequestInputEnvelope
    connect?: Enumerable<RequestFundingWhereUniqueInput>
  }

  export type RequestReactionUncheckedCreateNestedManyWithoutRequestInput = {
    create?: XOR<Enumerable<RequestReactionCreateWithoutRequestInput>, Enumerable<RequestReactionUncheckedCreateWithoutRequestInput>>
    connectOrCreate?: Enumerable<RequestReactionCreateOrConnectWithoutRequestInput>
    createMany?: RequestReactionCreateManyRequestInputEnvelope
    connect?: Enumerable<RequestReactionWhereUniqueInput>
  }

  export type RequestApplyCreatorUncheckedCreateNestedManyWithoutRequestInput = {
    create?: XOR<Enumerable<RequestApplyCreatorCreateWithoutRequestInput>, Enumerable<RequestApplyCreatorUncheckedCreateWithoutRequestInput>>
    connectOrCreate?: Enumerable<RequestApplyCreatorCreateOrConnectWithoutRequestInput>
    createMany?: RequestApplyCreatorCreateManyRequestInputEnvelope
    connect?: Enumerable<RequestApplyCreatorWhereUniqueInput>
  }

  export type RequestPlatformUncheckedCreateNestedManyWithoutRequestInput = {
    create?: XOR<Enumerable<RequestPlatformCreateWithoutRequestInput>, Enumerable<RequestPlatformUncheckedCreateWithoutRequestInput>>
    connectOrCreate?: Enumerable<RequestPlatformCreateOrConnectWithoutRequestInput>
    createMany?: RequestPlatformCreateManyRequestInputEnvelope
    connect?: Enumerable<RequestPlatformWhereUniqueInput>
  }

  export type RequestCommentUncheckedCreateNestedManyWithoutRequestInput = {
    create?: XOR<Enumerable<RequestCommentCreateWithoutRequestInput>, Enumerable<RequestCommentUncheckedCreateWithoutRequestInput>>
    connectOrCreate?: Enumerable<RequestCommentCreateOrConnectWithoutRequestInput>
    createMany?: RequestCommentCreateManyRequestInputEnvelope
    connect?: Enumerable<RequestCommentWhereUniqueInput>
  }

  export type RequestBookmarkUncheckedCreateNestedManyWithoutRequestInput = {
    create?: XOR<Enumerable<RequestBookmarkCreateWithoutRequestInput>, Enumerable<RequestBookmarkUncheckedCreateWithoutRequestInput>>
    connectOrCreate?: Enumerable<RequestBookmarkCreateOrConnectWithoutRequestInput>
    createMany?: RequestBookmarkCreateManyRequestInputEnvelope
    connect?: Enumerable<RequestBookmarkWhereUniqueInput>
  }

  export type RequestReportUncheckedCreateNestedManyWithoutRequestInput = {
    create?: XOR<Enumerable<RequestReportCreateWithoutRequestInput>, Enumerable<RequestReportUncheckedCreateWithoutRequestInput>>
    connectOrCreate?: Enumerable<RequestReportCreateOrConnectWithoutRequestInput>
    createMany?: RequestReportCreateManyRequestInputEnvelope
    connect?: Enumerable<RequestReportWhereUniqueInput>
  }

  export type RequestInquiryUncheckedCreateNestedManyWithoutRequestInput = {
    create?: XOR<Enumerable<RequestInquiryCreateWithoutRequestInput>, Enumerable<RequestInquiryUncheckedCreateWithoutRequestInput>>
    connectOrCreate?: Enumerable<RequestInquiryCreateOrConnectWithoutRequestInput>
    createMany?: RequestInquiryCreateManyRequestInputEnvelope
    connect?: Enumerable<RequestInquiryWhereUniqueInput>
  }

  export type LogUncheckedCreateNestedManyWithoutRequestInput = {
    create?: XOR<Enumerable<LogCreateWithoutRequestInput>, Enumerable<LogUncheckedCreateWithoutRequestInput>>
    connectOrCreate?: Enumerable<LogCreateOrConnectWithoutRequestInput>
    createMany?: LogCreateManyRequestInputEnvelope
    connect?: Enumerable<LogWhereUniqueInput>
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type UserUpdateOneWithoutRequestPostsNestedInput = {
    create?: XOR<UserCreateWithoutRequestPostsInput, UserUncheckedCreateWithoutRequestPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRequestPostsInput
    upsert?: UserUpsertWithoutRequestPostsInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutRequestPostsInput, UserUncheckedUpdateWithoutRequestPostsInput>
  }

  export type CreatorUpdateOneWithoutRequestPostsNestedInput = {
    create?: XOR<CreatorCreateWithoutRequestPostsInput, CreatorUncheckedCreateWithoutRequestPostsInput>
    connectOrCreate?: CreatorCreateOrConnectWithoutRequestPostsInput
    upsert?: CreatorUpsertWithoutRequestPostsInput
    disconnect?: boolean
    delete?: boolean
    connect?: CreatorWhereUniqueInput
    update?: XOR<CreatorUpdateWithoutRequestPostsInput, CreatorUncheckedUpdateWithoutRequestPostsInput>
  }

  export type NullableEnumRequestCategoryTypeFieldUpdateOperationsInput = {
    set?: RequestCategoryType | null
  }

  export type EnumRequestStatusTypeFieldUpdateOperationsInput = {
    set?: RequestStatusType
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type RequestFundingUpdateManyWithoutRequestNestedInput = {
    create?: XOR<Enumerable<RequestFundingCreateWithoutRequestInput>, Enumerable<RequestFundingUncheckedCreateWithoutRequestInput>>
    connectOrCreate?: Enumerable<RequestFundingCreateOrConnectWithoutRequestInput>
    upsert?: Enumerable<RequestFundingUpsertWithWhereUniqueWithoutRequestInput>
    createMany?: RequestFundingCreateManyRequestInputEnvelope
    set?: Enumerable<RequestFundingWhereUniqueInput>
    disconnect?: Enumerable<RequestFundingWhereUniqueInput>
    delete?: Enumerable<RequestFundingWhereUniqueInput>
    connect?: Enumerable<RequestFundingWhereUniqueInput>
    update?: Enumerable<RequestFundingUpdateWithWhereUniqueWithoutRequestInput>
    updateMany?: Enumerable<RequestFundingUpdateManyWithWhereWithoutRequestInput>
    deleteMany?: Enumerable<RequestFundingScalarWhereInput>
  }

  export type RequestReactionUpdateManyWithoutRequestNestedInput = {
    create?: XOR<Enumerable<RequestReactionCreateWithoutRequestInput>, Enumerable<RequestReactionUncheckedCreateWithoutRequestInput>>
    connectOrCreate?: Enumerable<RequestReactionCreateOrConnectWithoutRequestInput>
    upsert?: Enumerable<RequestReactionUpsertWithWhereUniqueWithoutRequestInput>
    createMany?: RequestReactionCreateManyRequestInputEnvelope
    set?: Enumerable<RequestReactionWhereUniqueInput>
    disconnect?: Enumerable<RequestReactionWhereUniqueInput>
    delete?: Enumerable<RequestReactionWhereUniqueInput>
    connect?: Enumerable<RequestReactionWhereUniqueInput>
    update?: Enumerable<RequestReactionUpdateWithWhereUniqueWithoutRequestInput>
    updateMany?: Enumerable<RequestReactionUpdateManyWithWhereWithoutRequestInput>
    deleteMany?: Enumerable<RequestReactionScalarWhereInput>
  }

  export type RequestApplyCreatorUpdateManyWithoutRequestNestedInput = {
    create?: XOR<Enumerable<RequestApplyCreatorCreateWithoutRequestInput>, Enumerable<RequestApplyCreatorUncheckedCreateWithoutRequestInput>>
    connectOrCreate?: Enumerable<RequestApplyCreatorCreateOrConnectWithoutRequestInput>
    upsert?: Enumerable<RequestApplyCreatorUpsertWithWhereUniqueWithoutRequestInput>
    createMany?: RequestApplyCreatorCreateManyRequestInputEnvelope
    set?: Enumerable<RequestApplyCreatorWhereUniqueInput>
    disconnect?: Enumerable<RequestApplyCreatorWhereUniqueInput>
    delete?: Enumerable<RequestApplyCreatorWhereUniqueInput>
    connect?: Enumerable<RequestApplyCreatorWhereUniqueInput>
    update?: Enumerable<RequestApplyCreatorUpdateWithWhereUniqueWithoutRequestInput>
    updateMany?: Enumerable<RequestApplyCreatorUpdateManyWithWhereWithoutRequestInput>
    deleteMany?: Enumerable<RequestApplyCreatorScalarWhereInput>
  }

  export type RequestPlatformUpdateManyWithoutRequestNestedInput = {
    create?: XOR<Enumerable<RequestPlatformCreateWithoutRequestInput>, Enumerable<RequestPlatformUncheckedCreateWithoutRequestInput>>
    connectOrCreate?: Enumerable<RequestPlatformCreateOrConnectWithoutRequestInput>
    upsert?: Enumerable<RequestPlatformUpsertWithWhereUniqueWithoutRequestInput>
    createMany?: RequestPlatformCreateManyRequestInputEnvelope
    set?: Enumerable<RequestPlatformWhereUniqueInput>
    disconnect?: Enumerable<RequestPlatformWhereUniqueInput>
    delete?: Enumerable<RequestPlatformWhereUniqueInput>
    connect?: Enumerable<RequestPlatformWhereUniqueInput>
    update?: Enumerable<RequestPlatformUpdateWithWhereUniqueWithoutRequestInput>
    updateMany?: Enumerable<RequestPlatformUpdateManyWithWhereWithoutRequestInput>
    deleteMany?: Enumerable<RequestPlatformScalarWhereInput>
  }

  export type RequestCommentUpdateManyWithoutRequestNestedInput = {
    create?: XOR<Enumerable<RequestCommentCreateWithoutRequestInput>, Enumerable<RequestCommentUncheckedCreateWithoutRequestInput>>
    connectOrCreate?: Enumerable<RequestCommentCreateOrConnectWithoutRequestInput>
    upsert?: Enumerable<RequestCommentUpsertWithWhereUniqueWithoutRequestInput>
    createMany?: RequestCommentCreateManyRequestInputEnvelope
    set?: Enumerable<RequestCommentWhereUniqueInput>
    disconnect?: Enumerable<RequestCommentWhereUniqueInput>
    delete?: Enumerable<RequestCommentWhereUniqueInput>
    connect?: Enumerable<RequestCommentWhereUniqueInput>
    update?: Enumerable<RequestCommentUpdateWithWhereUniqueWithoutRequestInput>
    updateMany?: Enumerable<RequestCommentUpdateManyWithWhereWithoutRequestInput>
    deleteMany?: Enumerable<RequestCommentScalarWhereInput>
  }

  export type RequestBookmarkUpdateManyWithoutRequestNestedInput = {
    create?: XOR<Enumerable<RequestBookmarkCreateWithoutRequestInput>, Enumerable<RequestBookmarkUncheckedCreateWithoutRequestInput>>
    connectOrCreate?: Enumerable<RequestBookmarkCreateOrConnectWithoutRequestInput>
    upsert?: Enumerable<RequestBookmarkUpsertWithWhereUniqueWithoutRequestInput>
    createMany?: RequestBookmarkCreateManyRequestInputEnvelope
    set?: Enumerable<RequestBookmarkWhereUniqueInput>
    disconnect?: Enumerable<RequestBookmarkWhereUniqueInput>
    delete?: Enumerable<RequestBookmarkWhereUniqueInput>
    connect?: Enumerable<RequestBookmarkWhereUniqueInput>
    update?: Enumerable<RequestBookmarkUpdateWithWhereUniqueWithoutRequestInput>
    updateMany?: Enumerable<RequestBookmarkUpdateManyWithWhereWithoutRequestInput>
    deleteMany?: Enumerable<RequestBookmarkScalarWhereInput>
  }

  export type RequestReportUpdateManyWithoutRequestNestedInput = {
    create?: XOR<Enumerable<RequestReportCreateWithoutRequestInput>, Enumerable<RequestReportUncheckedCreateWithoutRequestInput>>
    connectOrCreate?: Enumerable<RequestReportCreateOrConnectWithoutRequestInput>
    upsert?: Enumerable<RequestReportUpsertWithWhereUniqueWithoutRequestInput>
    createMany?: RequestReportCreateManyRequestInputEnvelope
    set?: Enumerable<RequestReportWhereUniqueInput>
    disconnect?: Enumerable<RequestReportWhereUniqueInput>
    delete?: Enumerable<RequestReportWhereUniqueInput>
    connect?: Enumerable<RequestReportWhereUniqueInput>
    update?: Enumerable<RequestReportUpdateWithWhereUniqueWithoutRequestInput>
    updateMany?: Enumerable<RequestReportUpdateManyWithWhereWithoutRequestInput>
    deleteMany?: Enumerable<RequestReportScalarWhereInput>
  }

  export type RequestInquiryUpdateManyWithoutRequestNestedInput = {
    create?: XOR<Enumerable<RequestInquiryCreateWithoutRequestInput>, Enumerable<RequestInquiryUncheckedCreateWithoutRequestInput>>
    connectOrCreate?: Enumerable<RequestInquiryCreateOrConnectWithoutRequestInput>
    upsert?: Enumerable<RequestInquiryUpsertWithWhereUniqueWithoutRequestInput>
    createMany?: RequestInquiryCreateManyRequestInputEnvelope
    set?: Enumerable<RequestInquiryWhereUniqueInput>
    disconnect?: Enumerable<RequestInquiryWhereUniqueInput>
    delete?: Enumerable<RequestInquiryWhereUniqueInput>
    connect?: Enumerable<RequestInquiryWhereUniqueInput>
    update?: Enumerable<RequestInquiryUpdateWithWhereUniqueWithoutRequestInput>
    updateMany?: Enumerable<RequestInquiryUpdateManyWithWhereWithoutRequestInput>
    deleteMany?: Enumerable<RequestInquiryScalarWhereInput>
  }

  export type LogUpdateManyWithoutRequestNestedInput = {
    create?: XOR<Enumerable<LogCreateWithoutRequestInput>, Enumerable<LogUncheckedCreateWithoutRequestInput>>
    connectOrCreate?: Enumerable<LogCreateOrConnectWithoutRequestInput>
    upsert?: Enumerable<LogUpsertWithWhereUniqueWithoutRequestInput>
    createMany?: LogCreateManyRequestInputEnvelope
    set?: Enumerable<LogWhereUniqueInput>
    disconnect?: Enumerable<LogWhereUniqueInput>
    delete?: Enumerable<LogWhereUniqueInput>
    connect?: Enumerable<LogWhereUniqueInput>
    update?: Enumerable<LogUpdateWithWhereUniqueWithoutRequestInput>
    updateMany?: Enumerable<LogUpdateManyWithWhereWithoutRequestInput>
    deleteMany?: Enumerable<LogScalarWhereInput>
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type RequestFundingUncheckedUpdateManyWithoutRequestNestedInput = {
    create?: XOR<Enumerable<RequestFundingCreateWithoutRequestInput>, Enumerable<RequestFundingUncheckedCreateWithoutRequestInput>>
    connectOrCreate?: Enumerable<RequestFundingCreateOrConnectWithoutRequestInput>
    upsert?: Enumerable<RequestFundingUpsertWithWhereUniqueWithoutRequestInput>
    createMany?: RequestFundingCreateManyRequestInputEnvelope
    set?: Enumerable<RequestFundingWhereUniqueInput>
    disconnect?: Enumerable<RequestFundingWhereUniqueInput>
    delete?: Enumerable<RequestFundingWhereUniqueInput>
    connect?: Enumerable<RequestFundingWhereUniqueInput>
    update?: Enumerable<RequestFundingUpdateWithWhereUniqueWithoutRequestInput>
    updateMany?: Enumerable<RequestFundingUpdateManyWithWhereWithoutRequestInput>
    deleteMany?: Enumerable<RequestFundingScalarWhereInput>
  }

  export type RequestReactionUncheckedUpdateManyWithoutRequestNestedInput = {
    create?: XOR<Enumerable<RequestReactionCreateWithoutRequestInput>, Enumerable<RequestReactionUncheckedCreateWithoutRequestInput>>
    connectOrCreate?: Enumerable<RequestReactionCreateOrConnectWithoutRequestInput>
    upsert?: Enumerable<RequestReactionUpsertWithWhereUniqueWithoutRequestInput>
    createMany?: RequestReactionCreateManyRequestInputEnvelope
    set?: Enumerable<RequestReactionWhereUniqueInput>
    disconnect?: Enumerable<RequestReactionWhereUniqueInput>
    delete?: Enumerable<RequestReactionWhereUniqueInput>
    connect?: Enumerable<RequestReactionWhereUniqueInput>
    update?: Enumerable<RequestReactionUpdateWithWhereUniqueWithoutRequestInput>
    updateMany?: Enumerable<RequestReactionUpdateManyWithWhereWithoutRequestInput>
    deleteMany?: Enumerable<RequestReactionScalarWhereInput>
  }

  export type RequestApplyCreatorUncheckedUpdateManyWithoutRequestNestedInput = {
    create?: XOR<Enumerable<RequestApplyCreatorCreateWithoutRequestInput>, Enumerable<RequestApplyCreatorUncheckedCreateWithoutRequestInput>>
    connectOrCreate?: Enumerable<RequestApplyCreatorCreateOrConnectWithoutRequestInput>
    upsert?: Enumerable<RequestApplyCreatorUpsertWithWhereUniqueWithoutRequestInput>
    createMany?: RequestApplyCreatorCreateManyRequestInputEnvelope
    set?: Enumerable<RequestApplyCreatorWhereUniqueInput>
    disconnect?: Enumerable<RequestApplyCreatorWhereUniqueInput>
    delete?: Enumerable<RequestApplyCreatorWhereUniqueInput>
    connect?: Enumerable<RequestApplyCreatorWhereUniqueInput>
    update?: Enumerable<RequestApplyCreatorUpdateWithWhereUniqueWithoutRequestInput>
    updateMany?: Enumerable<RequestApplyCreatorUpdateManyWithWhereWithoutRequestInput>
    deleteMany?: Enumerable<RequestApplyCreatorScalarWhereInput>
  }

  export type RequestPlatformUncheckedUpdateManyWithoutRequestNestedInput = {
    create?: XOR<Enumerable<RequestPlatformCreateWithoutRequestInput>, Enumerable<RequestPlatformUncheckedCreateWithoutRequestInput>>
    connectOrCreate?: Enumerable<RequestPlatformCreateOrConnectWithoutRequestInput>
    upsert?: Enumerable<RequestPlatformUpsertWithWhereUniqueWithoutRequestInput>
    createMany?: RequestPlatformCreateManyRequestInputEnvelope
    set?: Enumerable<RequestPlatformWhereUniqueInput>
    disconnect?: Enumerable<RequestPlatformWhereUniqueInput>
    delete?: Enumerable<RequestPlatformWhereUniqueInput>
    connect?: Enumerable<RequestPlatformWhereUniqueInput>
    update?: Enumerable<RequestPlatformUpdateWithWhereUniqueWithoutRequestInput>
    updateMany?: Enumerable<RequestPlatformUpdateManyWithWhereWithoutRequestInput>
    deleteMany?: Enumerable<RequestPlatformScalarWhereInput>
  }

  export type RequestCommentUncheckedUpdateManyWithoutRequestNestedInput = {
    create?: XOR<Enumerable<RequestCommentCreateWithoutRequestInput>, Enumerable<RequestCommentUncheckedCreateWithoutRequestInput>>
    connectOrCreate?: Enumerable<RequestCommentCreateOrConnectWithoutRequestInput>
    upsert?: Enumerable<RequestCommentUpsertWithWhereUniqueWithoutRequestInput>
    createMany?: RequestCommentCreateManyRequestInputEnvelope
    set?: Enumerable<RequestCommentWhereUniqueInput>
    disconnect?: Enumerable<RequestCommentWhereUniqueInput>
    delete?: Enumerable<RequestCommentWhereUniqueInput>
    connect?: Enumerable<RequestCommentWhereUniqueInput>
    update?: Enumerable<RequestCommentUpdateWithWhereUniqueWithoutRequestInput>
    updateMany?: Enumerable<RequestCommentUpdateManyWithWhereWithoutRequestInput>
    deleteMany?: Enumerable<RequestCommentScalarWhereInput>
  }

  export type RequestBookmarkUncheckedUpdateManyWithoutRequestNestedInput = {
    create?: XOR<Enumerable<RequestBookmarkCreateWithoutRequestInput>, Enumerable<RequestBookmarkUncheckedCreateWithoutRequestInput>>
    connectOrCreate?: Enumerable<RequestBookmarkCreateOrConnectWithoutRequestInput>
    upsert?: Enumerable<RequestBookmarkUpsertWithWhereUniqueWithoutRequestInput>
    createMany?: RequestBookmarkCreateManyRequestInputEnvelope
    set?: Enumerable<RequestBookmarkWhereUniqueInput>
    disconnect?: Enumerable<RequestBookmarkWhereUniqueInput>
    delete?: Enumerable<RequestBookmarkWhereUniqueInput>
    connect?: Enumerable<RequestBookmarkWhereUniqueInput>
    update?: Enumerable<RequestBookmarkUpdateWithWhereUniqueWithoutRequestInput>
    updateMany?: Enumerable<RequestBookmarkUpdateManyWithWhereWithoutRequestInput>
    deleteMany?: Enumerable<RequestBookmarkScalarWhereInput>
  }

  export type RequestReportUncheckedUpdateManyWithoutRequestNestedInput = {
    create?: XOR<Enumerable<RequestReportCreateWithoutRequestInput>, Enumerable<RequestReportUncheckedCreateWithoutRequestInput>>
    connectOrCreate?: Enumerable<RequestReportCreateOrConnectWithoutRequestInput>
    upsert?: Enumerable<RequestReportUpsertWithWhereUniqueWithoutRequestInput>
    createMany?: RequestReportCreateManyRequestInputEnvelope
    set?: Enumerable<RequestReportWhereUniqueInput>
    disconnect?: Enumerable<RequestReportWhereUniqueInput>
    delete?: Enumerable<RequestReportWhereUniqueInput>
    connect?: Enumerable<RequestReportWhereUniqueInput>
    update?: Enumerable<RequestReportUpdateWithWhereUniqueWithoutRequestInput>
    updateMany?: Enumerable<RequestReportUpdateManyWithWhereWithoutRequestInput>
    deleteMany?: Enumerable<RequestReportScalarWhereInput>
  }

  export type RequestInquiryUncheckedUpdateManyWithoutRequestNestedInput = {
    create?: XOR<Enumerable<RequestInquiryCreateWithoutRequestInput>, Enumerable<RequestInquiryUncheckedCreateWithoutRequestInput>>
    connectOrCreate?: Enumerable<RequestInquiryCreateOrConnectWithoutRequestInput>
    upsert?: Enumerable<RequestInquiryUpsertWithWhereUniqueWithoutRequestInput>
    createMany?: RequestInquiryCreateManyRequestInputEnvelope
    set?: Enumerable<RequestInquiryWhereUniqueInput>
    disconnect?: Enumerable<RequestInquiryWhereUniqueInput>
    delete?: Enumerable<RequestInquiryWhereUniqueInput>
    connect?: Enumerable<RequestInquiryWhereUniqueInput>
    update?: Enumerable<RequestInquiryUpdateWithWhereUniqueWithoutRequestInput>
    updateMany?: Enumerable<RequestInquiryUpdateManyWithWhereWithoutRequestInput>
    deleteMany?: Enumerable<RequestInquiryScalarWhereInput>
  }

  export type LogUncheckedUpdateManyWithoutRequestNestedInput = {
    create?: XOR<Enumerable<LogCreateWithoutRequestInput>, Enumerable<LogUncheckedCreateWithoutRequestInput>>
    connectOrCreate?: Enumerable<LogCreateOrConnectWithoutRequestInput>
    upsert?: Enumerable<LogUpsertWithWhereUniqueWithoutRequestInput>
    createMany?: LogCreateManyRequestInputEnvelope
    set?: Enumerable<LogWhereUniqueInput>
    disconnect?: Enumerable<LogWhereUniqueInput>
    delete?: Enumerable<LogWhereUniqueInput>
    connect?: Enumerable<LogWhereUniqueInput>
    update?: Enumerable<LogUpdateWithWhereUniqueWithoutRequestInput>
    updateMany?: Enumerable<LogUpdateManyWithWhereWithoutRequestInput>
    deleteMany?: Enumerable<LogScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutRequestFundingsInput = {
    create?: XOR<UserCreateWithoutRequestFundingsInput, UserUncheckedCreateWithoutRequestFundingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRequestFundingsInput
    connect?: UserWhereUniqueInput
  }

  export type RequestPostCreateNestedOneWithoutRequestFundingsInput = {
    create?: XOR<RequestPostCreateWithoutRequestFundingsInput, RequestPostUncheckedCreateWithoutRequestFundingsInput>
    connectOrCreate?: RequestPostCreateOrConnectWithoutRequestFundingsInput
    connect?: RequestPostWhereUniqueInput
  }

  export type UserUpdateOneWithoutRequestFundingsNestedInput = {
    create?: XOR<UserCreateWithoutRequestFundingsInput, UserUncheckedCreateWithoutRequestFundingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRequestFundingsInput
    upsert?: UserUpsertWithoutRequestFundingsInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutRequestFundingsInput, UserUncheckedUpdateWithoutRequestFundingsInput>
  }

  export type RequestPostUpdateOneWithoutRequestFundingsNestedInput = {
    create?: XOR<RequestPostCreateWithoutRequestFundingsInput, RequestPostUncheckedCreateWithoutRequestFundingsInput>
    connectOrCreate?: RequestPostCreateOrConnectWithoutRequestFundingsInput
    upsert?: RequestPostUpsertWithoutRequestFundingsInput
    disconnect?: boolean
    delete?: boolean
    connect?: RequestPostWhereUniqueInput
    update?: XOR<RequestPostUpdateWithoutRequestFundingsInput, RequestPostUncheckedUpdateWithoutRequestFundingsInput>
  }

  export type EnumRequestFundingStatusFieldUpdateOperationsInput = {
    set?: RequestFundingStatus
  }

  export type UserCreateNestedOneWithoutRequestReactionsInput = {
    create?: XOR<UserCreateWithoutRequestReactionsInput, UserUncheckedCreateWithoutRequestReactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRequestReactionsInput
    connect?: UserWhereUniqueInput
  }

  export type RequestPostCreateNestedOneWithoutRequestReactionsInput = {
    create?: XOR<RequestPostCreateWithoutRequestReactionsInput, RequestPostUncheckedCreateWithoutRequestReactionsInput>
    connectOrCreate?: RequestPostCreateOrConnectWithoutRequestReactionsInput
    connect?: RequestPostWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRequestReactionsNestedInput = {
    create?: XOR<UserCreateWithoutRequestReactionsInput, UserUncheckedCreateWithoutRequestReactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRequestReactionsInput
    upsert?: UserUpsertWithoutRequestReactionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutRequestReactionsInput, UserUncheckedUpdateWithoutRequestReactionsInput>
  }

  export type EnumReactionTypeFieldUpdateOperationsInput = {
    set?: ReactionType
  }

  export type RequestPostUpdateOneRequiredWithoutRequestReactionsNestedInput = {
    create?: XOR<RequestPostCreateWithoutRequestReactionsInput, RequestPostUncheckedCreateWithoutRequestReactionsInput>
    connectOrCreate?: RequestPostCreateOrConnectWithoutRequestReactionsInput
    upsert?: RequestPostUpsertWithoutRequestReactionsInput
    connect?: RequestPostWhereUniqueInput
    update?: XOR<RequestPostUpdateWithoutRequestReactionsInput, RequestPostUncheckedUpdateWithoutRequestReactionsInput>
  }

  export type RequestPostCreateNestedOneWithoutRequestCommentsInput = {
    create?: XOR<RequestPostCreateWithoutRequestCommentsInput, RequestPostUncheckedCreateWithoutRequestCommentsInput>
    connectOrCreate?: RequestPostCreateOrConnectWithoutRequestCommentsInput
    connect?: RequestPostWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRequestCommentsInput = {
    create?: XOR<UserCreateWithoutRequestCommentsInput, UserUncheckedCreateWithoutRequestCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRequestCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type RequestCommentCreateNestedOneWithoutChildrenCommentsInput = {
    create?: XOR<RequestCommentCreateWithoutChildrenCommentsInput, RequestCommentUncheckedCreateWithoutChildrenCommentsInput>
    connectOrCreate?: RequestCommentCreateOrConnectWithoutChildrenCommentsInput
    connect?: RequestCommentWhereUniqueInput
  }

  export type RequestCommentHeartCreateNestedManyWithoutRequestCommentInput = {
    create?: XOR<Enumerable<RequestCommentHeartCreateWithoutRequestCommentInput>, Enumerable<RequestCommentHeartUncheckedCreateWithoutRequestCommentInput>>
    connectOrCreate?: Enumerable<RequestCommentHeartCreateOrConnectWithoutRequestCommentInput>
    createMany?: RequestCommentHeartCreateManyRequestCommentInputEnvelope
    connect?: Enumerable<RequestCommentHeartWhereUniqueInput>
  }

  export type RequestCommentCreateNestedManyWithoutParentCommentInput = {
    create?: XOR<Enumerable<RequestCommentCreateWithoutParentCommentInput>, Enumerable<RequestCommentUncheckedCreateWithoutParentCommentInput>>
    connectOrCreate?: Enumerable<RequestCommentCreateOrConnectWithoutParentCommentInput>
    createMany?: RequestCommentCreateManyParentCommentInputEnvelope
    connect?: Enumerable<RequestCommentWhereUniqueInput>
  }

  export type RequestCommentHeartUncheckedCreateNestedManyWithoutRequestCommentInput = {
    create?: XOR<Enumerable<RequestCommentHeartCreateWithoutRequestCommentInput>, Enumerable<RequestCommentHeartUncheckedCreateWithoutRequestCommentInput>>
    connectOrCreate?: Enumerable<RequestCommentHeartCreateOrConnectWithoutRequestCommentInput>
    createMany?: RequestCommentHeartCreateManyRequestCommentInputEnvelope
    connect?: Enumerable<RequestCommentHeartWhereUniqueInput>
  }

  export type RequestCommentUncheckedCreateNestedManyWithoutParentCommentInput = {
    create?: XOR<Enumerable<RequestCommentCreateWithoutParentCommentInput>, Enumerable<RequestCommentUncheckedCreateWithoutParentCommentInput>>
    connectOrCreate?: Enumerable<RequestCommentCreateOrConnectWithoutParentCommentInput>
    createMany?: RequestCommentCreateManyParentCommentInputEnvelope
    connect?: Enumerable<RequestCommentWhereUniqueInput>
  }

  export type RequestPostUpdateOneRequiredWithoutRequestCommentsNestedInput = {
    create?: XOR<RequestPostCreateWithoutRequestCommentsInput, RequestPostUncheckedCreateWithoutRequestCommentsInput>
    connectOrCreate?: RequestPostCreateOrConnectWithoutRequestCommentsInput
    upsert?: RequestPostUpsertWithoutRequestCommentsInput
    connect?: RequestPostWhereUniqueInput
    update?: XOR<RequestPostUpdateWithoutRequestCommentsInput, RequestPostUncheckedUpdateWithoutRequestCommentsInput>
  }

  export type UserUpdateOneWithoutRequestCommentsNestedInput = {
    create?: XOR<UserCreateWithoutRequestCommentsInput, UserUncheckedCreateWithoutRequestCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRequestCommentsInput
    upsert?: UserUpsertWithoutRequestCommentsInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutRequestCommentsInput, UserUncheckedUpdateWithoutRequestCommentsInput>
  }

  export type RequestCommentUpdateOneWithoutChildrenCommentsNestedInput = {
    create?: XOR<RequestCommentCreateWithoutChildrenCommentsInput, RequestCommentUncheckedCreateWithoutChildrenCommentsInput>
    connectOrCreate?: RequestCommentCreateOrConnectWithoutChildrenCommentsInput
    upsert?: RequestCommentUpsertWithoutChildrenCommentsInput
    disconnect?: boolean
    delete?: boolean
    connect?: RequestCommentWhereUniqueInput
    update?: XOR<RequestCommentUpdateWithoutChildrenCommentsInput, RequestCommentUncheckedUpdateWithoutChildrenCommentsInput>
  }

  export type RequestCommentHeartUpdateManyWithoutRequestCommentNestedInput = {
    create?: XOR<Enumerable<RequestCommentHeartCreateWithoutRequestCommentInput>, Enumerable<RequestCommentHeartUncheckedCreateWithoutRequestCommentInput>>
    connectOrCreate?: Enumerable<RequestCommentHeartCreateOrConnectWithoutRequestCommentInput>
    upsert?: Enumerable<RequestCommentHeartUpsertWithWhereUniqueWithoutRequestCommentInput>
    createMany?: RequestCommentHeartCreateManyRequestCommentInputEnvelope
    set?: Enumerable<RequestCommentHeartWhereUniqueInput>
    disconnect?: Enumerable<RequestCommentHeartWhereUniqueInput>
    delete?: Enumerable<RequestCommentHeartWhereUniqueInput>
    connect?: Enumerable<RequestCommentHeartWhereUniqueInput>
    update?: Enumerable<RequestCommentHeartUpdateWithWhereUniqueWithoutRequestCommentInput>
    updateMany?: Enumerable<RequestCommentHeartUpdateManyWithWhereWithoutRequestCommentInput>
    deleteMany?: Enumerable<RequestCommentHeartScalarWhereInput>
  }

  export type RequestCommentUpdateManyWithoutParentCommentNestedInput = {
    create?: XOR<Enumerable<RequestCommentCreateWithoutParentCommentInput>, Enumerable<RequestCommentUncheckedCreateWithoutParentCommentInput>>
    connectOrCreate?: Enumerable<RequestCommentCreateOrConnectWithoutParentCommentInput>
    upsert?: Enumerable<RequestCommentUpsertWithWhereUniqueWithoutParentCommentInput>
    createMany?: RequestCommentCreateManyParentCommentInputEnvelope
    set?: Enumerable<RequestCommentWhereUniqueInput>
    disconnect?: Enumerable<RequestCommentWhereUniqueInput>
    delete?: Enumerable<RequestCommentWhereUniqueInput>
    connect?: Enumerable<RequestCommentWhereUniqueInput>
    update?: Enumerable<RequestCommentUpdateWithWhereUniqueWithoutParentCommentInput>
    updateMany?: Enumerable<RequestCommentUpdateManyWithWhereWithoutParentCommentInput>
    deleteMany?: Enumerable<RequestCommentScalarWhereInput>
  }

  export type RequestCommentHeartUncheckedUpdateManyWithoutRequestCommentNestedInput = {
    create?: XOR<Enumerable<RequestCommentHeartCreateWithoutRequestCommentInput>, Enumerable<RequestCommentHeartUncheckedCreateWithoutRequestCommentInput>>
    connectOrCreate?: Enumerable<RequestCommentHeartCreateOrConnectWithoutRequestCommentInput>
    upsert?: Enumerable<RequestCommentHeartUpsertWithWhereUniqueWithoutRequestCommentInput>
    createMany?: RequestCommentHeartCreateManyRequestCommentInputEnvelope
    set?: Enumerable<RequestCommentHeartWhereUniqueInput>
    disconnect?: Enumerable<RequestCommentHeartWhereUniqueInput>
    delete?: Enumerable<RequestCommentHeartWhereUniqueInput>
    connect?: Enumerable<RequestCommentHeartWhereUniqueInput>
    update?: Enumerable<RequestCommentHeartUpdateWithWhereUniqueWithoutRequestCommentInput>
    updateMany?: Enumerable<RequestCommentHeartUpdateManyWithWhereWithoutRequestCommentInput>
    deleteMany?: Enumerable<RequestCommentHeartScalarWhereInput>
  }

  export type RequestCommentUncheckedUpdateManyWithoutParentCommentNestedInput = {
    create?: XOR<Enumerable<RequestCommentCreateWithoutParentCommentInput>, Enumerable<RequestCommentUncheckedCreateWithoutParentCommentInput>>
    connectOrCreate?: Enumerable<RequestCommentCreateOrConnectWithoutParentCommentInput>
    upsert?: Enumerable<RequestCommentUpsertWithWhereUniqueWithoutParentCommentInput>
    createMany?: RequestCommentCreateManyParentCommentInputEnvelope
    set?: Enumerable<RequestCommentWhereUniqueInput>
    disconnect?: Enumerable<RequestCommentWhereUniqueInput>
    delete?: Enumerable<RequestCommentWhereUniqueInput>
    connect?: Enumerable<RequestCommentWhereUniqueInput>
    update?: Enumerable<RequestCommentUpdateWithWhereUniqueWithoutParentCommentInput>
    updateMany?: Enumerable<RequestCommentUpdateManyWithWhereWithoutParentCommentInput>
    deleteMany?: Enumerable<RequestCommentScalarWhereInput>
  }

  export type RequestCommentCreateNestedOneWithoutHeartsInput = {
    create?: XOR<RequestCommentCreateWithoutHeartsInput, RequestCommentUncheckedCreateWithoutHeartsInput>
    connectOrCreate?: RequestCommentCreateOrConnectWithoutHeartsInput
    connect?: RequestCommentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRequestCommentHeartsInput = {
    create?: XOR<UserCreateWithoutRequestCommentHeartsInput, UserUncheckedCreateWithoutRequestCommentHeartsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRequestCommentHeartsInput
    connect?: UserWhereUniqueInput
  }

  export type RequestCommentUpdateOneRequiredWithoutHeartsNestedInput = {
    create?: XOR<RequestCommentCreateWithoutHeartsInput, RequestCommentUncheckedCreateWithoutHeartsInput>
    connectOrCreate?: RequestCommentCreateOrConnectWithoutHeartsInput
    upsert?: RequestCommentUpsertWithoutHeartsInput
    connect?: RequestCommentWhereUniqueInput
    update?: XOR<RequestCommentUpdateWithoutHeartsInput, RequestCommentUncheckedUpdateWithoutHeartsInput>
  }

  export type UserUpdateOneRequiredWithoutRequestCommentHeartsNestedInput = {
    create?: XOR<UserCreateWithoutRequestCommentHeartsInput, UserUncheckedCreateWithoutRequestCommentHeartsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRequestCommentHeartsInput
    upsert?: UserUpsertWithoutRequestCommentHeartsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutRequestCommentHeartsInput, UserUncheckedUpdateWithoutRequestCommentHeartsInput>
  }

  export type RequestPostCreateNestedOneWithoutRequestBookmarksInput = {
    create?: XOR<RequestPostCreateWithoutRequestBookmarksInput, RequestPostUncheckedCreateWithoutRequestBookmarksInput>
    connectOrCreate?: RequestPostCreateOrConnectWithoutRequestBookmarksInput
    connect?: RequestPostWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRequestBookmarksInput = {
    create?: XOR<UserCreateWithoutRequestBookmarksInput, UserUncheckedCreateWithoutRequestBookmarksInput>
    connectOrCreate?: UserCreateOrConnectWithoutRequestBookmarksInput
    connect?: UserWhereUniqueInput
  }

  export type RequestPostUpdateOneWithoutRequestBookmarksNestedInput = {
    create?: XOR<RequestPostCreateWithoutRequestBookmarksInput, RequestPostUncheckedCreateWithoutRequestBookmarksInput>
    connectOrCreate?: RequestPostCreateOrConnectWithoutRequestBookmarksInput
    upsert?: RequestPostUpsertWithoutRequestBookmarksInput
    disconnect?: boolean
    delete?: boolean
    connect?: RequestPostWhereUniqueInput
    update?: XOR<RequestPostUpdateWithoutRequestBookmarksInput, RequestPostUncheckedUpdateWithoutRequestBookmarksInput>
  }

  export type UserUpdateOneRequiredWithoutRequestBookmarksNestedInput = {
    create?: XOR<UserCreateWithoutRequestBookmarksInput, UserUncheckedCreateWithoutRequestBookmarksInput>
    connectOrCreate?: UserCreateOrConnectWithoutRequestBookmarksInput
    upsert?: UserUpsertWithoutRequestBookmarksInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutRequestBookmarksInput, UserUncheckedUpdateWithoutRequestBookmarksInput>
  }

  export type RequestPostCreateNestedOneWithoutRequestPlatformsInput = {
    create?: XOR<RequestPostCreateWithoutRequestPlatformsInput, RequestPostUncheckedCreateWithoutRequestPlatformsInput>
    connectOrCreate?: RequestPostCreateOrConnectWithoutRequestPlatformsInput
    connect?: RequestPostWhereUniqueInput
  }

  export type RequestPostUpdateOneRequiredWithoutRequestPlatformsNestedInput = {
    create?: XOR<RequestPostCreateWithoutRequestPlatformsInput, RequestPostUncheckedCreateWithoutRequestPlatformsInput>
    connectOrCreate?: RequestPostCreateOrConnectWithoutRequestPlatformsInput
    upsert?: RequestPostUpsertWithoutRequestPlatformsInput
    connect?: RequestPostWhereUniqueInput
    update?: XOR<RequestPostUpdateWithoutRequestPlatformsInput, RequestPostUncheckedUpdateWithoutRequestPlatformsInput>
  }

  export type EnumRequestPlatformTypeFieldUpdateOperationsInput = {
    set?: RequestPlatformType
  }

  export type RequestPostCreateNestedOneWithoutRequestApplyCreatorsInput = {
    create?: XOR<RequestPostCreateWithoutRequestApplyCreatorsInput, RequestPostUncheckedCreateWithoutRequestApplyCreatorsInput>
    connectOrCreate?: RequestPostCreateOrConnectWithoutRequestApplyCreatorsInput
    connect?: RequestPostWhereUniqueInput
  }

  export type CreatorCreateNestedOneWithoutRequestApplyCreatorsInput = {
    create?: XOR<CreatorCreateWithoutRequestApplyCreatorsInput, CreatorUncheckedCreateWithoutRequestApplyCreatorsInput>
    connectOrCreate?: CreatorCreateOrConnectWithoutRequestApplyCreatorsInput
    connect?: CreatorWhereUniqueInput
  }

  export type RequestPostUpdateOneRequiredWithoutRequestApplyCreatorsNestedInput = {
    create?: XOR<RequestPostCreateWithoutRequestApplyCreatorsInput, RequestPostUncheckedCreateWithoutRequestApplyCreatorsInput>
    connectOrCreate?: RequestPostCreateOrConnectWithoutRequestApplyCreatorsInput
    upsert?: RequestPostUpsertWithoutRequestApplyCreatorsInput
    connect?: RequestPostWhereUniqueInput
    update?: XOR<RequestPostUpdateWithoutRequestApplyCreatorsInput, RequestPostUncheckedUpdateWithoutRequestApplyCreatorsInput>
  }

  export type CreatorUpdateOneWithoutRequestApplyCreatorsNestedInput = {
    create?: XOR<CreatorCreateWithoutRequestApplyCreatorsInput, CreatorUncheckedCreateWithoutRequestApplyCreatorsInput>
    connectOrCreate?: CreatorCreateOrConnectWithoutRequestApplyCreatorsInput
    upsert?: CreatorUpsertWithoutRequestApplyCreatorsInput
    disconnect?: boolean
    delete?: boolean
    connect?: CreatorWhereUniqueInput
    update?: XOR<CreatorUpdateWithoutRequestApplyCreatorsInput, CreatorUncheckedUpdateWithoutRequestApplyCreatorsInput>
  }

  export type RequestPostCreateNestedOneWithoutRequestReportsInput = {
    create?: XOR<RequestPostCreateWithoutRequestReportsInput, RequestPostUncheckedCreateWithoutRequestReportsInput>
    connectOrCreate?: RequestPostCreateOrConnectWithoutRequestReportsInput
    connect?: RequestPostWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRequestReportsInput = {
    create?: XOR<UserCreateWithoutRequestReportsInput, UserUncheckedCreateWithoutRequestReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRequestReportsInput
    connect?: UserWhereUniqueInput
  }

  export type RequestPostUpdateOneRequiredWithoutRequestReportsNestedInput = {
    create?: XOR<RequestPostCreateWithoutRequestReportsInput, RequestPostUncheckedCreateWithoutRequestReportsInput>
    connectOrCreate?: RequestPostCreateOrConnectWithoutRequestReportsInput
    upsert?: RequestPostUpsertWithoutRequestReportsInput
    connect?: RequestPostWhereUniqueInput
    update?: XOR<RequestPostUpdateWithoutRequestReportsInput, RequestPostUncheckedUpdateWithoutRequestReportsInput>
  }

  export type UserUpdateOneWithoutRequestReportsNestedInput = {
    create?: XOR<UserCreateWithoutRequestReportsInput, UserUncheckedCreateWithoutRequestReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRequestReportsInput
    upsert?: UserUpsertWithoutRequestReportsInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutRequestReportsInput, UserUncheckedUpdateWithoutRequestReportsInput>
  }

  export type EnumRequestReportTypeFieldUpdateOperationsInput = {
    set?: RequestReportType
  }

  export type EnumRequestReportStatusFieldUpdateOperationsInput = {
    set?: RequestReportStatus
  }

  export type RequestPostCreateNestedOneWithoutRequestInquirysInput = {
    create?: XOR<RequestPostCreateWithoutRequestInquirysInput, RequestPostUncheckedCreateWithoutRequestInquirysInput>
    connectOrCreate?: RequestPostCreateOrConnectWithoutRequestInquirysInput
    connect?: RequestPostWhereUniqueInput
  }

  export type CreatorCreateNestedOneWithoutRequestInquiriesInput = {
    create?: XOR<CreatorCreateWithoutRequestInquiriesInput, CreatorUncheckedCreateWithoutRequestInquiriesInput>
    connectOrCreate?: CreatorCreateOrConnectWithoutRequestInquiriesInput
    connect?: CreatorWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRequestInquiriesInput = {
    create?: XOR<UserCreateWithoutRequestInquiriesInput, UserUncheckedCreateWithoutRequestInquiriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRequestInquiriesInput
    connect?: UserWhereUniqueInput
  }

  export type RequestInquiryMessageCreateNestedManyWithoutRoomInput = {
    create?: XOR<Enumerable<RequestInquiryMessageCreateWithoutRoomInput>, Enumerable<RequestInquiryMessageUncheckedCreateWithoutRoomInput>>
    connectOrCreate?: Enumerable<RequestInquiryMessageCreateOrConnectWithoutRoomInput>
    createMany?: RequestInquiryMessageCreateManyRoomInputEnvelope
    connect?: Enumerable<RequestInquiryMessageWhereUniqueInput>
  }

  export type RequestInquiryMessageUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<Enumerable<RequestInquiryMessageCreateWithoutRoomInput>, Enumerable<RequestInquiryMessageUncheckedCreateWithoutRoomInput>>
    connectOrCreate?: Enumerable<RequestInquiryMessageCreateOrConnectWithoutRoomInput>
    createMany?: RequestInquiryMessageCreateManyRoomInputEnvelope
    connect?: Enumerable<RequestInquiryMessageWhereUniqueInput>
  }

  export type RequestPostUpdateOneRequiredWithoutRequestInquirysNestedInput = {
    create?: XOR<RequestPostCreateWithoutRequestInquirysInput, RequestPostUncheckedCreateWithoutRequestInquirysInput>
    connectOrCreate?: RequestPostCreateOrConnectWithoutRequestInquirysInput
    upsert?: RequestPostUpsertWithoutRequestInquirysInput
    connect?: RequestPostWhereUniqueInput
    update?: XOR<RequestPostUpdateWithoutRequestInquirysInput, RequestPostUncheckedUpdateWithoutRequestInquirysInput>
  }

  export type CreatorUpdateOneWithoutRequestInquiriesNestedInput = {
    create?: XOR<CreatorCreateWithoutRequestInquiriesInput, CreatorUncheckedCreateWithoutRequestInquiriesInput>
    connectOrCreate?: CreatorCreateOrConnectWithoutRequestInquiriesInput
    upsert?: CreatorUpsertWithoutRequestInquiriesInput
    disconnect?: boolean
    delete?: boolean
    connect?: CreatorWhereUniqueInput
    update?: XOR<CreatorUpdateWithoutRequestInquiriesInput, CreatorUncheckedUpdateWithoutRequestInquiriesInput>
  }

  export type UserUpdateOneWithoutRequestInquiriesNestedInput = {
    create?: XOR<UserCreateWithoutRequestInquiriesInput, UserUncheckedCreateWithoutRequestInquiriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRequestInquiriesInput
    upsert?: UserUpsertWithoutRequestInquiriesInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutRequestInquiriesInput, UserUncheckedUpdateWithoutRequestInquiriesInput>
  }

  export type RequestInquiryMessageUpdateManyWithoutRoomNestedInput = {
    create?: XOR<Enumerable<RequestInquiryMessageCreateWithoutRoomInput>, Enumerable<RequestInquiryMessageUncheckedCreateWithoutRoomInput>>
    connectOrCreate?: Enumerable<RequestInquiryMessageCreateOrConnectWithoutRoomInput>
    upsert?: Enumerable<RequestInquiryMessageUpsertWithWhereUniqueWithoutRoomInput>
    createMany?: RequestInquiryMessageCreateManyRoomInputEnvelope
    set?: Enumerable<RequestInquiryMessageWhereUniqueInput>
    disconnect?: Enumerable<RequestInquiryMessageWhereUniqueInput>
    delete?: Enumerable<RequestInquiryMessageWhereUniqueInput>
    connect?: Enumerable<RequestInquiryMessageWhereUniqueInput>
    update?: Enumerable<RequestInquiryMessageUpdateWithWhereUniqueWithoutRoomInput>
    updateMany?: Enumerable<RequestInquiryMessageUpdateManyWithWhereWithoutRoomInput>
    deleteMany?: Enumerable<RequestInquiryMessageScalarWhereInput>
  }

  export type RequestInquiryMessageUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<Enumerable<RequestInquiryMessageCreateWithoutRoomInput>, Enumerable<RequestInquiryMessageUncheckedCreateWithoutRoomInput>>
    connectOrCreate?: Enumerable<RequestInquiryMessageCreateOrConnectWithoutRoomInput>
    upsert?: Enumerable<RequestInquiryMessageUpsertWithWhereUniqueWithoutRoomInput>
    createMany?: RequestInquiryMessageCreateManyRoomInputEnvelope
    set?: Enumerable<RequestInquiryMessageWhereUniqueInput>
    disconnect?: Enumerable<RequestInquiryMessageWhereUniqueInput>
    delete?: Enumerable<RequestInquiryMessageWhereUniqueInput>
    connect?: Enumerable<RequestInquiryMessageWhereUniqueInput>
    update?: Enumerable<RequestInquiryMessageUpdateWithWhereUniqueWithoutRoomInput>
    updateMany?: Enumerable<RequestInquiryMessageUpdateManyWithWhereWithoutRoomInput>
    deleteMany?: Enumerable<RequestInquiryMessageScalarWhereInput>
  }

  export type RequestInquiryCreateNestedOneWithoutRequestInquiryMessagesInput = {
    create?: XOR<RequestInquiryCreateWithoutRequestInquiryMessagesInput, RequestInquiryUncheckedCreateWithoutRequestInquiryMessagesInput>
    connectOrCreate?: RequestInquiryCreateOrConnectWithoutRequestInquiryMessagesInput
    connect?: RequestInquiryWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRequestinquiryMessagesInput = {
    create?: XOR<UserCreateWithoutRequestinquiryMessagesInput, UserUncheckedCreateWithoutRequestinquiryMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRequestinquiryMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type RequestInquiryUpdateOneRequiredWithoutRequestInquiryMessagesNestedInput = {
    create?: XOR<RequestInquiryCreateWithoutRequestInquiryMessagesInput, RequestInquiryUncheckedCreateWithoutRequestInquiryMessagesInput>
    connectOrCreate?: RequestInquiryCreateOrConnectWithoutRequestInquiryMessagesInput
    upsert?: RequestInquiryUpsertWithoutRequestInquiryMessagesInput
    connect?: RequestInquiryWhereUniqueInput
    update?: XOR<RequestInquiryUpdateWithoutRequestInquiryMessagesInput, RequestInquiryUncheckedUpdateWithoutRequestInquiryMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutRequestinquiryMessagesNestedInput = {
    create?: XOR<UserCreateWithoutRequestinquiryMessagesInput, UserUncheckedCreateWithoutRequestinquiryMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRequestinquiryMessagesInput
    upsert?: UserUpsertWithoutRequestinquiryMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutRequestinquiryMessagesInput, UserUncheckedUpdateWithoutRequestinquiryMessagesInput>
  }

  export type EnumMessageTypeFieldUpdateOperationsInput = {
    set?: MessageType
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type UserCreateNestedOneWithoutPointsInput = {
    create?: XOR<UserCreateWithoutPointsInput, UserUncheckedCreateWithoutPointsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPointsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPointsNestedInput = {
    create?: XOR<UserCreateWithoutPointsInput, UserUncheckedCreateWithoutPointsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPointsInput
    upsert?: UserUpsertWithoutPointsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutPointsInput, UserUncheckedUpdateWithoutPointsInput>
  }

  export type EnumPoinTypeFieldUpdateOperationsInput = {
    set?: PoinType
  }

  export type UserCreateNestedOneWithoutRankingsInput = {
    create?: XOR<UserCreateWithoutRankingsInput, UserUncheckedCreateWithoutRankingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRankingsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutRankingsNestedInput = {
    create?: XOR<UserCreateWithoutRankingsInput, UserUncheckedCreateWithoutRankingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRankingsInput
    upsert?: UserUpsertWithoutRankingsInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutRankingsInput, UserUncheckedUpdateWithoutRankingsInput>
  }

  export type EnumRankingTypeFieldUpdateOperationsInput = {
    set?: RankingType
  }

  export type EnumFaqTypeFieldUpdateOperationsInput = {
    set?: FaqType
  }

  export type UserCreateNestedOneWithoutCreatorInput = {
    create?: XOR<UserCreateWithoutCreatorInput, UserUncheckedCreateWithoutCreatorInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatorInput
    connect?: UserWhereUniqueInput
  }

  export type RequestPostCreateNestedManyWithoutCreatorInput = {
    create?: XOR<Enumerable<RequestPostCreateWithoutCreatorInput>, Enumerable<RequestPostUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<RequestPostCreateOrConnectWithoutCreatorInput>
    createMany?: RequestPostCreateManyCreatorInputEnvelope
    connect?: Enumerable<RequestPostWhereUniqueInput>
  }

  export type RequestApplyCreatorCreateNestedManyWithoutCreatorInput = {
    create?: XOR<Enumerable<RequestApplyCreatorCreateWithoutCreatorInput>, Enumerable<RequestApplyCreatorUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<RequestApplyCreatorCreateOrConnectWithoutCreatorInput>
    createMany?: RequestApplyCreatorCreateManyCreatorInputEnvelope
    connect?: Enumerable<RequestApplyCreatorWhereUniqueInput>
  }

  export type RequestInquiryCreateNestedManyWithoutCreatorInput = {
    create?: XOR<Enumerable<RequestInquiryCreateWithoutCreatorInput>, Enumerable<RequestInquiryUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<RequestInquiryCreateOrConnectWithoutCreatorInput>
    createMany?: RequestInquiryCreateManyCreatorInputEnvelope
    connect?: Enumerable<RequestInquiryWhereUniqueInput>
  }

  export type CreatorAuthCreateNestedManyWithoutCreatorInput = {
    create?: XOR<Enumerable<CreatorAuthCreateWithoutCreatorInput>, Enumerable<CreatorAuthUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<CreatorAuthCreateOrConnectWithoutCreatorInput>
    createMany?: CreatorAuthCreateManyCreatorInputEnvelope
    connect?: Enumerable<CreatorAuthWhereUniqueInput>
  }

  export type CreatorReviewCreateNestedManyWithoutCreatorInput = {
    create?: XOR<Enumerable<CreatorReviewCreateWithoutCreatorInput>, Enumerable<CreatorReviewUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<CreatorReviewCreateOrConnectWithoutCreatorInput>
    createMany?: CreatorReviewCreateManyCreatorInputEnvelope
    connect?: Enumerable<CreatorReviewWhereUniqueInput>
  }

  export type RequestPostUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<Enumerable<RequestPostCreateWithoutCreatorInput>, Enumerable<RequestPostUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<RequestPostCreateOrConnectWithoutCreatorInput>
    createMany?: RequestPostCreateManyCreatorInputEnvelope
    connect?: Enumerable<RequestPostWhereUniqueInput>
  }

  export type RequestApplyCreatorUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<Enumerable<RequestApplyCreatorCreateWithoutCreatorInput>, Enumerable<RequestApplyCreatorUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<RequestApplyCreatorCreateOrConnectWithoutCreatorInput>
    createMany?: RequestApplyCreatorCreateManyCreatorInputEnvelope
    connect?: Enumerable<RequestApplyCreatorWhereUniqueInput>
  }

  export type RequestInquiryUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<Enumerable<RequestInquiryCreateWithoutCreatorInput>, Enumerable<RequestInquiryUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<RequestInquiryCreateOrConnectWithoutCreatorInput>
    createMany?: RequestInquiryCreateManyCreatorInputEnvelope
    connect?: Enumerable<RequestInquiryWhereUniqueInput>
  }

  export type CreatorAuthUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<Enumerable<CreatorAuthCreateWithoutCreatorInput>, Enumerable<CreatorAuthUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<CreatorAuthCreateOrConnectWithoutCreatorInput>
    createMany?: CreatorAuthCreateManyCreatorInputEnvelope
    connect?: Enumerable<CreatorAuthWhereUniqueInput>
  }

  export type CreatorReviewUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<Enumerable<CreatorReviewCreateWithoutCreatorInput>, Enumerable<CreatorReviewUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<CreatorReviewCreateOrConnectWithoutCreatorInput>
    createMany?: CreatorReviewCreateManyCreatorInputEnvelope
    connect?: Enumerable<CreatorReviewWhereUniqueInput>
  }

  export type UserUpdateOneRequiredWithoutCreatorNestedInput = {
    create?: XOR<UserCreateWithoutCreatorInput, UserUncheckedCreateWithoutCreatorInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatorInput
    upsert?: UserUpsertWithoutCreatorInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutCreatorInput, UserUncheckedUpdateWithoutCreatorInput>
  }

  export type RequestPostUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<Enumerable<RequestPostCreateWithoutCreatorInput>, Enumerable<RequestPostUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<RequestPostCreateOrConnectWithoutCreatorInput>
    upsert?: Enumerable<RequestPostUpsertWithWhereUniqueWithoutCreatorInput>
    createMany?: RequestPostCreateManyCreatorInputEnvelope
    set?: Enumerable<RequestPostWhereUniqueInput>
    disconnect?: Enumerable<RequestPostWhereUniqueInput>
    delete?: Enumerable<RequestPostWhereUniqueInput>
    connect?: Enumerable<RequestPostWhereUniqueInput>
    update?: Enumerable<RequestPostUpdateWithWhereUniqueWithoutCreatorInput>
    updateMany?: Enumerable<RequestPostUpdateManyWithWhereWithoutCreatorInput>
    deleteMany?: Enumerable<RequestPostScalarWhereInput>
  }

  export type RequestApplyCreatorUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<Enumerable<RequestApplyCreatorCreateWithoutCreatorInput>, Enumerable<RequestApplyCreatorUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<RequestApplyCreatorCreateOrConnectWithoutCreatorInput>
    upsert?: Enumerable<RequestApplyCreatorUpsertWithWhereUniqueWithoutCreatorInput>
    createMany?: RequestApplyCreatorCreateManyCreatorInputEnvelope
    set?: Enumerable<RequestApplyCreatorWhereUniqueInput>
    disconnect?: Enumerable<RequestApplyCreatorWhereUniqueInput>
    delete?: Enumerable<RequestApplyCreatorWhereUniqueInput>
    connect?: Enumerable<RequestApplyCreatorWhereUniqueInput>
    update?: Enumerable<RequestApplyCreatorUpdateWithWhereUniqueWithoutCreatorInput>
    updateMany?: Enumerable<RequestApplyCreatorUpdateManyWithWhereWithoutCreatorInput>
    deleteMany?: Enumerable<RequestApplyCreatorScalarWhereInput>
  }

  export type RequestInquiryUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<Enumerable<RequestInquiryCreateWithoutCreatorInput>, Enumerable<RequestInquiryUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<RequestInquiryCreateOrConnectWithoutCreatorInput>
    upsert?: Enumerable<RequestInquiryUpsertWithWhereUniqueWithoutCreatorInput>
    createMany?: RequestInquiryCreateManyCreatorInputEnvelope
    set?: Enumerable<RequestInquiryWhereUniqueInput>
    disconnect?: Enumerable<RequestInquiryWhereUniqueInput>
    delete?: Enumerable<RequestInquiryWhereUniqueInput>
    connect?: Enumerable<RequestInquiryWhereUniqueInput>
    update?: Enumerable<RequestInquiryUpdateWithWhereUniqueWithoutCreatorInput>
    updateMany?: Enumerable<RequestInquiryUpdateManyWithWhereWithoutCreatorInput>
    deleteMany?: Enumerable<RequestInquiryScalarWhereInput>
  }

  export type CreatorAuthUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<Enumerable<CreatorAuthCreateWithoutCreatorInput>, Enumerable<CreatorAuthUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<CreatorAuthCreateOrConnectWithoutCreatorInput>
    upsert?: Enumerable<CreatorAuthUpsertWithWhereUniqueWithoutCreatorInput>
    createMany?: CreatorAuthCreateManyCreatorInputEnvelope
    set?: Enumerable<CreatorAuthWhereUniqueInput>
    disconnect?: Enumerable<CreatorAuthWhereUniqueInput>
    delete?: Enumerable<CreatorAuthWhereUniqueInput>
    connect?: Enumerable<CreatorAuthWhereUniqueInput>
    update?: Enumerable<CreatorAuthUpdateWithWhereUniqueWithoutCreatorInput>
    updateMany?: Enumerable<CreatorAuthUpdateManyWithWhereWithoutCreatorInput>
    deleteMany?: Enumerable<CreatorAuthScalarWhereInput>
  }

  export type CreatorReviewUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<Enumerable<CreatorReviewCreateWithoutCreatorInput>, Enumerable<CreatorReviewUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<CreatorReviewCreateOrConnectWithoutCreatorInput>
    upsert?: Enumerable<CreatorReviewUpsertWithWhereUniqueWithoutCreatorInput>
    createMany?: CreatorReviewCreateManyCreatorInputEnvelope
    set?: Enumerable<CreatorReviewWhereUniqueInput>
    disconnect?: Enumerable<CreatorReviewWhereUniqueInput>
    delete?: Enumerable<CreatorReviewWhereUniqueInput>
    connect?: Enumerable<CreatorReviewWhereUniqueInput>
    update?: Enumerable<CreatorReviewUpdateWithWhereUniqueWithoutCreatorInput>
    updateMany?: Enumerable<CreatorReviewUpdateManyWithWhereWithoutCreatorInput>
    deleteMany?: Enumerable<CreatorReviewScalarWhereInput>
  }

  export type RequestPostUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<Enumerable<RequestPostCreateWithoutCreatorInput>, Enumerable<RequestPostUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<RequestPostCreateOrConnectWithoutCreatorInput>
    upsert?: Enumerable<RequestPostUpsertWithWhereUniqueWithoutCreatorInput>
    createMany?: RequestPostCreateManyCreatorInputEnvelope
    set?: Enumerable<RequestPostWhereUniqueInput>
    disconnect?: Enumerable<RequestPostWhereUniqueInput>
    delete?: Enumerable<RequestPostWhereUniqueInput>
    connect?: Enumerable<RequestPostWhereUniqueInput>
    update?: Enumerable<RequestPostUpdateWithWhereUniqueWithoutCreatorInput>
    updateMany?: Enumerable<RequestPostUpdateManyWithWhereWithoutCreatorInput>
    deleteMany?: Enumerable<RequestPostScalarWhereInput>
  }

  export type RequestApplyCreatorUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<Enumerable<RequestApplyCreatorCreateWithoutCreatorInput>, Enumerable<RequestApplyCreatorUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<RequestApplyCreatorCreateOrConnectWithoutCreatorInput>
    upsert?: Enumerable<RequestApplyCreatorUpsertWithWhereUniqueWithoutCreatorInput>
    createMany?: RequestApplyCreatorCreateManyCreatorInputEnvelope
    set?: Enumerable<RequestApplyCreatorWhereUniqueInput>
    disconnect?: Enumerable<RequestApplyCreatorWhereUniqueInput>
    delete?: Enumerable<RequestApplyCreatorWhereUniqueInput>
    connect?: Enumerable<RequestApplyCreatorWhereUniqueInput>
    update?: Enumerable<RequestApplyCreatorUpdateWithWhereUniqueWithoutCreatorInput>
    updateMany?: Enumerable<RequestApplyCreatorUpdateManyWithWhereWithoutCreatorInput>
    deleteMany?: Enumerable<RequestApplyCreatorScalarWhereInput>
  }

  export type RequestInquiryUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<Enumerable<RequestInquiryCreateWithoutCreatorInput>, Enumerable<RequestInquiryUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<RequestInquiryCreateOrConnectWithoutCreatorInput>
    upsert?: Enumerable<RequestInquiryUpsertWithWhereUniqueWithoutCreatorInput>
    createMany?: RequestInquiryCreateManyCreatorInputEnvelope
    set?: Enumerable<RequestInquiryWhereUniqueInput>
    disconnect?: Enumerable<RequestInquiryWhereUniqueInput>
    delete?: Enumerable<RequestInquiryWhereUniqueInput>
    connect?: Enumerable<RequestInquiryWhereUniqueInput>
    update?: Enumerable<RequestInquiryUpdateWithWhereUniqueWithoutCreatorInput>
    updateMany?: Enumerable<RequestInquiryUpdateManyWithWhereWithoutCreatorInput>
    deleteMany?: Enumerable<RequestInquiryScalarWhereInput>
  }

  export type CreatorAuthUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<Enumerable<CreatorAuthCreateWithoutCreatorInput>, Enumerable<CreatorAuthUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<CreatorAuthCreateOrConnectWithoutCreatorInput>
    upsert?: Enumerable<CreatorAuthUpsertWithWhereUniqueWithoutCreatorInput>
    createMany?: CreatorAuthCreateManyCreatorInputEnvelope
    set?: Enumerable<CreatorAuthWhereUniqueInput>
    disconnect?: Enumerable<CreatorAuthWhereUniqueInput>
    delete?: Enumerable<CreatorAuthWhereUniqueInput>
    connect?: Enumerable<CreatorAuthWhereUniqueInput>
    update?: Enumerable<CreatorAuthUpdateWithWhereUniqueWithoutCreatorInput>
    updateMany?: Enumerable<CreatorAuthUpdateManyWithWhereWithoutCreatorInput>
    deleteMany?: Enumerable<CreatorAuthScalarWhereInput>
  }

  export type CreatorReviewUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<Enumerable<CreatorReviewCreateWithoutCreatorInput>, Enumerable<CreatorReviewUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<CreatorReviewCreateOrConnectWithoutCreatorInput>
    upsert?: Enumerable<CreatorReviewUpsertWithWhereUniqueWithoutCreatorInput>
    createMany?: CreatorReviewCreateManyCreatorInputEnvelope
    set?: Enumerable<CreatorReviewWhereUniqueInput>
    disconnect?: Enumerable<CreatorReviewWhereUniqueInput>
    delete?: Enumerable<CreatorReviewWhereUniqueInput>
    connect?: Enumerable<CreatorReviewWhereUniqueInput>
    update?: Enumerable<CreatorReviewUpdateWithWhereUniqueWithoutCreatorInput>
    updateMany?: Enumerable<CreatorReviewUpdateManyWithWhereWithoutCreatorInput>
    deleteMany?: Enumerable<CreatorReviewScalarWhereInput>
  }

  export type CreatorCreateNestedOneWithoutCreatorAuthsInput = {
    create?: XOR<CreatorCreateWithoutCreatorAuthsInput, CreatorUncheckedCreateWithoutCreatorAuthsInput>
    connectOrCreate?: CreatorCreateOrConnectWithoutCreatorAuthsInput
    connect?: CreatorWhereUniqueInput
  }

  export type CreatorUpdateOneRequiredWithoutCreatorAuthsNestedInput = {
    create?: XOR<CreatorCreateWithoutCreatorAuthsInput, CreatorUncheckedCreateWithoutCreatorAuthsInput>
    connectOrCreate?: CreatorCreateOrConnectWithoutCreatorAuthsInput
    upsert?: CreatorUpsertWithoutCreatorAuthsInput
    connect?: CreatorWhereUniqueInput
    update?: XOR<CreatorUpdateWithoutCreatorAuthsInput, CreatorUncheckedUpdateWithoutCreatorAuthsInput>
  }

  export type EnumAuthPlatformTypeFieldUpdateOperationsInput = {
    set?: AuthPlatformType
  }

  export type CreatorCreateNestedOneWithoutCreatorReviewsInput = {
    create?: XOR<CreatorCreateWithoutCreatorReviewsInput, CreatorUncheckedCreateWithoutCreatorReviewsInput>
    connectOrCreate?: CreatorCreateOrConnectWithoutCreatorReviewsInput
    connect?: CreatorWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatorReviewsInput = {
    create?: XOR<UserCreateWithoutCreatorReviewsInput, UserUncheckedCreateWithoutCreatorReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatorReviewsInput
    connect?: UserWhereUniqueInput
  }

  export type CreatorReviewItemCreateNestedManyWithoutReviewInput = {
    create?: XOR<Enumerable<CreatorReviewItemCreateWithoutReviewInput>, Enumerable<CreatorReviewItemUncheckedCreateWithoutReviewInput>>
    connectOrCreate?: Enumerable<CreatorReviewItemCreateOrConnectWithoutReviewInput>
    createMany?: CreatorReviewItemCreateManyReviewInputEnvelope
    connect?: Enumerable<CreatorReviewItemWhereUniqueInput>
  }

  export type CreatorReviewItemUncheckedCreateNestedManyWithoutReviewInput = {
    create?: XOR<Enumerable<CreatorReviewItemCreateWithoutReviewInput>, Enumerable<CreatorReviewItemUncheckedCreateWithoutReviewInput>>
    connectOrCreate?: Enumerable<CreatorReviewItemCreateOrConnectWithoutReviewInput>
    createMany?: CreatorReviewItemCreateManyReviewInputEnvelope
    connect?: Enumerable<CreatorReviewItemWhereUniqueInput>
  }

  export type CreatorUpdateOneRequiredWithoutCreatorReviewsNestedInput = {
    create?: XOR<CreatorCreateWithoutCreatorReviewsInput, CreatorUncheckedCreateWithoutCreatorReviewsInput>
    connectOrCreate?: CreatorCreateOrConnectWithoutCreatorReviewsInput
    upsert?: CreatorUpsertWithoutCreatorReviewsInput
    connect?: CreatorWhereUniqueInput
    update?: XOR<CreatorUpdateWithoutCreatorReviewsInput, CreatorUncheckedUpdateWithoutCreatorReviewsInput>
  }

  export type UserUpdateOneWithoutCreatorReviewsNestedInput = {
    create?: XOR<UserCreateWithoutCreatorReviewsInput, UserUncheckedCreateWithoutCreatorReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatorReviewsInput
    upsert?: UserUpsertWithoutCreatorReviewsInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutCreatorReviewsInput, UserUncheckedUpdateWithoutCreatorReviewsInput>
  }

  export type CreatorReviewItemUpdateManyWithoutReviewNestedInput = {
    create?: XOR<Enumerable<CreatorReviewItemCreateWithoutReviewInput>, Enumerable<CreatorReviewItemUncheckedCreateWithoutReviewInput>>
    connectOrCreate?: Enumerable<CreatorReviewItemCreateOrConnectWithoutReviewInput>
    upsert?: Enumerable<CreatorReviewItemUpsertWithWhereUniqueWithoutReviewInput>
    createMany?: CreatorReviewItemCreateManyReviewInputEnvelope
    set?: Enumerable<CreatorReviewItemWhereUniqueInput>
    disconnect?: Enumerable<CreatorReviewItemWhereUniqueInput>
    delete?: Enumerable<CreatorReviewItemWhereUniqueInput>
    connect?: Enumerable<CreatorReviewItemWhereUniqueInput>
    update?: Enumerable<CreatorReviewItemUpdateWithWhereUniqueWithoutReviewInput>
    updateMany?: Enumerable<CreatorReviewItemUpdateManyWithWhereWithoutReviewInput>
    deleteMany?: Enumerable<CreatorReviewItemScalarWhereInput>
  }

  export type CreatorReviewItemUncheckedUpdateManyWithoutReviewNestedInput = {
    create?: XOR<Enumerable<CreatorReviewItemCreateWithoutReviewInput>, Enumerable<CreatorReviewItemUncheckedCreateWithoutReviewInput>>
    connectOrCreate?: Enumerable<CreatorReviewItemCreateOrConnectWithoutReviewInput>
    upsert?: Enumerable<CreatorReviewItemUpsertWithWhereUniqueWithoutReviewInput>
    createMany?: CreatorReviewItemCreateManyReviewInputEnvelope
    set?: Enumerable<CreatorReviewItemWhereUniqueInput>
    disconnect?: Enumerable<CreatorReviewItemWhereUniqueInput>
    delete?: Enumerable<CreatorReviewItemWhereUniqueInput>
    connect?: Enumerable<CreatorReviewItemWhereUniqueInput>
    update?: Enumerable<CreatorReviewItemUpdateWithWhereUniqueWithoutReviewInput>
    updateMany?: Enumerable<CreatorReviewItemUpdateManyWithWhereWithoutReviewInput>
    deleteMany?: Enumerable<CreatorReviewItemScalarWhereInput>
  }

  export type CreatorReviewCreateNestedOneWithoutReviewItemsInput = {
    create?: XOR<CreatorReviewCreateWithoutReviewItemsInput, CreatorReviewUncheckedCreateWithoutReviewItemsInput>
    connectOrCreate?: CreatorReviewCreateOrConnectWithoutReviewItemsInput
    connect?: CreatorReviewWhereUniqueInput
  }

  export type CreatorReviewUpdateOneRequiredWithoutReviewItemsNestedInput = {
    create?: XOR<CreatorReviewCreateWithoutReviewItemsInput, CreatorReviewUncheckedCreateWithoutReviewItemsInput>
    connectOrCreate?: CreatorReviewCreateOrConnectWithoutReviewItemsInput
    upsert?: CreatorReviewUpsertWithoutReviewItemsInput
    connect?: CreatorReviewWhereUniqueInput
    update?: XOR<CreatorReviewUpdateWithoutReviewItemsInput, CreatorReviewUncheckedUpdateWithoutReviewItemsInput>
  }

  export type UserCreateNestedOneWithoutLogInput = {
    create?: XOR<UserCreateWithoutLogInput, UserUncheckedCreateWithoutLogInput>
    connectOrCreate?: UserCreateOrConnectWithoutLogInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutLogsInput = {
    create?: XOR<Enumerable<UserCreateWithoutLogsInput>, Enumerable<UserUncheckedCreateWithoutLogsInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutLogsInput>
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type RequestPostCreateNestedOneWithoutLogInput = {
    create?: XOR<RequestPostCreateWithoutLogInput, RequestPostUncheckedCreateWithoutLogInput>
    connectOrCreate?: RequestPostCreateOrConnectWithoutLogInput
    connect?: RequestPostWhereUniqueInput
  }

  export type UserUncheckedCreateNestedManyWithoutLogsInput = {
    create?: XOR<Enumerable<UserCreateWithoutLogsInput>, Enumerable<UserUncheckedCreateWithoutLogsInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutLogsInput>
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type EnumLogTypeFieldUpdateOperationsInput = {
    set?: LogType
  }

  export type UserUpdateOneWithoutLogNestedInput = {
    create?: XOR<UserCreateWithoutLogInput, UserUncheckedCreateWithoutLogInput>
    connectOrCreate?: UserCreateOrConnectWithoutLogInput
    upsert?: UserUpsertWithoutLogInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutLogInput, UserUncheckedUpdateWithoutLogInput>
  }

  export type UserUpdateManyWithoutLogsNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutLogsInput>, Enumerable<UserUncheckedCreateWithoutLogsInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutLogsInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutLogsInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutLogsInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutLogsInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type RequestPostUpdateOneWithoutLogNestedInput = {
    create?: XOR<RequestPostCreateWithoutLogInput, RequestPostUncheckedCreateWithoutLogInput>
    connectOrCreate?: RequestPostCreateOrConnectWithoutLogInput
    upsert?: RequestPostUpsertWithoutLogInput
    disconnect?: boolean
    delete?: boolean
    connect?: RequestPostWhereUniqueInput
    update?: XOR<RequestPostUpdateWithoutLogInput, RequestPostUncheckedUpdateWithoutLogInput>
  }

  export type UserUncheckedUpdateManyWithoutLogsNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutLogsInput>, Enumerable<UserUncheckedCreateWithoutLogsInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutLogsInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutLogsInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutLogsInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutLogsInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedBigIntFilter = {
    equals?: bigint | number
    in?: Enumerable<bigint> | Enumerable<number>
    notIn?: Enumerable<bigint> | Enumerable<number>
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntFilter | bigint | number
  }

  export type NestedEnumRequestCategoryTypeNullableFilter = {
    equals?: RequestCategoryType | null
    in?: Enumerable<RequestCategoryType> | null
    notIn?: Enumerable<RequestCategoryType> | null
    not?: NestedEnumRequestCategoryTypeNullableFilter | RequestCategoryType | null
  }

  export type NestedBigIntNullableFilter = {
    equals?: bigint | number | null
    in?: Enumerable<bigint> | Enumerable<number> | null
    notIn?: Enumerable<bigint> | Enumerable<number> | null
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntNullableFilter | bigint | number | null
  }

  export type NestedEnumRequestStatusTypeFilter = {
    equals?: RequestStatusType
    in?: Enumerable<RequestStatusType>
    notIn?: Enumerable<RequestStatusType>
    not?: NestedEnumRequestStatusTypeFilter | RequestStatusType
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedBigIntWithAggregatesFilter = {
    equals?: bigint | number
    in?: Enumerable<bigint> | Enumerable<number>
    notIn?: Enumerable<bigint> | Enumerable<number>
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntWithAggregatesFilter | bigint | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedBigIntFilter
    _min?: NestedBigIntFilter
    _max?: NestedBigIntFilter
  }

  export type NestedEnumRequestCategoryTypeNullableWithAggregatesFilter = {
    equals?: RequestCategoryType | null
    in?: Enumerable<RequestCategoryType> | null
    notIn?: Enumerable<RequestCategoryType> | null
    not?: NestedEnumRequestCategoryTypeNullableWithAggregatesFilter | RequestCategoryType | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumRequestCategoryTypeNullableFilter
    _max?: NestedEnumRequestCategoryTypeNullableFilter
  }

  export type NestedBigIntNullableWithAggregatesFilter = {
    equals?: bigint | number | null
    in?: Enumerable<bigint> | Enumerable<number> | null
    notIn?: Enumerable<bigint> | Enumerable<number> | null
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntNullableWithAggregatesFilter | bigint | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedBigIntNullableFilter
    _min?: NestedBigIntNullableFilter
    _max?: NestedBigIntNullableFilter
  }

  export type NestedEnumRequestStatusTypeWithAggregatesFilter = {
    equals?: RequestStatusType
    in?: Enumerable<RequestStatusType>
    notIn?: Enumerable<RequestStatusType>
    not?: NestedEnumRequestStatusTypeWithAggregatesFilter | RequestStatusType
    _count?: NestedIntFilter
    _min?: NestedEnumRequestStatusTypeFilter
    _max?: NestedEnumRequestStatusTypeFilter
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedEnumRequestFundingStatusFilter = {
    equals?: RequestFundingStatus
    in?: Enumerable<RequestFundingStatus>
    notIn?: Enumerable<RequestFundingStatus>
    not?: NestedEnumRequestFundingStatusFilter | RequestFundingStatus
  }

  export type NestedEnumRequestFundingStatusWithAggregatesFilter = {
    equals?: RequestFundingStatus
    in?: Enumerable<RequestFundingStatus>
    notIn?: Enumerable<RequestFundingStatus>
    not?: NestedEnumRequestFundingStatusWithAggregatesFilter | RequestFundingStatus
    _count?: NestedIntFilter
    _min?: NestedEnumRequestFundingStatusFilter
    _max?: NestedEnumRequestFundingStatusFilter
  }

  export type NestedEnumReactionTypeFilter = {
    equals?: ReactionType
    in?: Enumerable<ReactionType>
    notIn?: Enumerable<ReactionType>
    not?: NestedEnumReactionTypeFilter | ReactionType
  }

  export type NestedEnumReactionTypeWithAggregatesFilter = {
    equals?: ReactionType
    in?: Enumerable<ReactionType>
    notIn?: Enumerable<ReactionType>
    not?: NestedEnumReactionTypeWithAggregatesFilter | ReactionType
    _count?: NestedIntFilter
    _min?: NestedEnumReactionTypeFilter
    _max?: NestedEnumReactionTypeFilter
  }

  export type NestedEnumRequestPlatformTypeFilter = {
    equals?: RequestPlatformType
    in?: Enumerable<RequestPlatformType>
    notIn?: Enumerable<RequestPlatformType>
    not?: NestedEnumRequestPlatformTypeFilter | RequestPlatformType
  }

  export type NestedEnumRequestPlatformTypeWithAggregatesFilter = {
    equals?: RequestPlatformType
    in?: Enumerable<RequestPlatformType>
    notIn?: Enumerable<RequestPlatformType>
    not?: NestedEnumRequestPlatformTypeWithAggregatesFilter | RequestPlatformType
    _count?: NestedIntFilter
    _min?: NestedEnumRequestPlatformTypeFilter
    _max?: NestedEnumRequestPlatformTypeFilter
  }

  export type NestedEnumRequestReportTypeFilter = {
    equals?: RequestReportType
    in?: Enumerable<RequestReportType>
    notIn?: Enumerable<RequestReportType>
    not?: NestedEnumRequestReportTypeFilter | RequestReportType
  }

  export type NestedEnumRequestReportStatusFilter = {
    equals?: RequestReportStatus
    in?: Enumerable<RequestReportStatus>
    notIn?: Enumerable<RequestReportStatus>
    not?: NestedEnumRequestReportStatusFilter | RequestReportStatus
  }

  export type NestedEnumRequestReportTypeWithAggregatesFilter = {
    equals?: RequestReportType
    in?: Enumerable<RequestReportType>
    notIn?: Enumerable<RequestReportType>
    not?: NestedEnumRequestReportTypeWithAggregatesFilter | RequestReportType
    _count?: NestedIntFilter
    _min?: NestedEnumRequestReportTypeFilter
    _max?: NestedEnumRequestReportTypeFilter
  }

  export type NestedEnumRequestReportStatusWithAggregatesFilter = {
    equals?: RequestReportStatus
    in?: Enumerable<RequestReportStatus>
    notIn?: Enumerable<RequestReportStatus>
    not?: NestedEnumRequestReportStatusWithAggregatesFilter | RequestReportStatus
    _count?: NestedIntFilter
    _min?: NestedEnumRequestReportStatusFilter
    _max?: NestedEnumRequestReportStatusFilter
  }

  export type NestedEnumMessageTypeFilter = {
    equals?: MessageType
    in?: Enumerable<MessageType>
    notIn?: Enumerable<MessageType>
    not?: NestedEnumMessageTypeFilter | MessageType
  }

  export type NestedBoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type NestedEnumMessageTypeWithAggregatesFilter = {
    equals?: MessageType
    in?: Enumerable<MessageType>
    notIn?: Enumerable<MessageType>
    not?: NestedEnumMessageTypeWithAggregatesFilter | MessageType
    _count?: NestedIntFilter
    _min?: NestedEnumMessageTypeFilter
    _max?: NestedEnumMessageTypeFilter
  }

  export type NestedBoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type NestedEnumPoinTypeFilter = {
    equals?: PoinType
    in?: Enumerable<PoinType>
    notIn?: Enumerable<PoinType>
    not?: NestedEnumPoinTypeFilter | PoinType
  }

  export type NestedEnumPoinTypeWithAggregatesFilter = {
    equals?: PoinType
    in?: Enumerable<PoinType>
    notIn?: Enumerable<PoinType>
    not?: NestedEnumPoinTypeWithAggregatesFilter | PoinType
    _count?: NestedIntFilter
    _min?: NestedEnumPoinTypeFilter
    _max?: NestedEnumPoinTypeFilter
  }

  export type NestedEnumRankingTypeFilter = {
    equals?: RankingType
    in?: Enumerable<RankingType>
    notIn?: Enumerable<RankingType>
    not?: NestedEnumRankingTypeFilter | RankingType
  }

  export type NestedEnumRankingTypeWithAggregatesFilter = {
    equals?: RankingType
    in?: Enumerable<RankingType>
    notIn?: Enumerable<RankingType>
    not?: NestedEnumRankingTypeWithAggregatesFilter | RankingType
    _count?: NestedIntFilter
    _min?: NestedEnumRankingTypeFilter
    _max?: NestedEnumRankingTypeFilter
  }

  export type NestedEnumFaqTypeFilter = {
    equals?: FaqType
    in?: Enumerable<FaqType>
    notIn?: Enumerable<FaqType>
    not?: NestedEnumFaqTypeFilter | FaqType
  }

  export type NestedEnumFaqTypeWithAggregatesFilter = {
    equals?: FaqType
    in?: Enumerable<FaqType>
    notIn?: Enumerable<FaqType>
    not?: NestedEnumFaqTypeWithAggregatesFilter | FaqType
    _count?: NestedIntFilter
    _min?: NestedEnumFaqTypeFilter
    _max?: NestedEnumFaqTypeFilter
  }

  export type NestedEnumAuthPlatformTypeFilter = {
    equals?: AuthPlatformType
    in?: Enumerable<AuthPlatformType>
    notIn?: Enumerable<AuthPlatformType>
    not?: NestedEnumAuthPlatformTypeFilter | AuthPlatformType
  }

  export type NestedEnumAuthPlatformTypeWithAggregatesFilter = {
    equals?: AuthPlatformType
    in?: Enumerable<AuthPlatformType>
    notIn?: Enumerable<AuthPlatformType>
    not?: NestedEnumAuthPlatformTypeWithAggregatesFilter | AuthPlatformType
    _count?: NestedIntFilter
    _min?: NestedEnumAuthPlatformTypeFilter
    _max?: NestedEnumAuthPlatformTypeFilter
  }

  export type NestedEnumLogTypeFilter = {
    equals?: LogType
    in?: Enumerable<LogType>
    notIn?: Enumerable<LogType>
    not?: NestedEnumLogTypeFilter | LogType
  }

  export type NestedEnumLogTypeWithAggregatesFilter = {
    equals?: LogType
    in?: Enumerable<LogType>
    notIn?: Enumerable<LogType>
    not?: NestedEnumLogTypeWithAggregatesFilter | LogType
    _count?: NestedIntFilter
    _min?: NestedEnumLogTypeFilter
    _max?: NestedEnumLogTypeFilter
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    introduction?: string | null
    totalPoint?: number
    sessions?: SessionCreateNestedManyWithoutUserInput
    requestPosts?: RequestPostCreateNestedManyWithoutUserInput
    requestFundings?: RequestFundingCreateNestedManyWithoutUserInput
    requestComments?: RequestCommentCreateNestedManyWithoutUserInput
    requestReactions?: RequestReactionCreateNestedManyWithoutUserInput
    requestBookmarks?: RequestBookmarkCreateNestedManyWithoutUserInput
    requestReports?: RequestReportCreateNestedManyWithoutUserInput
    requestInquiries?: RequestInquiryCreateNestedManyWithoutUserInput
    requestinquiryMessages?: RequestInquiryMessageCreateNestedManyWithoutFromInput
    requestCommentHearts?: RequestCommentHeartCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutReceiverInput
    points?: PointCreateNestedManyWithoutUserInput
    rankings?: RankingCreateNestedManyWithoutUserInput
    creatorReviews?: CreatorReviewCreateNestedManyWithoutUserInput
    creator?: CreatorCreateNestedOneWithoutUserInput
    Log?: LogCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    introduction?: string | null
    totalPoint?: number
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    requestPosts?: RequestPostUncheckedCreateNestedManyWithoutUserInput
    requestFundings?: RequestFundingUncheckedCreateNestedManyWithoutUserInput
    requestComments?: RequestCommentUncheckedCreateNestedManyWithoutUserInput
    requestReactions?: RequestReactionUncheckedCreateNestedManyWithoutUserInput
    requestBookmarks?: RequestBookmarkUncheckedCreateNestedManyWithoutUserInput
    requestReports?: RequestReportUncheckedCreateNestedManyWithoutUserInput
    requestInquiries?: RequestInquiryUncheckedCreateNestedManyWithoutUserInput
    requestinquiryMessages?: RequestInquiryMessageUncheckedCreateNestedManyWithoutFromInput
    requestCommentHearts?: RequestCommentHeartUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutReceiverInput
    points?: PointUncheckedCreateNestedManyWithoutUserInput
    rankings?: RankingUncheckedCreateNestedManyWithoutUserInput
    creatorReviews?: CreatorReviewUncheckedCreateNestedManyWithoutUserInput
    creator?: CreatorUncheckedCreateNestedOneWithoutUserInput
    Log?: LogUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoint?: IntFieldUpdateOperationsInput | number
    sessions?: SessionUpdateManyWithoutUserNestedInput
    requestPosts?: RequestPostUpdateManyWithoutUserNestedInput
    requestFundings?: RequestFundingUpdateManyWithoutUserNestedInput
    requestComments?: RequestCommentUpdateManyWithoutUserNestedInput
    requestReactions?: RequestReactionUpdateManyWithoutUserNestedInput
    requestBookmarks?: RequestBookmarkUpdateManyWithoutUserNestedInput
    requestReports?: RequestReportUpdateManyWithoutUserNestedInput
    requestInquiries?: RequestInquiryUpdateManyWithoutUserNestedInput
    requestinquiryMessages?: RequestInquiryMessageUpdateManyWithoutFromNestedInput
    requestCommentHearts?: RequestCommentHeartUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutReceiverNestedInput
    points?: PointUpdateManyWithoutUserNestedInput
    rankings?: RankingUpdateManyWithoutUserNestedInput
    creatorReviews?: CreatorReviewUpdateManyWithoutUserNestedInput
    creator?: CreatorUpdateOneWithoutUserNestedInput
    Log?: LogUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoint?: IntFieldUpdateOperationsInput | number
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    requestPosts?: RequestPostUncheckedUpdateManyWithoutUserNestedInput
    requestFundings?: RequestFundingUncheckedUpdateManyWithoutUserNestedInput
    requestComments?: RequestCommentUncheckedUpdateManyWithoutUserNestedInput
    requestReactions?: RequestReactionUncheckedUpdateManyWithoutUserNestedInput
    requestBookmarks?: RequestBookmarkUncheckedUpdateManyWithoutUserNestedInput
    requestReports?: RequestReportUncheckedUpdateManyWithoutUserNestedInput
    requestInquiries?: RequestInquiryUncheckedUpdateManyWithoutUserNestedInput
    requestinquiryMessages?: RequestInquiryMessageUncheckedUpdateManyWithoutFromNestedInput
    requestCommentHearts?: RequestCommentHeartUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutReceiverNestedInput
    points?: PointUncheckedUpdateManyWithoutUserNestedInput
    rankings?: RankingUncheckedUpdateManyWithoutUserNestedInput
    creatorReviews?: CreatorReviewUncheckedUpdateManyWithoutUserNestedInput
    creator?: CreatorUncheckedUpdateOneWithoutUserNestedInput
    Log?: LogUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    introduction?: string | null
    totalPoint?: number
    accounts?: AccountCreateNestedManyWithoutUserInput
    requestPosts?: RequestPostCreateNestedManyWithoutUserInput
    requestFundings?: RequestFundingCreateNestedManyWithoutUserInput
    requestComments?: RequestCommentCreateNestedManyWithoutUserInput
    requestReactions?: RequestReactionCreateNestedManyWithoutUserInput
    requestBookmarks?: RequestBookmarkCreateNestedManyWithoutUserInput
    requestReports?: RequestReportCreateNestedManyWithoutUserInput
    requestInquiries?: RequestInquiryCreateNestedManyWithoutUserInput
    requestinquiryMessages?: RequestInquiryMessageCreateNestedManyWithoutFromInput
    requestCommentHearts?: RequestCommentHeartCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutReceiverInput
    points?: PointCreateNestedManyWithoutUserInput
    rankings?: RankingCreateNestedManyWithoutUserInput
    creatorReviews?: CreatorReviewCreateNestedManyWithoutUserInput
    creator?: CreatorCreateNestedOneWithoutUserInput
    Log?: LogCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    introduction?: string | null
    totalPoint?: number
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    requestPosts?: RequestPostUncheckedCreateNestedManyWithoutUserInput
    requestFundings?: RequestFundingUncheckedCreateNestedManyWithoutUserInput
    requestComments?: RequestCommentUncheckedCreateNestedManyWithoutUserInput
    requestReactions?: RequestReactionUncheckedCreateNestedManyWithoutUserInput
    requestBookmarks?: RequestBookmarkUncheckedCreateNestedManyWithoutUserInput
    requestReports?: RequestReportUncheckedCreateNestedManyWithoutUserInput
    requestInquiries?: RequestInquiryUncheckedCreateNestedManyWithoutUserInput
    requestinquiryMessages?: RequestInquiryMessageUncheckedCreateNestedManyWithoutFromInput
    requestCommentHearts?: RequestCommentHeartUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutReceiverInput
    points?: PointUncheckedCreateNestedManyWithoutUserInput
    rankings?: RankingUncheckedCreateNestedManyWithoutUserInput
    creatorReviews?: CreatorReviewUncheckedCreateNestedManyWithoutUserInput
    creator?: CreatorUncheckedCreateNestedOneWithoutUserInput
    Log?: LogUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoint?: IntFieldUpdateOperationsInput | number
    accounts?: AccountUpdateManyWithoutUserNestedInput
    requestPosts?: RequestPostUpdateManyWithoutUserNestedInput
    requestFundings?: RequestFundingUpdateManyWithoutUserNestedInput
    requestComments?: RequestCommentUpdateManyWithoutUserNestedInput
    requestReactions?: RequestReactionUpdateManyWithoutUserNestedInput
    requestBookmarks?: RequestBookmarkUpdateManyWithoutUserNestedInput
    requestReports?: RequestReportUpdateManyWithoutUserNestedInput
    requestInquiries?: RequestInquiryUpdateManyWithoutUserNestedInput
    requestinquiryMessages?: RequestInquiryMessageUpdateManyWithoutFromNestedInput
    requestCommentHearts?: RequestCommentHeartUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutReceiverNestedInput
    points?: PointUpdateManyWithoutUserNestedInput
    rankings?: RankingUpdateManyWithoutUserNestedInput
    creatorReviews?: CreatorReviewUpdateManyWithoutUserNestedInput
    creator?: CreatorUpdateOneWithoutUserNestedInput
    Log?: LogUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoint?: IntFieldUpdateOperationsInput | number
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    requestPosts?: RequestPostUncheckedUpdateManyWithoutUserNestedInput
    requestFundings?: RequestFundingUncheckedUpdateManyWithoutUserNestedInput
    requestComments?: RequestCommentUncheckedUpdateManyWithoutUserNestedInput
    requestReactions?: RequestReactionUncheckedUpdateManyWithoutUserNestedInput
    requestBookmarks?: RequestBookmarkUncheckedUpdateManyWithoutUserNestedInput
    requestReports?: RequestReportUncheckedUpdateManyWithoutUserNestedInput
    requestInquiries?: RequestInquiryUncheckedUpdateManyWithoutUserNestedInput
    requestinquiryMessages?: RequestInquiryMessageUncheckedUpdateManyWithoutFromNestedInput
    requestCommentHearts?: RequestCommentHeartUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutReceiverNestedInput
    points?: PointUncheckedUpdateManyWithoutUserNestedInput
    rankings?: RankingUncheckedUpdateManyWithoutUserNestedInput
    creatorReviews?: CreatorReviewUncheckedUpdateManyWithoutUserNestedInput
    creator?: CreatorUncheckedUpdateOneWithoutUserNestedInput
    Log?: LogUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: Enumerable<AccountCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: Enumerable<SessionCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type RequestPostCreateWithoutUserInput = {
    id?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    content: string
    creator?: CreatorCreateNestedOneWithoutRequestPostsInput
    category?: RequestCategoryType | null
    expires?: Date | string | null
    totalViews?: number
    status?: RequestStatusType
    solvedUrl?: string | null
    thumbnailUrl?: string | null
    refusalReason?: string | null
    totalQuantity?: number
    totalLikeScroe?: number
    isUnspecified?: boolean
    requestFundings?: RequestFundingCreateNestedManyWithoutRequestInput
    requestReactions?: RequestReactionCreateNestedManyWithoutRequestInput
    requestApplyCreators?: RequestApplyCreatorCreateNestedManyWithoutRequestInput
    requestPlatforms?: RequestPlatformCreateNestedManyWithoutRequestInput
    requestComments?: RequestCommentCreateNestedManyWithoutRequestInput
    requestBookmarks?: RequestBookmarkCreateNestedManyWithoutRequestInput
    requestReports?: RequestReportCreateNestedManyWithoutRequestInput
    requestInquirys?: RequestInquiryCreateNestedManyWithoutRequestInput
    Log?: LogCreateNestedManyWithoutRequestInput
  }

  export type RequestPostUncheckedCreateWithoutUserInput = {
    id?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    content: string
    category?: RequestCategoryType | null
    creatorId?: bigint | number | null
    expires?: Date | string | null
    totalViews?: number
    status?: RequestStatusType
    solvedUrl?: string | null
    thumbnailUrl?: string | null
    refusalReason?: string | null
    totalQuantity?: number
    totalLikeScroe?: number
    isUnspecified?: boolean
    requestFundings?: RequestFundingUncheckedCreateNestedManyWithoutRequestInput
    requestReactions?: RequestReactionUncheckedCreateNestedManyWithoutRequestInput
    requestApplyCreators?: RequestApplyCreatorUncheckedCreateNestedManyWithoutRequestInput
    requestPlatforms?: RequestPlatformUncheckedCreateNestedManyWithoutRequestInput
    requestComments?: RequestCommentUncheckedCreateNestedManyWithoutRequestInput
    requestBookmarks?: RequestBookmarkUncheckedCreateNestedManyWithoutRequestInput
    requestReports?: RequestReportUncheckedCreateNestedManyWithoutRequestInput
    requestInquirys?: RequestInquiryUncheckedCreateNestedManyWithoutRequestInput
    Log?: LogUncheckedCreateNestedManyWithoutRequestInput
  }

  export type RequestPostCreateOrConnectWithoutUserInput = {
    where: RequestPostWhereUniqueInput
    create: XOR<RequestPostCreateWithoutUserInput, RequestPostUncheckedCreateWithoutUserInput>
  }

  export type RequestPostCreateManyUserInputEnvelope = {
    data: Enumerable<RequestPostCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type RequestFundingCreateWithoutUserInput = {
    id?: bigint | number
    quantity: number
    request?: RequestPostCreateNestedOneWithoutRequestFundingsInput
    createdAt?: Date | string
    status?: RequestFundingStatus
  }

  export type RequestFundingUncheckedCreateWithoutUserInput = {
    id?: bigint | number
    quantity: number
    requestId?: bigint | number | null
    createdAt?: Date | string
    status?: RequestFundingStatus
  }

  export type RequestFundingCreateOrConnectWithoutUserInput = {
    where: RequestFundingWhereUniqueInput
    create: XOR<RequestFundingCreateWithoutUserInput, RequestFundingUncheckedCreateWithoutUserInput>
  }

  export type RequestFundingCreateManyUserInputEnvelope = {
    data: Enumerable<RequestFundingCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type RequestCommentCreateWithoutUserInput = {
    id?: bigint | number
    request: RequestPostCreateNestedOneWithoutRequestCommentsInput
    parentComment?: RequestCommentCreateNestedOneWithoutChildrenCommentsInput
    rootId?: bigint | number | null
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    hearts?: RequestCommentHeartCreateNestedManyWithoutRequestCommentInput
    childrenComments?: RequestCommentCreateNestedManyWithoutParentCommentInput
  }

  export type RequestCommentUncheckedCreateWithoutUserInput = {
    id?: bigint | number
    requestId: bigint | number
    parentId?: bigint | number | null
    rootId?: bigint | number | null
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    hearts?: RequestCommentHeartUncheckedCreateNestedManyWithoutRequestCommentInput
    childrenComments?: RequestCommentUncheckedCreateNestedManyWithoutParentCommentInput
  }

  export type RequestCommentCreateOrConnectWithoutUserInput = {
    where: RequestCommentWhereUniqueInput
    create: XOR<RequestCommentCreateWithoutUserInput, RequestCommentUncheckedCreateWithoutUserInput>
  }

  export type RequestCommentCreateManyUserInputEnvelope = {
    data: Enumerable<RequestCommentCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type RequestReactionCreateWithoutUserInput = {
    id?: bigint | number
    type: ReactionType
    request: RequestPostCreateNestedOneWithoutRequestReactionsInput
    createdAt?: Date | string
  }

  export type RequestReactionUncheckedCreateWithoutUserInput = {
    id?: bigint | number
    type: ReactionType
    requestId: bigint | number
    createdAt?: Date | string
  }

  export type RequestReactionCreateOrConnectWithoutUserInput = {
    where: RequestReactionWhereUniqueInput
    create: XOR<RequestReactionCreateWithoutUserInput, RequestReactionUncheckedCreateWithoutUserInput>
  }

  export type RequestReactionCreateManyUserInputEnvelope = {
    data: Enumerable<RequestReactionCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type RequestBookmarkCreateWithoutUserInput = {
    id?: bigint | number
    request?: RequestPostCreateNestedOneWithoutRequestBookmarksInput
    createdAt?: Date | string
  }

  export type RequestBookmarkUncheckedCreateWithoutUserInput = {
    id?: bigint | number
    requestId?: bigint | number | null
    createdAt?: Date | string
  }

  export type RequestBookmarkCreateOrConnectWithoutUserInput = {
    where: RequestBookmarkWhereUniqueInput
    create: XOR<RequestBookmarkCreateWithoutUserInput, RequestBookmarkUncheckedCreateWithoutUserInput>
  }

  export type RequestBookmarkCreateManyUserInputEnvelope = {
    data: Enumerable<RequestBookmarkCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type RequestReportCreateWithoutUserInput = {
    id?: bigint | number
    request: RequestPostCreateNestedOneWithoutRequestReportsInput
    content: string
    type: RequestReportType
    status: RequestReportStatus
    createdAt?: Date | string
  }

  export type RequestReportUncheckedCreateWithoutUserInput = {
    id?: bigint | number
    requestId: bigint | number
    content: string
    type: RequestReportType
    status: RequestReportStatus
    createdAt?: Date | string
  }

  export type RequestReportCreateOrConnectWithoutUserInput = {
    where: RequestReportWhereUniqueInput
    create: XOR<RequestReportCreateWithoutUserInput, RequestReportUncheckedCreateWithoutUserInput>
  }

  export type RequestReportCreateManyUserInputEnvelope = {
    data: Enumerable<RequestReportCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type RequestInquiryCreateWithoutUserInput = {
    id?: bigint | number
    request: RequestPostCreateNestedOneWithoutRequestInquirysInput
    creator?: CreatorCreateNestedOneWithoutRequestInquiriesInput
    requestInquiryMessages?: RequestInquiryMessageCreateNestedManyWithoutRoomInput
    createdAt?: Date | string
  }

  export type RequestInquiryUncheckedCreateWithoutUserInput = {
    id?: bigint | number
    requestId: bigint | number
    creatorId?: bigint | number | null
    requestInquiryMessages?: RequestInquiryMessageUncheckedCreateNestedManyWithoutRoomInput
    createdAt?: Date | string
  }

  export type RequestInquiryCreateOrConnectWithoutUserInput = {
    where: RequestInquiryWhereUniqueInput
    create: XOR<RequestInquiryCreateWithoutUserInput, RequestInquiryUncheckedCreateWithoutUserInput>
  }

  export type RequestInquiryCreateManyUserInputEnvelope = {
    data: Enumerable<RequestInquiryCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type RequestInquiryMessageCreateWithoutFromInput = {
    id?: bigint | number
    room: RequestInquiryCreateNestedOneWithoutRequestInquiryMessagesInput
    text: string
    fileUrl?: string | null
    type?: MessageType
    isRead?: boolean | null
    createdAt?: Date | string
  }

  export type RequestInquiryMessageUncheckedCreateWithoutFromInput = {
    id?: bigint | number
    roomId: bigint | number
    text: string
    fileUrl?: string | null
    type?: MessageType
    isRead?: boolean | null
    createdAt?: Date | string
  }

  export type RequestInquiryMessageCreateOrConnectWithoutFromInput = {
    where: RequestInquiryMessageWhereUniqueInput
    create: XOR<RequestInquiryMessageCreateWithoutFromInput, RequestInquiryMessageUncheckedCreateWithoutFromInput>
  }

  export type RequestInquiryMessageCreateManyFromInputEnvelope = {
    data: Enumerable<RequestInquiryMessageCreateManyFromInput>
    skipDuplicates?: boolean
  }

  export type RequestCommentHeartCreateWithoutUserInput = {
    id?: bigint | number
    requestComment: RequestCommentCreateNestedOneWithoutHeartsInput
    createdAt?: Date | string
  }

  export type RequestCommentHeartUncheckedCreateWithoutUserInput = {
    id?: bigint | number
    requestCommentId: bigint | number
    createdAt?: Date | string
  }

  export type RequestCommentHeartCreateOrConnectWithoutUserInput = {
    where: RequestCommentHeartWhereUniqueInput
    create: XOR<RequestCommentHeartCreateWithoutUserInput, RequestCommentHeartUncheckedCreateWithoutUserInput>
  }

  export type RequestCommentHeartCreateManyUserInputEnvelope = {
    data: Enumerable<RequestCommentHeartCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type LogCreateWithoutReceiverInput = {
    id?: bigint | number
    logType: LogType
    message?: string | null
    sender?: UserCreateNestedOneWithoutLogInput
    isRead?: boolean | null
    request?: RequestPostCreateNestedOneWithoutLogInput
    createdAt?: Date | string
  }

  export type LogUncheckedCreateWithoutReceiverInput = {
    id?: bigint | number
    logType: LogType
    message?: string | null
    senderId?: string | null
    isRead?: boolean | null
    requestId?: bigint | number | null
    createdAt?: Date | string
  }

  export type LogCreateOrConnectWithoutReceiverInput = {
    where: LogWhereUniqueInput
    create: XOR<LogCreateWithoutReceiverInput, LogUncheckedCreateWithoutReceiverInput>
  }

  export type PointCreateWithoutUserInput = {
    id?: bigint | number
    quantity: number
    type: PoinType
    createdAt?: Date | string
  }

  export type PointUncheckedCreateWithoutUserInput = {
    id?: bigint | number
    quantity: number
    type: PoinType
    createdAt?: Date | string
  }

  export type PointCreateOrConnectWithoutUserInput = {
    where: PointWhereUniqueInput
    create: XOR<PointCreateWithoutUserInput, PointUncheckedCreateWithoutUserInput>
  }

  export type PointCreateManyUserInputEnvelope = {
    data: Enumerable<PointCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type RankingCreateWithoutUserInput = {
    ranking: number
    type: RankingType
    score: bigint | number
    change: number
    createdAt?: Date | string
  }

  export type RankingUncheckedCreateWithoutUserInput = {
    id?: number
    ranking: number
    type: RankingType
    score: bigint | number
    change: number
    createdAt?: Date | string
  }

  export type RankingCreateOrConnectWithoutUserInput = {
    where: RankingWhereUniqueInput
    create: XOR<RankingCreateWithoutUserInput, RankingUncheckedCreateWithoutUserInput>
  }

  export type RankingCreateManyUserInputEnvelope = {
    data: Enumerable<RankingCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type CreatorReviewCreateWithoutUserInput = {
    id?: bigint | number
    creator: CreatorCreateNestedOneWithoutCreatorReviewsInput
    reviewItems?: CreatorReviewItemCreateNestedManyWithoutReviewInput
    content?: string | null
    createdAt?: Date | string
  }

  export type CreatorReviewUncheckedCreateWithoutUserInput = {
    id?: bigint | number
    creatorId: bigint | number
    reviewItems?: CreatorReviewItemUncheckedCreateNestedManyWithoutReviewInput
    content?: string | null
    createdAt?: Date | string
  }

  export type CreatorReviewCreateOrConnectWithoutUserInput = {
    where: CreatorReviewWhereUniqueInput
    create: XOR<CreatorReviewCreateWithoutUserInput, CreatorReviewUncheckedCreateWithoutUserInput>
  }

  export type CreatorReviewCreateManyUserInputEnvelope = {
    data: Enumerable<CreatorReviewCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type CreatorCreateWithoutUserInput = {
    id?: bigint | number
    createdAt?: Date | string
    requestPosts?: RequestPostCreateNestedManyWithoutCreatorInput
    requestApplyCreators?: RequestApplyCreatorCreateNestedManyWithoutCreatorInput
    requestInquiries?: RequestInquiryCreateNestedManyWithoutCreatorInput
    creatorAuths?: CreatorAuthCreateNestedManyWithoutCreatorInput
    creatorReviews?: CreatorReviewCreateNestedManyWithoutCreatorInput
  }

  export type CreatorUncheckedCreateWithoutUserInput = {
    id?: bigint | number
    createdAt?: Date | string
    requestPosts?: RequestPostUncheckedCreateNestedManyWithoutCreatorInput
    requestApplyCreators?: RequestApplyCreatorUncheckedCreateNestedManyWithoutCreatorInput
    requestInquiries?: RequestInquiryUncheckedCreateNestedManyWithoutCreatorInput
    creatorAuths?: CreatorAuthUncheckedCreateNestedManyWithoutCreatorInput
    creatorReviews?: CreatorReviewUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type CreatorCreateOrConnectWithoutUserInput = {
    where: CreatorWhereUniqueInput
    create: XOR<CreatorCreateWithoutUserInput, CreatorUncheckedCreateWithoutUserInput>
  }

  export type LogCreateWithoutSenderInput = {
    id?: bigint | number
    logType: LogType
    message?: string | null
    isRead?: boolean | null
    receiver?: UserCreateNestedManyWithoutLogsInput
    request?: RequestPostCreateNestedOneWithoutLogInput
    createdAt?: Date | string
  }

  export type LogUncheckedCreateWithoutSenderInput = {
    id?: bigint | number
    logType: LogType
    message?: string | null
    isRead?: boolean | null
    receiver?: UserUncheckedCreateNestedManyWithoutLogsInput
    requestId?: bigint | number | null
    createdAt?: Date | string
  }

  export type LogCreateOrConnectWithoutSenderInput = {
    where: LogWhereUniqueInput
    create: XOR<LogCreateWithoutSenderInput, LogUncheckedCreateWithoutSenderInput>
  }

  export type LogCreateManySenderInputEnvelope = {
    data: Enumerable<LogCreateManySenderInput>
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutAccountsInput>
  }

  export type AccountScalarWhereInput = {
    AND?: Enumerable<AccountScalarWhereInput>
    OR?: Enumerable<AccountScalarWhereInput>
    NOT?: Enumerable<AccountScalarWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    type?: StringFilter | string
    provider?: StringFilter | string
    providerAccountId?: StringFilter | string
    refresh_token?: StringNullableFilter | string | null
    access_token?: StringNullableFilter | string | null
    expires_at?: IntNullableFilter | number | null
    token_type?: StringNullableFilter | string | null
    scope?: StringNullableFilter | string | null
    id_token?: StringNullableFilter | string | null
    session_state?: StringNullableFilter | string | null
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutSessionsInput>
  }

  export type SessionScalarWhereInput = {
    AND?: Enumerable<SessionScalarWhereInput>
    OR?: Enumerable<SessionScalarWhereInput>
    NOT?: Enumerable<SessionScalarWhereInput>
    id?: StringFilter | string
    sessionToken?: StringFilter | string
    userId?: StringFilter | string
    expires?: DateTimeFilter | Date | string
  }

  export type RequestPostUpsertWithWhereUniqueWithoutUserInput = {
    where: RequestPostWhereUniqueInput
    update: XOR<RequestPostUpdateWithoutUserInput, RequestPostUncheckedUpdateWithoutUserInput>
    create: XOR<RequestPostCreateWithoutUserInput, RequestPostUncheckedCreateWithoutUserInput>
  }

  export type RequestPostUpdateWithWhereUniqueWithoutUserInput = {
    where: RequestPostWhereUniqueInput
    data: XOR<RequestPostUpdateWithoutUserInput, RequestPostUncheckedUpdateWithoutUserInput>
  }

  export type RequestPostUpdateManyWithWhereWithoutUserInput = {
    where: RequestPostScalarWhereInput
    data: XOR<RequestPostUpdateManyMutationInput, RequestPostUncheckedUpdateManyWithoutRequestPostsInput>
  }

  export type RequestPostScalarWhereInput = {
    AND?: Enumerable<RequestPostScalarWhereInput>
    OR?: Enumerable<RequestPostScalarWhereInput>
    NOT?: Enumerable<RequestPostScalarWhereInput>
    id?: BigIntFilter | bigint | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    userId?: StringNullableFilter | string | null
    title?: StringFilter | string
    content?: StringFilter | string
    category?: EnumRequestCategoryTypeNullableFilter | RequestCategoryType | null
    creatorId?: BigIntNullableFilter | bigint | number | null
    expires?: DateTimeNullableFilter | Date | string | null
    totalViews?: IntFilter | number
    status?: EnumRequestStatusTypeFilter | RequestStatusType
    solvedUrl?: StringNullableFilter | string | null
    thumbnailUrl?: StringNullableFilter | string | null
    refusalReason?: StringNullableFilter | string | null
    totalQuantity?: IntFilter | number
    totalLikeScroe?: IntFilter | number
    isUnspecified?: BoolFilter | boolean
  }

  export type RequestFundingUpsertWithWhereUniqueWithoutUserInput = {
    where: RequestFundingWhereUniqueInput
    update: XOR<RequestFundingUpdateWithoutUserInput, RequestFundingUncheckedUpdateWithoutUserInput>
    create: XOR<RequestFundingCreateWithoutUserInput, RequestFundingUncheckedCreateWithoutUserInput>
  }

  export type RequestFundingUpdateWithWhereUniqueWithoutUserInput = {
    where: RequestFundingWhereUniqueInput
    data: XOR<RequestFundingUpdateWithoutUserInput, RequestFundingUncheckedUpdateWithoutUserInput>
  }

  export type RequestFundingUpdateManyWithWhereWithoutUserInput = {
    where: RequestFundingScalarWhereInput
    data: XOR<RequestFundingUpdateManyMutationInput, RequestFundingUncheckedUpdateManyWithoutRequestFundingsInput>
  }

  export type RequestFundingScalarWhereInput = {
    AND?: Enumerable<RequestFundingScalarWhereInput>
    OR?: Enumerable<RequestFundingScalarWhereInput>
    NOT?: Enumerable<RequestFundingScalarWhereInput>
    id?: BigIntFilter | bigint | number
    userId?: StringNullableFilter | string | null
    quantity?: IntFilter | number
    requestId?: BigIntNullableFilter | bigint | number | null
    createdAt?: DateTimeFilter | Date | string
    status?: EnumRequestFundingStatusFilter | RequestFundingStatus
  }

  export type RequestCommentUpsertWithWhereUniqueWithoutUserInput = {
    where: RequestCommentWhereUniqueInput
    update: XOR<RequestCommentUpdateWithoutUserInput, RequestCommentUncheckedUpdateWithoutUserInput>
    create: XOR<RequestCommentCreateWithoutUserInput, RequestCommentUncheckedCreateWithoutUserInput>
  }

  export type RequestCommentUpdateWithWhereUniqueWithoutUserInput = {
    where: RequestCommentWhereUniqueInput
    data: XOR<RequestCommentUpdateWithoutUserInput, RequestCommentUncheckedUpdateWithoutUserInput>
  }

  export type RequestCommentUpdateManyWithWhereWithoutUserInput = {
    where: RequestCommentScalarWhereInput
    data: XOR<RequestCommentUpdateManyMutationInput, RequestCommentUncheckedUpdateManyWithoutRequestCommentsInput>
  }

  export type RequestCommentScalarWhereInput = {
    AND?: Enumerable<RequestCommentScalarWhereInput>
    OR?: Enumerable<RequestCommentScalarWhereInput>
    NOT?: Enumerable<RequestCommentScalarWhereInput>
    id?: BigIntFilter | bigint | number
    requestId?: BigIntFilter | bigint | number
    userId?: StringNullableFilter | string | null
    parentId?: BigIntNullableFilter | bigint | number | null
    rootId?: BigIntNullableFilter | bigint | number | null
    content?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type RequestReactionUpsertWithWhereUniqueWithoutUserInput = {
    where: RequestReactionWhereUniqueInput
    update: XOR<RequestReactionUpdateWithoutUserInput, RequestReactionUncheckedUpdateWithoutUserInput>
    create: XOR<RequestReactionCreateWithoutUserInput, RequestReactionUncheckedCreateWithoutUserInput>
  }

  export type RequestReactionUpdateWithWhereUniqueWithoutUserInput = {
    where: RequestReactionWhereUniqueInput
    data: XOR<RequestReactionUpdateWithoutUserInput, RequestReactionUncheckedUpdateWithoutUserInput>
  }

  export type RequestReactionUpdateManyWithWhereWithoutUserInput = {
    where: RequestReactionScalarWhereInput
    data: XOR<RequestReactionUpdateManyMutationInput, RequestReactionUncheckedUpdateManyWithoutRequestReactionsInput>
  }

  export type RequestReactionScalarWhereInput = {
    AND?: Enumerable<RequestReactionScalarWhereInput>
    OR?: Enumerable<RequestReactionScalarWhereInput>
    NOT?: Enumerable<RequestReactionScalarWhereInput>
    id?: BigIntFilter | bigint | number
    userId?: StringFilter | string
    type?: EnumReactionTypeFilter | ReactionType
    requestId?: BigIntFilter | bigint | number
    createdAt?: DateTimeFilter | Date | string
  }

  export type RequestBookmarkUpsertWithWhereUniqueWithoutUserInput = {
    where: RequestBookmarkWhereUniqueInput
    update: XOR<RequestBookmarkUpdateWithoutUserInput, RequestBookmarkUncheckedUpdateWithoutUserInput>
    create: XOR<RequestBookmarkCreateWithoutUserInput, RequestBookmarkUncheckedCreateWithoutUserInput>
  }

  export type RequestBookmarkUpdateWithWhereUniqueWithoutUserInput = {
    where: RequestBookmarkWhereUniqueInput
    data: XOR<RequestBookmarkUpdateWithoutUserInput, RequestBookmarkUncheckedUpdateWithoutUserInput>
  }

  export type RequestBookmarkUpdateManyWithWhereWithoutUserInput = {
    where: RequestBookmarkScalarWhereInput
    data: XOR<RequestBookmarkUpdateManyMutationInput, RequestBookmarkUncheckedUpdateManyWithoutRequestBookmarksInput>
  }

  export type RequestBookmarkScalarWhereInput = {
    AND?: Enumerable<RequestBookmarkScalarWhereInput>
    OR?: Enumerable<RequestBookmarkScalarWhereInput>
    NOT?: Enumerable<RequestBookmarkScalarWhereInput>
    id?: BigIntFilter | bigint | number
    requestId?: BigIntNullableFilter | bigint | number | null
    userId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
  }

  export type RequestReportUpsertWithWhereUniqueWithoutUserInput = {
    where: RequestReportWhereUniqueInput
    update: XOR<RequestReportUpdateWithoutUserInput, RequestReportUncheckedUpdateWithoutUserInput>
    create: XOR<RequestReportCreateWithoutUserInput, RequestReportUncheckedCreateWithoutUserInput>
  }

  export type RequestReportUpdateWithWhereUniqueWithoutUserInput = {
    where: RequestReportWhereUniqueInput
    data: XOR<RequestReportUpdateWithoutUserInput, RequestReportUncheckedUpdateWithoutUserInput>
  }

  export type RequestReportUpdateManyWithWhereWithoutUserInput = {
    where: RequestReportScalarWhereInput
    data: XOR<RequestReportUpdateManyMutationInput, RequestReportUncheckedUpdateManyWithoutRequestReportsInput>
  }

  export type RequestReportScalarWhereInput = {
    AND?: Enumerable<RequestReportScalarWhereInput>
    OR?: Enumerable<RequestReportScalarWhereInput>
    NOT?: Enumerable<RequestReportScalarWhereInput>
    id?: BigIntFilter | bigint | number
    requestId?: BigIntFilter | bigint | number
    userId?: StringNullableFilter | string | null
    content?: StringFilter | string
    type?: EnumRequestReportTypeFilter | RequestReportType
    status?: EnumRequestReportStatusFilter | RequestReportStatus
    createdAt?: DateTimeFilter | Date | string
  }

  export type RequestInquiryUpsertWithWhereUniqueWithoutUserInput = {
    where: RequestInquiryWhereUniqueInput
    update: XOR<RequestInquiryUpdateWithoutUserInput, RequestInquiryUncheckedUpdateWithoutUserInput>
    create: XOR<RequestInquiryCreateWithoutUserInput, RequestInquiryUncheckedCreateWithoutUserInput>
  }

  export type RequestInquiryUpdateWithWhereUniqueWithoutUserInput = {
    where: RequestInquiryWhereUniqueInput
    data: XOR<RequestInquiryUpdateWithoutUserInput, RequestInquiryUncheckedUpdateWithoutUserInput>
  }

  export type RequestInquiryUpdateManyWithWhereWithoutUserInput = {
    where: RequestInquiryScalarWhereInput
    data: XOR<RequestInquiryUpdateManyMutationInput, RequestInquiryUncheckedUpdateManyWithoutRequestInquiriesInput>
  }

  export type RequestInquiryScalarWhereInput = {
    AND?: Enumerable<RequestInquiryScalarWhereInput>
    OR?: Enumerable<RequestInquiryScalarWhereInput>
    NOT?: Enumerable<RequestInquiryScalarWhereInput>
    id?: BigIntFilter | bigint | number
    requestId?: BigIntFilter | bigint | number
    creatorId?: BigIntNullableFilter | bigint | number | null
    userId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
  }

  export type RequestInquiryMessageUpsertWithWhereUniqueWithoutFromInput = {
    where: RequestInquiryMessageWhereUniqueInput
    update: XOR<RequestInquiryMessageUpdateWithoutFromInput, RequestInquiryMessageUncheckedUpdateWithoutFromInput>
    create: XOR<RequestInquiryMessageCreateWithoutFromInput, RequestInquiryMessageUncheckedCreateWithoutFromInput>
  }

  export type RequestInquiryMessageUpdateWithWhereUniqueWithoutFromInput = {
    where: RequestInquiryMessageWhereUniqueInput
    data: XOR<RequestInquiryMessageUpdateWithoutFromInput, RequestInquiryMessageUncheckedUpdateWithoutFromInput>
  }

  export type RequestInquiryMessageUpdateManyWithWhereWithoutFromInput = {
    where: RequestInquiryMessageScalarWhereInput
    data: XOR<RequestInquiryMessageUpdateManyMutationInput, RequestInquiryMessageUncheckedUpdateManyWithoutRequestinquiryMessagesInput>
  }

  export type RequestInquiryMessageScalarWhereInput = {
    AND?: Enumerable<RequestInquiryMessageScalarWhereInput>
    OR?: Enumerable<RequestInquiryMessageScalarWhereInput>
    NOT?: Enumerable<RequestInquiryMessageScalarWhereInput>
    id?: BigIntFilter | bigint | number
    roomId?: BigIntFilter | bigint | number
    fromId?: StringFilter | string
    text?: StringFilter | string
    fileUrl?: StringNullableFilter | string | null
    type?: EnumMessageTypeFilter | MessageType
    isRead?: BoolNullableFilter | boolean | null
    createdAt?: DateTimeFilter | Date | string
  }

  export type RequestCommentHeartUpsertWithWhereUniqueWithoutUserInput = {
    where: RequestCommentHeartWhereUniqueInput
    update: XOR<RequestCommentHeartUpdateWithoutUserInput, RequestCommentHeartUncheckedUpdateWithoutUserInput>
    create: XOR<RequestCommentHeartCreateWithoutUserInput, RequestCommentHeartUncheckedCreateWithoutUserInput>
  }

  export type RequestCommentHeartUpdateWithWhereUniqueWithoutUserInput = {
    where: RequestCommentHeartWhereUniqueInput
    data: XOR<RequestCommentHeartUpdateWithoutUserInput, RequestCommentHeartUncheckedUpdateWithoutUserInput>
  }

  export type RequestCommentHeartUpdateManyWithWhereWithoutUserInput = {
    where: RequestCommentHeartScalarWhereInput
    data: XOR<RequestCommentHeartUpdateManyMutationInput, RequestCommentHeartUncheckedUpdateManyWithoutRequestCommentHeartsInput>
  }

  export type RequestCommentHeartScalarWhereInput = {
    AND?: Enumerable<RequestCommentHeartScalarWhereInput>
    OR?: Enumerable<RequestCommentHeartScalarWhereInput>
    NOT?: Enumerable<RequestCommentHeartScalarWhereInput>
    id?: BigIntFilter | bigint | number
    requestCommentId?: BigIntFilter | bigint | number
    userId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
  }

  export type LogUpsertWithWhereUniqueWithoutReceiverInput = {
    where: LogWhereUniqueInput
    update: XOR<LogUpdateWithoutReceiverInput, LogUncheckedUpdateWithoutReceiverInput>
    create: XOR<LogCreateWithoutReceiverInput, LogUncheckedCreateWithoutReceiverInput>
  }

  export type LogUpdateWithWhereUniqueWithoutReceiverInput = {
    where: LogWhereUniqueInput
    data: XOR<LogUpdateWithoutReceiverInput, LogUncheckedUpdateWithoutReceiverInput>
  }

  export type LogUpdateManyWithWhereWithoutReceiverInput = {
    where: LogScalarWhereInput
    data: XOR<LogUpdateManyMutationInput, LogUncheckedUpdateManyWithoutLogsInput>
  }

  export type LogScalarWhereInput = {
    AND?: Enumerable<LogScalarWhereInput>
    OR?: Enumerable<LogScalarWhereInput>
    NOT?: Enumerable<LogScalarWhereInput>
    id?: BigIntFilter | bigint | number
    logType?: EnumLogTypeFilter | LogType
    message?: StringNullableFilter | string | null
    senderId?: StringNullableFilter | string | null
    isRead?: BoolNullableFilter | boolean | null
    requestId?: BigIntNullableFilter | bigint | number | null
    createdAt?: DateTimeFilter | Date | string
  }

  export type PointUpsertWithWhereUniqueWithoutUserInput = {
    where: PointWhereUniqueInput
    update: XOR<PointUpdateWithoutUserInput, PointUncheckedUpdateWithoutUserInput>
    create: XOR<PointCreateWithoutUserInput, PointUncheckedCreateWithoutUserInput>
  }

  export type PointUpdateWithWhereUniqueWithoutUserInput = {
    where: PointWhereUniqueInput
    data: XOR<PointUpdateWithoutUserInput, PointUncheckedUpdateWithoutUserInput>
  }

  export type PointUpdateManyWithWhereWithoutUserInput = {
    where: PointScalarWhereInput
    data: XOR<PointUpdateManyMutationInput, PointUncheckedUpdateManyWithoutPointsInput>
  }

  export type PointScalarWhereInput = {
    AND?: Enumerable<PointScalarWhereInput>
    OR?: Enumerable<PointScalarWhereInput>
    NOT?: Enumerable<PointScalarWhereInput>
    id?: BigIntFilter | bigint | number
    userId?: StringFilter | string
    quantity?: IntFilter | number
    type?: EnumPoinTypeFilter | PoinType
    createdAt?: DateTimeFilter | Date | string
  }

  export type RankingUpsertWithWhereUniqueWithoutUserInput = {
    where: RankingWhereUniqueInput
    update: XOR<RankingUpdateWithoutUserInput, RankingUncheckedUpdateWithoutUserInput>
    create: XOR<RankingCreateWithoutUserInput, RankingUncheckedCreateWithoutUserInput>
  }

  export type RankingUpdateWithWhereUniqueWithoutUserInput = {
    where: RankingWhereUniqueInput
    data: XOR<RankingUpdateWithoutUserInput, RankingUncheckedUpdateWithoutUserInput>
  }

  export type RankingUpdateManyWithWhereWithoutUserInput = {
    where: RankingScalarWhereInput
    data: XOR<RankingUpdateManyMutationInput, RankingUncheckedUpdateManyWithoutRankingsInput>
  }

  export type RankingScalarWhereInput = {
    AND?: Enumerable<RankingScalarWhereInput>
    OR?: Enumerable<RankingScalarWhereInput>
    NOT?: Enumerable<RankingScalarWhereInput>
    id?: IntFilter | number
    userId?: StringNullableFilter | string | null
    ranking?: IntFilter | number
    type?: EnumRankingTypeFilter | RankingType
    score?: BigIntFilter | bigint | number
    change?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
  }

  export type CreatorReviewUpsertWithWhereUniqueWithoutUserInput = {
    where: CreatorReviewWhereUniqueInput
    update: XOR<CreatorReviewUpdateWithoutUserInput, CreatorReviewUncheckedUpdateWithoutUserInput>
    create: XOR<CreatorReviewCreateWithoutUserInput, CreatorReviewUncheckedCreateWithoutUserInput>
  }

  export type CreatorReviewUpdateWithWhereUniqueWithoutUserInput = {
    where: CreatorReviewWhereUniqueInput
    data: XOR<CreatorReviewUpdateWithoutUserInput, CreatorReviewUncheckedUpdateWithoutUserInput>
  }

  export type CreatorReviewUpdateManyWithWhereWithoutUserInput = {
    where: CreatorReviewScalarWhereInput
    data: XOR<CreatorReviewUpdateManyMutationInput, CreatorReviewUncheckedUpdateManyWithoutCreatorReviewsInput>
  }

  export type CreatorReviewScalarWhereInput = {
    AND?: Enumerable<CreatorReviewScalarWhereInput>
    OR?: Enumerable<CreatorReviewScalarWhereInput>
    NOT?: Enumerable<CreatorReviewScalarWhereInput>
    id?: BigIntFilter | bigint | number
    creatorId?: BigIntFilter | bigint | number
    userId?: StringNullableFilter | string | null
    content?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
  }

  export type CreatorUpsertWithoutUserInput = {
    update: XOR<CreatorUpdateWithoutUserInput, CreatorUncheckedUpdateWithoutUserInput>
    create: XOR<CreatorCreateWithoutUserInput, CreatorUncheckedCreateWithoutUserInput>
  }

  export type CreatorUpdateWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestPosts?: RequestPostUpdateManyWithoutCreatorNestedInput
    requestApplyCreators?: RequestApplyCreatorUpdateManyWithoutCreatorNestedInput
    requestInquiries?: RequestInquiryUpdateManyWithoutCreatorNestedInput
    creatorAuths?: CreatorAuthUpdateManyWithoutCreatorNestedInput
    creatorReviews?: CreatorReviewUpdateManyWithoutCreatorNestedInput
  }

  export type CreatorUncheckedUpdateWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestPosts?: RequestPostUncheckedUpdateManyWithoutCreatorNestedInput
    requestApplyCreators?: RequestApplyCreatorUncheckedUpdateManyWithoutCreatorNestedInput
    requestInquiries?: RequestInquiryUncheckedUpdateManyWithoutCreatorNestedInput
    creatorAuths?: CreatorAuthUncheckedUpdateManyWithoutCreatorNestedInput
    creatorReviews?: CreatorReviewUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type LogUpsertWithWhereUniqueWithoutSenderInput = {
    where: LogWhereUniqueInput
    update: XOR<LogUpdateWithoutSenderInput, LogUncheckedUpdateWithoutSenderInput>
    create: XOR<LogCreateWithoutSenderInput, LogUncheckedCreateWithoutSenderInput>
  }

  export type LogUpdateWithWhereUniqueWithoutSenderInput = {
    where: LogWhereUniqueInput
    data: XOR<LogUpdateWithoutSenderInput, LogUncheckedUpdateWithoutSenderInput>
  }

  export type LogUpdateManyWithWhereWithoutSenderInput = {
    where: LogScalarWhereInput
    data: XOR<LogUpdateManyMutationInput, LogUncheckedUpdateManyWithoutLogInput>
  }

  export type UserCreateWithoutRequestPostsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    introduction?: string | null
    totalPoint?: number
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    requestFundings?: RequestFundingCreateNestedManyWithoutUserInput
    requestComments?: RequestCommentCreateNestedManyWithoutUserInput
    requestReactions?: RequestReactionCreateNestedManyWithoutUserInput
    requestBookmarks?: RequestBookmarkCreateNestedManyWithoutUserInput
    requestReports?: RequestReportCreateNestedManyWithoutUserInput
    requestInquiries?: RequestInquiryCreateNestedManyWithoutUserInput
    requestinquiryMessages?: RequestInquiryMessageCreateNestedManyWithoutFromInput
    requestCommentHearts?: RequestCommentHeartCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutReceiverInput
    points?: PointCreateNestedManyWithoutUserInput
    rankings?: RankingCreateNestedManyWithoutUserInput
    creatorReviews?: CreatorReviewCreateNestedManyWithoutUserInput
    creator?: CreatorCreateNestedOneWithoutUserInput
    Log?: LogCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutRequestPostsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    introduction?: string | null
    totalPoint?: number
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    requestFundings?: RequestFundingUncheckedCreateNestedManyWithoutUserInput
    requestComments?: RequestCommentUncheckedCreateNestedManyWithoutUserInput
    requestReactions?: RequestReactionUncheckedCreateNestedManyWithoutUserInput
    requestBookmarks?: RequestBookmarkUncheckedCreateNestedManyWithoutUserInput
    requestReports?: RequestReportUncheckedCreateNestedManyWithoutUserInput
    requestInquiries?: RequestInquiryUncheckedCreateNestedManyWithoutUserInput
    requestinquiryMessages?: RequestInquiryMessageUncheckedCreateNestedManyWithoutFromInput
    requestCommentHearts?: RequestCommentHeartUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutReceiverInput
    points?: PointUncheckedCreateNestedManyWithoutUserInput
    rankings?: RankingUncheckedCreateNestedManyWithoutUserInput
    creatorReviews?: CreatorReviewUncheckedCreateNestedManyWithoutUserInput
    creator?: CreatorUncheckedCreateNestedOneWithoutUserInput
    Log?: LogUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutRequestPostsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRequestPostsInput, UserUncheckedCreateWithoutRequestPostsInput>
  }

  export type CreatorCreateWithoutRequestPostsInput = {
    id?: bigint | number
    user: UserCreateNestedOneWithoutCreatorInput
    createdAt?: Date | string
    requestApplyCreators?: RequestApplyCreatorCreateNestedManyWithoutCreatorInput
    requestInquiries?: RequestInquiryCreateNestedManyWithoutCreatorInput
    creatorAuths?: CreatorAuthCreateNestedManyWithoutCreatorInput
    creatorReviews?: CreatorReviewCreateNestedManyWithoutCreatorInput
  }

  export type CreatorUncheckedCreateWithoutRequestPostsInput = {
    id?: bigint | number
    userId: string
    createdAt?: Date | string
    requestApplyCreators?: RequestApplyCreatorUncheckedCreateNestedManyWithoutCreatorInput
    requestInquiries?: RequestInquiryUncheckedCreateNestedManyWithoutCreatorInput
    creatorAuths?: CreatorAuthUncheckedCreateNestedManyWithoutCreatorInput
    creatorReviews?: CreatorReviewUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type CreatorCreateOrConnectWithoutRequestPostsInput = {
    where: CreatorWhereUniqueInput
    create: XOR<CreatorCreateWithoutRequestPostsInput, CreatorUncheckedCreateWithoutRequestPostsInput>
  }

  export type RequestFundingCreateWithoutRequestInput = {
    id?: bigint | number
    user?: UserCreateNestedOneWithoutRequestFundingsInput
    quantity: number
    createdAt?: Date | string
    status?: RequestFundingStatus
  }

  export type RequestFundingUncheckedCreateWithoutRequestInput = {
    id?: bigint | number
    userId?: string | null
    quantity: number
    createdAt?: Date | string
    status?: RequestFundingStatus
  }

  export type RequestFundingCreateOrConnectWithoutRequestInput = {
    where: RequestFundingWhereUniqueInput
    create: XOR<RequestFundingCreateWithoutRequestInput, RequestFundingUncheckedCreateWithoutRequestInput>
  }

  export type RequestFundingCreateManyRequestInputEnvelope = {
    data: Enumerable<RequestFundingCreateManyRequestInput>
    skipDuplicates?: boolean
  }

  export type RequestReactionCreateWithoutRequestInput = {
    id?: bigint | number
    user: UserCreateNestedOneWithoutRequestReactionsInput
    type: ReactionType
    createdAt?: Date | string
  }

  export type RequestReactionUncheckedCreateWithoutRequestInput = {
    id?: bigint | number
    userId: string
    type: ReactionType
    createdAt?: Date | string
  }

  export type RequestReactionCreateOrConnectWithoutRequestInput = {
    where: RequestReactionWhereUniqueInput
    create: XOR<RequestReactionCreateWithoutRequestInput, RequestReactionUncheckedCreateWithoutRequestInput>
  }

  export type RequestReactionCreateManyRequestInputEnvelope = {
    data: Enumerable<RequestReactionCreateManyRequestInput>
    skipDuplicates?: boolean
  }

  export type RequestApplyCreatorCreateWithoutRequestInput = {
    id?: bigint | number
    creator?: CreatorCreateNestedOneWithoutRequestApplyCreatorsInput
  }

  export type RequestApplyCreatorUncheckedCreateWithoutRequestInput = {
    id?: bigint | number
    creatorId?: bigint | number | null
  }

  export type RequestApplyCreatorCreateOrConnectWithoutRequestInput = {
    where: RequestApplyCreatorWhereUniqueInput
    create: XOR<RequestApplyCreatorCreateWithoutRequestInput, RequestApplyCreatorUncheckedCreateWithoutRequestInput>
  }

  export type RequestApplyCreatorCreateManyRequestInputEnvelope = {
    data: Enumerable<RequestApplyCreatorCreateManyRequestInput>
    skipDuplicates?: boolean
  }

  export type RequestPlatformCreateWithoutRequestInput = {
    id?: bigint | number
    name: RequestPlatformType
  }

  export type RequestPlatformUncheckedCreateWithoutRequestInput = {
    id?: bigint | number
    name: RequestPlatformType
  }

  export type RequestPlatformCreateOrConnectWithoutRequestInput = {
    where: RequestPlatformWhereUniqueInput
    create: XOR<RequestPlatformCreateWithoutRequestInput, RequestPlatformUncheckedCreateWithoutRequestInput>
  }

  export type RequestPlatformCreateManyRequestInputEnvelope = {
    data: Enumerable<RequestPlatformCreateManyRequestInput>
    skipDuplicates?: boolean
  }

  export type RequestCommentCreateWithoutRequestInput = {
    id?: bigint | number
    user?: UserCreateNestedOneWithoutRequestCommentsInput
    parentComment?: RequestCommentCreateNestedOneWithoutChildrenCommentsInput
    rootId?: bigint | number | null
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    hearts?: RequestCommentHeartCreateNestedManyWithoutRequestCommentInput
    childrenComments?: RequestCommentCreateNestedManyWithoutParentCommentInput
  }

  export type RequestCommentUncheckedCreateWithoutRequestInput = {
    id?: bigint | number
    userId?: string | null
    parentId?: bigint | number | null
    rootId?: bigint | number | null
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    hearts?: RequestCommentHeartUncheckedCreateNestedManyWithoutRequestCommentInput
    childrenComments?: RequestCommentUncheckedCreateNestedManyWithoutParentCommentInput
  }

  export type RequestCommentCreateOrConnectWithoutRequestInput = {
    where: RequestCommentWhereUniqueInput
    create: XOR<RequestCommentCreateWithoutRequestInput, RequestCommentUncheckedCreateWithoutRequestInput>
  }

  export type RequestCommentCreateManyRequestInputEnvelope = {
    data: Enumerable<RequestCommentCreateManyRequestInput>
    skipDuplicates?: boolean
  }

  export type RequestBookmarkCreateWithoutRequestInput = {
    id?: bigint | number
    user: UserCreateNestedOneWithoutRequestBookmarksInput
    createdAt?: Date | string
  }

  export type RequestBookmarkUncheckedCreateWithoutRequestInput = {
    id?: bigint | number
    userId: string
    createdAt?: Date | string
  }

  export type RequestBookmarkCreateOrConnectWithoutRequestInput = {
    where: RequestBookmarkWhereUniqueInput
    create: XOR<RequestBookmarkCreateWithoutRequestInput, RequestBookmarkUncheckedCreateWithoutRequestInput>
  }

  export type RequestBookmarkCreateManyRequestInputEnvelope = {
    data: Enumerable<RequestBookmarkCreateManyRequestInput>
    skipDuplicates?: boolean
  }

  export type RequestReportCreateWithoutRequestInput = {
    id?: bigint | number
    user?: UserCreateNestedOneWithoutRequestReportsInput
    content: string
    type: RequestReportType
    status: RequestReportStatus
    createdAt?: Date | string
  }

  export type RequestReportUncheckedCreateWithoutRequestInput = {
    id?: bigint | number
    userId?: string | null
    content: string
    type: RequestReportType
    status: RequestReportStatus
    createdAt?: Date | string
  }

  export type RequestReportCreateOrConnectWithoutRequestInput = {
    where: RequestReportWhereUniqueInput
    create: XOR<RequestReportCreateWithoutRequestInput, RequestReportUncheckedCreateWithoutRequestInput>
  }

  export type RequestReportCreateManyRequestInputEnvelope = {
    data: Enumerable<RequestReportCreateManyRequestInput>
    skipDuplicates?: boolean
  }

  export type RequestInquiryCreateWithoutRequestInput = {
    id?: bigint | number
    creator?: CreatorCreateNestedOneWithoutRequestInquiriesInput
    user?: UserCreateNestedOneWithoutRequestInquiriesInput
    requestInquiryMessages?: RequestInquiryMessageCreateNestedManyWithoutRoomInput
    createdAt?: Date | string
  }

  export type RequestInquiryUncheckedCreateWithoutRequestInput = {
    id?: bigint | number
    creatorId?: bigint | number | null
    userId?: string | null
    requestInquiryMessages?: RequestInquiryMessageUncheckedCreateNestedManyWithoutRoomInput
    createdAt?: Date | string
  }

  export type RequestInquiryCreateOrConnectWithoutRequestInput = {
    where: RequestInquiryWhereUniqueInput
    create: XOR<RequestInquiryCreateWithoutRequestInput, RequestInquiryUncheckedCreateWithoutRequestInput>
  }

  export type RequestInquiryCreateManyRequestInputEnvelope = {
    data: Enumerable<RequestInquiryCreateManyRequestInput>
    skipDuplicates?: boolean
  }

  export type LogCreateWithoutRequestInput = {
    id?: bigint | number
    logType: LogType
    message?: string | null
    sender?: UserCreateNestedOneWithoutLogInput
    isRead?: boolean | null
    receiver?: UserCreateNestedManyWithoutLogsInput
    createdAt?: Date | string
  }

  export type LogUncheckedCreateWithoutRequestInput = {
    id?: bigint | number
    logType: LogType
    message?: string | null
    senderId?: string | null
    isRead?: boolean | null
    receiver?: UserUncheckedCreateNestedManyWithoutLogsInput
    createdAt?: Date | string
  }

  export type LogCreateOrConnectWithoutRequestInput = {
    where: LogWhereUniqueInput
    create: XOR<LogCreateWithoutRequestInput, LogUncheckedCreateWithoutRequestInput>
  }

  export type LogCreateManyRequestInputEnvelope = {
    data: Enumerable<LogCreateManyRequestInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutRequestPostsInput = {
    update: XOR<UserUpdateWithoutRequestPostsInput, UserUncheckedUpdateWithoutRequestPostsInput>
    create: XOR<UserCreateWithoutRequestPostsInput, UserUncheckedCreateWithoutRequestPostsInput>
  }

  export type UserUpdateWithoutRequestPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoint?: IntFieldUpdateOperationsInput | number
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    requestFundings?: RequestFundingUpdateManyWithoutUserNestedInput
    requestComments?: RequestCommentUpdateManyWithoutUserNestedInput
    requestReactions?: RequestReactionUpdateManyWithoutUserNestedInput
    requestBookmarks?: RequestBookmarkUpdateManyWithoutUserNestedInput
    requestReports?: RequestReportUpdateManyWithoutUserNestedInput
    requestInquiries?: RequestInquiryUpdateManyWithoutUserNestedInput
    requestinquiryMessages?: RequestInquiryMessageUpdateManyWithoutFromNestedInput
    requestCommentHearts?: RequestCommentHeartUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutReceiverNestedInput
    points?: PointUpdateManyWithoutUserNestedInput
    rankings?: RankingUpdateManyWithoutUserNestedInput
    creatorReviews?: CreatorReviewUpdateManyWithoutUserNestedInput
    creator?: CreatorUpdateOneWithoutUserNestedInput
    Log?: LogUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutRequestPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoint?: IntFieldUpdateOperationsInput | number
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    requestFundings?: RequestFundingUncheckedUpdateManyWithoutUserNestedInput
    requestComments?: RequestCommentUncheckedUpdateManyWithoutUserNestedInput
    requestReactions?: RequestReactionUncheckedUpdateManyWithoutUserNestedInput
    requestBookmarks?: RequestBookmarkUncheckedUpdateManyWithoutUserNestedInput
    requestReports?: RequestReportUncheckedUpdateManyWithoutUserNestedInput
    requestInquiries?: RequestInquiryUncheckedUpdateManyWithoutUserNestedInput
    requestinquiryMessages?: RequestInquiryMessageUncheckedUpdateManyWithoutFromNestedInput
    requestCommentHearts?: RequestCommentHeartUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutReceiverNestedInput
    points?: PointUncheckedUpdateManyWithoutUserNestedInput
    rankings?: RankingUncheckedUpdateManyWithoutUserNestedInput
    creatorReviews?: CreatorReviewUncheckedUpdateManyWithoutUserNestedInput
    creator?: CreatorUncheckedUpdateOneWithoutUserNestedInput
    Log?: LogUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type CreatorUpsertWithoutRequestPostsInput = {
    update: XOR<CreatorUpdateWithoutRequestPostsInput, CreatorUncheckedUpdateWithoutRequestPostsInput>
    create: XOR<CreatorCreateWithoutRequestPostsInput, CreatorUncheckedCreateWithoutRequestPostsInput>
  }

  export type CreatorUpdateWithoutRequestPostsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user?: UserUpdateOneRequiredWithoutCreatorNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestApplyCreators?: RequestApplyCreatorUpdateManyWithoutCreatorNestedInput
    requestInquiries?: RequestInquiryUpdateManyWithoutCreatorNestedInput
    creatorAuths?: CreatorAuthUpdateManyWithoutCreatorNestedInput
    creatorReviews?: CreatorReviewUpdateManyWithoutCreatorNestedInput
  }

  export type CreatorUncheckedUpdateWithoutRequestPostsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestApplyCreators?: RequestApplyCreatorUncheckedUpdateManyWithoutCreatorNestedInput
    requestInquiries?: RequestInquiryUncheckedUpdateManyWithoutCreatorNestedInput
    creatorAuths?: CreatorAuthUncheckedUpdateManyWithoutCreatorNestedInput
    creatorReviews?: CreatorReviewUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type RequestFundingUpsertWithWhereUniqueWithoutRequestInput = {
    where: RequestFundingWhereUniqueInput
    update: XOR<RequestFundingUpdateWithoutRequestInput, RequestFundingUncheckedUpdateWithoutRequestInput>
    create: XOR<RequestFundingCreateWithoutRequestInput, RequestFundingUncheckedCreateWithoutRequestInput>
  }

  export type RequestFundingUpdateWithWhereUniqueWithoutRequestInput = {
    where: RequestFundingWhereUniqueInput
    data: XOR<RequestFundingUpdateWithoutRequestInput, RequestFundingUncheckedUpdateWithoutRequestInput>
  }

  export type RequestFundingUpdateManyWithWhereWithoutRequestInput = {
    where: RequestFundingScalarWhereInput
    data: XOR<RequestFundingUpdateManyMutationInput, RequestFundingUncheckedUpdateManyWithoutRequestFundingsInput>
  }

  export type RequestReactionUpsertWithWhereUniqueWithoutRequestInput = {
    where: RequestReactionWhereUniqueInput
    update: XOR<RequestReactionUpdateWithoutRequestInput, RequestReactionUncheckedUpdateWithoutRequestInput>
    create: XOR<RequestReactionCreateWithoutRequestInput, RequestReactionUncheckedCreateWithoutRequestInput>
  }

  export type RequestReactionUpdateWithWhereUniqueWithoutRequestInput = {
    where: RequestReactionWhereUniqueInput
    data: XOR<RequestReactionUpdateWithoutRequestInput, RequestReactionUncheckedUpdateWithoutRequestInput>
  }

  export type RequestReactionUpdateManyWithWhereWithoutRequestInput = {
    where: RequestReactionScalarWhereInput
    data: XOR<RequestReactionUpdateManyMutationInput, RequestReactionUncheckedUpdateManyWithoutRequestReactionsInput>
  }

  export type RequestApplyCreatorUpsertWithWhereUniqueWithoutRequestInput = {
    where: RequestApplyCreatorWhereUniqueInput
    update: XOR<RequestApplyCreatorUpdateWithoutRequestInput, RequestApplyCreatorUncheckedUpdateWithoutRequestInput>
    create: XOR<RequestApplyCreatorCreateWithoutRequestInput, RequestApplyCreatorUncheckedCreateWithoutRequestInput>
  }

  export type RequestApplyCreatorUpdateWithWhereUniqueWithoutRequestInput = {
    where: RequestApplyCreatorWhereUniqueInput
    data: XOR<RequestApplyCreatorUpdateWithoutRequestInput, RequestApplyCreatorUncheckedUpdateWithoutRequestInput>
  }

  export type RequestApplyCreatorUpdateManyWithWhereWithoutRequestInput = {
    where: RequestApplyCreatorScalarWhereInput
    data: XOR<RequestApplyCreatorUpdateManyMutationInput, RequestApplyCreatorUncheckedUpdateManyWithoutRequestApplyCreatorsInput>
  }

  export type RequestApplyCreatorScalarWhereInput = {
    AND?: Enumerable<RequestApplyCreatorScalarWhereInput>
    OR?: Enumerable<RequestApplyCreatorScalarWhereInput>
    NOT?: Enumerable<RequestApplyCreatorScalarWhereInput>
    id?: BigIntFilter | bigint | number
    requestId?: BigIntFilter | bigint | number
    creatorId?: BigIntNullableFilter | bigint | number | null
  }

  export type RequestPlatformUpsertWithWhereUniqueWithoutRequestInput = {
    where: RequestPlatformWhereUniqueInput
    update: XOR<RequestPlatformUpdateWithoutRequestInput, RequestPlatformUncheckedUpdateWithoutRequestInput>
    create: XOR<RequestPlatformCreateWithoutRequestInput, RequestPlatformUncheckedCreateWithoutRequestInput>
  }

  export type RequestPlatformUpdateWithWhereUniqueWithoutRequestInput = {
    where: RequestPlatformWhereUniqueInput
    data: XOR<RequestPlatformUpdateWithoutRequestInput, RequestPlatformUncheckedUpdateWithoutRequestInput>
  }

  export type RequestPlatformUpdateManyWithWhereWithoutRequestInput = {
    where: RequestPlatformScalarWhereInput
    data: XOR<RequestPlatformUpdateManyMutationInput, RequestPlatformUncheckedUpdateManyWithoutRequestPlatformsInput>
  }

  export type RequestPlatformScalarWhereInput = {
    AND?: Enumerable<RequestPlatformScalarWhereInput>
    OR?: Enumerable<RequestPlatformScalarWhereInput>
    NOT?: Enumerable<RequestPlatformScalarWhereInput>
    id?: BigIntFilter | bigint | number
    requestId?: BigIntFilter | bigint | number
    name?: EnumRequestPlatformTypeFilter | RequestPlatformType
  }

  export type RequestCommentUpsertWithWhereUniqueWithoutRequestInput = {
    where: RequestCommentWhereUniqueInput
    update: XOR<RequestCommentUpdateWithoutRequestInput, RequestCommentUncheckedUpdateWithoutRequestInput>
    create: XOR<RequestCommentCreateWithoutRequestInput, RequestCommentUncheckedCreateWithoutRequestInput>
  }

  export type RequestCommentUpdateWithWhereUniqueWithoutRequestInput = {
    where: RequestCommentWhereUniqueInput
    data: XOR<RequestCommentUpdateWithoutRequestInput, RequestCommentUncheckedUpdateWithoutRequestInput>
  }

  export type RequestCommentUpdateManyWithWhereWithoutRequestInput = {
    where: RequestCommentScalarWhereInput
    data: XOR<RequestCommentUpdateManyMutationInput, RequestCommentUncheckedUpdateManyWithoutRequestCommentsInput>
  }

  export type RequestBookmarkUpsertWithWhereUniqueWithoutRequestInput = {
    where: RequestBookmarkWhereUniqueInput
    update: XOR<RequestBookmarkUpdateWithoutRequestInput, RequestBookmarkUncheckedUpdateWithoutRequestInput>
    create: XOR<RequestBookmarkCreateWithoutRequestInput, RequestBookmarkUncheckedCreateWithoutRequestInput>
  }

  export type RequestBookmarkUpdateWithWhereUniqueWithoutRequestInput = {
    where: RequestBookmarkWhereUniqueInput
    data: XOR<RequestBookmarkUpdateWithoutRequestInput, RequestBookmarkUncheckedUpdateWithoutRequestInput>
  }

  export type RequestBookmarkUpdateManyWithWhereWithoutRequestInput = {
    where: RequestBookmarkScalarWhereInput
    data: XOR<RequestBookmarkUpdateManyMutationInput, RequestBookmarkUncheckedUpdateManyWithoutRequestBookmarksInput>
  }

  export type RequestReportUpsertWithWhereUniqueWithoutRequestInput = {
    where: RequestReportWhereUniqueInput
    update: XOR<RequestReportUpdateWithoutRequestInput, RequestReportUncheckedUpdateWithoutRequestInput>
    create: XOR<RequestReportCreateWithoutRequestInput, RequestReportUncheckedCreateWithoutRequestInput>
  }

  export type RequestReportUpdateWithWhereUniqueWithoutRequestInput = {
    where: RequestReportWhereUniqueInput
    data: XOR<RequestReportUpdateWithoutRequestInput, RequestReportUncheckedUpdateWithoutRequestInput>
  }

  export type RequestReportUpdateManyWithWhereWithoutRequestInput = {
    where: RequestReportScalarWhereInput
    data: XOR<RequestReportUpdateManyMutationInput, RequestReportUncheckedUpdateManyWithoutRequestReportsInput>
  }

  export type RequestInquiryUpsertWithWhereUniqueWithoutRequestInput = {
    where: RequestInquiryWhereUniqueInput
    update: XOR<RequestInquiryUpdateWithoutRequestInput, RequestInquiryUncheckedUpdateWithoutRequestInput>
    create: XOR<RequestInquiryCreateWithoutRequestInput, RequestInquiryUncheckedCreateWithoutRequestInput>
  }

  export type RequestInquiryUpdateWithWhereUniqueWithoutRequestInput = {
    where: RequestInquiryWhereUniqueInput
    data: XOR<RequestInquiryUpdateWithoutRequestInput, RequestInquiryUncheckedUpdateWithoutRequestInput>
  }

  export type RequestInquiryUpdateManyWithWhereWithoutRequestInput = {
    where: RequestInquiryScalarWhereInput
    data: XOR<RequestInquiryUpdateManyMutationInput, RequestInquiryUncheckedUpdateManyWithoutRequestInquirysInput>
  }

  export type LogUpsertWithWhereUniqueWithoutRequestInput = {
    where: LogWhereUniqueInput
    update: XOR<LogUpdateWithoutRequestInput, LogUncheckedUpdateWithoutRequestInput>
    create: XOR<LogCreateWithoutRequestInput, LogUncheckedCreateWithoutRequestInput>
  }

  export type LogUpdateWithWhereUniqueWithoutRequestInput = {
    where: LogWhereUniqueInput
    data: XOR<LogUpdateWithoutRequestInput, LogUncheckedUpdateWithoutRequestInput>
  }

  export type LogUpdateManyWithWhereWithoutRequestInput = {
    where: LogScalarWhereInput
    data: XOR<LogUpdateManyMutationInput, LogUncheckedUpdateManyWithoutLogInput>
  }

  export type UserCreateWithoutRequestFundingsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    introduction?: string | null
    totalPoint?: number
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    requestPosts?: RequestPostCreateNestedManyWithoutUserInput
    requestComments?: RequestCommentCreateNestedManyWithoutUserInput
    requestReactions?: RequestReactionCreateNestedManyWithoutUserInput
    requestBookmarks?: RequestBookmarkCreateNestedManyWithoutUserInput
    requestReports?: RequestReportCreateNestedManyWithoutUserInput
    requestInquiries?: RequestInquiryCreateNestedManyWithoutUserInput
    requestinquiryMessages?: RequestInquiryMessageCreateNestedManyWithoutFromInput
    requestCommentHearts?: RequestCommentHeartCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutReceiverInput
    points?: PointCreateNestedManyWithoutUserInput
    rankings?: RankingCreateNestedManyWithoutUserInput
    creatorReviews?: CreatorReviewCreateNestedManyWithoutUserInput
    creator?: CreatorCreateNestedOneWithoutUserInput
    Log?: LogCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutRequestFundingsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    introduction?: string | null
    totalPoint?: number
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    requestPosts?: RequestPostUncheckedCreateNestedManyWithoutUserInput
    requestComments?: RequestCommentUncheckedCreateNestedManyWithoutUserInput
    requestReactions?: RequestReactionUncheckedCreateNestedManyWithoutUserInput
    requestBookmarks?: RequestBookmarkUncheckedCreateNestedManyWithoutUserInput
    requestReports?: RequestReportUncheckedCreateNestedManyWithoutUserInput
    requestInquiries?: RequestInquiryUncheckedCreateNestedManyWithoutUserInput
    requestinquiryMessages?: RequestInquiryMessageUncheckedCreateNestedManyWithoutFromInput
    requestCommentHearts?: RequestCommentHeartUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutReceiverInput
    points?: PointUncheckedCreateNestedManyWithoutUserInput
    rankings?: RankingUncheckedCreateNestedManyWithoutUserInput
    creatorReviews?: CreatorReviewUncheckedCreateNestedManyWithoutUserInput
    creator?: CreatorUncheckedCreateNestedOneWithoutUserInput
    Log?: LogUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutRequestFundingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRequestFundingsInput, UserUncheckedCreateWithoutRequestFundingsInput>
  }

  export type RequestPostCreateWithoutRequestFundingsInput = {
    id?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutRequestPostsInput
    title: string
    content: string
    creator?: CreatorCreateNestedOneWithoutRequestPostsInput
    category?: RequestCategoryType | null
    expires?: Date | string | null
    totalViews?: number
    status?: RequestStatusType
    solvedUrl?: string | null
    thumbnailUrl?: string | null
    refusalReason?: string | null
    totalQuantity?: number
    totalLikeScroe?: number
    isUnspecified?: boolean
    requestReactions?: RequestReactionCreateNestedManyWithoutRequestInput
    requestApplyCreators?: RequestApplyCreatorCreateNestedManyWithoutRequestInput
    requestPlatforms?: RequestPlatformCreateNestedManyWithoutRequestInput
    requestComments?: RequestCommentCreateNestedManyWithoutRequestInput
    requestBookmarks?: RequestBookmarkCreateNestedManyWithoutRequestInput
    requestReports?: RequestReportCreateNestedManyWithoutRequestInput
    requestInquirys?: RequestInquiryCreateNestedManyWithoutRequestInput
    Log?: LogCreateNestedManyWithoutRequestInput
  }

  export type RequestPostUncheckedCreateWithoutRequestFundingsInput = {
    id?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    title: string
    content: string
    category?: RequestCategoryType | null
    creatorId?: bigint | number | null
    expires?: Date | string | null
    totalViews?: number
    status?: RequestStatusType
    solvedUrl?: string | null
    thumbnailUrl?: string | null
    refusalReason?: string | null
    totalQuantity?: number
    totalLikeScroe?: number
    isUnspecified?: boolean
    requestReactions?: RequestReactionUncheckedCreateNestedManyWithoutRequestInput
    requestApplyCreators?: RequestApplyCreatorUncheckedCreateNestedManyWithoutRequestInput
    requestPlatforms?: RequestPlatformUncheckedCreateNestedManyWithoutRequestInput
    requestComments?: RequestCommentUncheckedCreateNestedManyWithoutRequestInput
    requestBookmarks?: RequestBookmarkUncheckedCreateNestedManyWithoutRequestInput
    requestReports?: RequestReportUncheckedCreateNestedManyWithoutRequestInput
    requestInquirys?: RequestInquiryUncheckedCreateNestedManyWithoutRequestInput
    Log?: LogUncheckedCreateNestedManyWithoutRequestInput
  }

  export type RequestPostCreateOrConnectWithoutRequestFundingsInput = {
    where: RequestPostWhereUniqueInput
    create: XOR<RequestPostCreateWithoutRequestFundingsInput, RequestPostUncheckedCreateWithoutRequestFundingsInput>
  }

  export type UserUpsertWithoutRequestFundingsInput = {
    update: XOR<UserUpdateWithoutRequestFundingsInput, UserUncheckedUpdateWithoutRequestFundingsInput>
    create: XOR<UserCreateWithoutRequestFundingsInput, UserUncheckedCreateWithoutRequestFundingsInput>
  }

  export type UserUpdateWithoutRequestFundingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoint?: IntFieldUpdateOperationsInput | number
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    requestPosts?: RequestPostUpdateManyWithoutUserNestedInput
    requestComments?: RequestCommentUpdateManyWithoutUserNestedInput
    requestReactions?: RequestReactionUpdateManyWithoutUserNestedInput
    requestBookmarks?: RequestBookmarkUpdateManyWithoutUserNestedInput
    requestReports?: RequestReportUpdateManyWithoutUserNestedInput
    requestInquiries?: RequestInquiryUpdateManyWithoutUserNestedInput
    requestinquiryMessages?: RequestInquiryMessageUpdateManyWithoutFromNestedInput
    requestCommentHearts?: RequestCommentHeartUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutReceiverNestedInput
    points?: PointUpdateManyWithoutUserNestedInput
    rankings?: RankingUpdateManyWithoutUserNestedInput
    creatorReviews?: CreatorReviewUpdateManyWithoutUserNestedInput
    creator?: CreatorUpdateOneWithoutUserNestedInput
    Log?: LogUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutRequestFundingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoint?: IntFieldUpdateOperationsInput | number
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    requestPosts?: RequestPostUncheckedUpdateManyWithoutUserNestedInput
    requestComments?: RequestCommentUncheckedUpdateManyWithoutUserNestedInput
    requestReactions?: RequestReactionUncheckedUpdateManyWithoutUserNestedInput
    requestBookmarks?: RequestBookmarkUncheckedUpdateManyWithoutUserNestedInput
    requestReports?: RequestReportUncheckedUpdateManyWithoutUserNestedInput
    requestInquiries?: RequestInquiryUncheckedUpdateManyWithoutUserNestedInput
    requestinquiryMessages?: RequestInquiryMessageUncheckedUpdateManyWithoutFromNestedInput
    requestCommentHearts?: RequestCommentHeartUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutReceiverNestedInput
    points?: PointUncheckedUpdateManyWithoutUserNestedInput
    rankings?: RankingUncheckedUpdateManyWithoutUserNestedInput
    creatorReviews?: CreatorReviewUncheckedUpdateManyWithoutUserNestedInput
    creator?: CreatorUncheckedUpdateOneWithoutUserNestedInput
    Log?: LogUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type RequestPostUpsertWithoutRequestFundingsInput = {
    update: XOR<RequestPostUpdateWithoutRequestFundingsInput, RequestPostUncheckedUpdateWithoutRequestFundingsInput>
    create: XOR<RequestPostCreateWithoutRequestFundingsInput, RequestPostUncheckedCreateWithoutRequestFundingsInput>
  }

  export type RequestPostUpdateWithoutRequestFundingsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutRequestPostsNestedInput
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    creator?: CreatorUpdateOneWithoutRequestPostsNestedInput
    category?: NullableEnumRequestCategoryTypeFieldUpdateOperationsInput | RequestCategoryType | null
    expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalViews?: IntFieldUpdateOperationsInput | number
    status?: EnumRequestStatusTypeFieldUpdateOperationsInput | RequestStatusType
    solvedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    refusalReason?: NullableStringFieldUpdateOperationsInput | string | null
    totalQuantity?: IntFieldUpdateOperationsInput | number
    totalLikeScroe?: IntFieldUpdateOperationsInput | number
    isUnspecified?: BoolFieldUpdateOperationsInput | boolean
    requestReactions?: RequestReactionUpdateManyWithoutRequestNestedInput
    requestApplyCreators?: RequestApplyCreatorUpdateManyWithoutRequestNestedInput
    requestPlatforms?: RequestPlatformUpdateManyWithoutRequestNestedInput
    requestComments?: RequestCommentUpdateManyWithoutRequestNestedInput
    requestBookmarks?: RequestBookmarkUpdateManyWithoutRequestNestedInput
    requestReports?: RequestReportUpdateManyWithoutRequestNestedInput
    requestInquirys?: RequestInquiryUpdateManyWithoutRequestNestedInput
    Log?: LogUpdateManyWithoutRequestNestedInput
  }

  export type RequestPostUncheckedUpdateWithoutRequestFundingsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableEnumRequestCategoryTypeFieldUpdateOperationsInput | RequestCategoryType | null
    creatorId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalViews?: IntFieldUpdateOperationsInput | number
    status?: EnumRequestStatusTypeFieldUpdateOperationsInput | RequestStatusType
    solvedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    refusalReason?: NullableStringFieldUpdateOperationsInput | string | null
    totalQuantity?: IntFieldUpdateOperationsInput | number
    totalLikeScroe?: IntFieldUpdateOperationsInput | number
    isUnspecified?: BoolFieldUpdateOperationsInput | boolean
    requestReactions?: RequestReactionUncheckedUpdateManyWithoutRequestNestedInput
    requestApplyCreators?: RequestApplyCreatorUncheckedUpdateManyWithoutRequestNestedInput
    requestPlatforms?: RequestPlatformUncheckedUpdateManyWithoutRequestNestedInput
    requestComments?: RequestCommentUncheckedUpdateManyWithoutRequestNestedInput
    requestBookmarks?: RequestBookmarkUncheckedUpdateManyWithoutRequestNestedInput
    requestReports?: RequestReportUncheckedUpdateManyWithoutRequestNestedInput
    requestInquirys?: RequestInquiryUncheckedUpdateManyWithoutRequestNestedInput
    Log?: LogUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type UserCreateWithoutRequestReactionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    introduction?: string | null
    totalPoint?: number
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    requestPosts?: RequestPostCreateNestedManyWithoutUserInput
    requestFundings?: RequestFundingCreateNestedManyWithoutUserInput
    requestComments?: RequestCommentCreateNestedManyWithoutUserInput
    requestBookmarks?: RequestBookmarkCreateNestedManyWithoutUserInput
    requestReports?: RequestReportCreateNestedManyWithoutUserInput
    requestInquiries?: RequestInquiryCreateNestedManyWithoutUserInput
    requestinquiryMessages?: RequestInquiryMessageCreateNestedManyWithoutFromInput
    requestCommentHearts?: RequestCommentHeartCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutReceiverInput
    points?: PointCreateNestedManyWithoutUserInput
    rankings?: RankingCreateNestedManyWithoutUserInput
    creatorReviews?: CreatorReviewCreateNestedManyWithoutUserInput
    creator?: CreatorCreateNestedOneWithoutUserInput
    Log?: LogCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutRequestReactionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    introduction?: string | null
    totalPoint?: number
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    requestPosts?: RequestPostUncheckedCreateNestedManyWithoutUserInput
    requestFundings?: RequestFundingUncheckedCreateNestedManyWithoutUserInput
    requestComments?: RequestCommentUncheckedCreateNestedManyWithoutUserInput
    requestBookmarks?: RequestBookmarkUncheckedCreateNestedManyWithoutUserInput
    requestReports?: RequestReportUncheckedCreateNestedManyWithoutUserInput
    requestInquiries?: RequestInquiryUncheckedCreateNestedManyWithoutUserInput
    requestinquiryMessages?: RequestInquiryMessageUncheckedCreateNestedManyWithoutFromInput
    requestCommentHearts?: RequestCommentHeartUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutReceiverInput
    points?: PointUncheckedCreateNestedManyWithoutUserInput
    rankings?: RankingUncheckedCreateNestedManyWithoutUserInput
    creatorReviews?: CreatorReviewUncheckedCreateNestedManyWithoutUserInput
    creator?: CreatorUncheckedCreateNestedOneWithoutUserInput
    Log?: LogUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutRequestReactionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRequestReactionsInput, UserUncheckedCreateWithoutRequestReactionsInput>
  }

  export type RequestPostCreateWithoutRequestReactionsInput = {
    id?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutRequestPostsInput
    title: string
    content: string
    creator?: CreatorCreateNestedOneWithoutRequestPostsInput
    category?: RequestCategoryType | null
    expires?: Date | string | null
    totalViews?: number
    status?: RequestStatusType
    solvedUrl?: string | null
    thumbnailUrl?: string | null
    refusalReason?: string | null
    totalQuantity?: number
    totalLikeScroe?: number
    isUnspecified?: boolean
    requestFundings?: RequestFundingCreateNestedManyWithoutRequestInput
    requestApplyCreators?: RequestApplyCreatorCreateNestedManyWithoutRequestInput
    requestPlatforms?: RequestPlatformCreateNestedManyWithoutRequestInput
    requestComments?: RequestCommentCreateNestedManyWithoutRequestInput
    requestBookmarks?: RequestBookmarkCreateNestedManyWithoutRequestInput
    requestReports?: RequestReportCreateNestedManyWithoutRequestInput
    requestInquirys?: RequestInquiryCreateNestedManyWithoutRequestInput
    Log?: LogCreateNestedManyWithoutRequestInput
  }

  export type RequestPostUncheckedCreateWithoutRequestReactionsInput = {
    id?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    title: string
    content: string
    category?: RequestCategoryType | null
    creatorId?: bigint | number | null
    expires?: Date | string | null
    totalViews?: number
    status?: RequestStatusType
    solvedUrl?: string | null
    thumbnailUrl?: string | null
    refusalReason?: string | null
    totalQuantity?: number
    totalLikeScroe?: number
    isUnspecified?: boolean
    requestFundings?: RequestFundingUncheckedCreateNestedManyWithoutRequestInput
    requestApplyCreators?: RequestApplyCreatorUncheckedCreateNestedManyWithoutRequestInput
    requestPlatforms?: RequestPlatformUncheckedCreateNestedManyWithoutRequestInput
    requestComments?: RequestCommentUncheckedCreateNestedManyWithoutRequestInput
    requestBookmarks?: RequestBookmarkUncheckedCreateNestedManyWithoutRequestInput
    requestReports?: RequestReportUncheckedCreateNestedManyWithoutRequestInput
    requestInquirys?: RequestInquiryUncheckedCreateNestedManyWithoutRequestInput
    Log?: LogUncheckedCreateNestedManyWithoutRequestInput
  }

  export type RequestPostCreateOrConnectWithoutRequestReactionsInput = {
    where: RequestPostWhereUniqueInput
    create: XOR<RequestPostCreateWithoutRequestReactionsInput, RequestPostUncheckedCreateWithoutRequestReactionsInput>
  }

  export type UserUpsertWithoutRequestReactionsInput = {
    update: XOR<UserUpdateWithoutRequestReactionsInput, UserUncheckedUpdateWithoutRequestReactionsInput>
    create: XOR<UserCreateWithoutRequestReactionsInput, UserUncheckedCreateWithoutRequestReactionsInput>
  }

  export type UserUpdateWithoutRequestReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoint?: IntFieldUpdateOperationsInput | number
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    requestPosts?: RequestPostUpdateManyWithoutUserNestedInput
    requestFundings?: RequestFundingUpdateManyWithoutUserNestedInput
    requestComments?: RequestCommentUpdateManyWithoutUserNestedInput
    requestBookmarks?: RequestBookmarkUpdateManyWithoutUserNestedInput
    requestReports?: RequestReportUpdateManyWithoutUserNestedInput
    requestInquiries?: RequestInquiryUpdateManyWithoutUserNestedInput
    requestinquiryMessages?: RequestInquiryMessageUpdateManyWithoutFromNestedInput
    requestCommentHearts?: RequestCommentHeartUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutReceiverNestedInput
    points?: PointUpdateManyWithoutUserNestedInput
    rankings?: RankingUpdateManyWithoutUserNestedInput
    creatorReviews?: CreatorReviewUpdateManyWithoutUserNestedInput
    creator?: CreatorUpdateOneWithoutUserNestedInput
    Log?: LogUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutRequestReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoint?: IntFieldUpdateOperationsInput | number
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    requestPosts?: RequestPostUncheckedUpdateManyWithoutUserNestedInput
    requestFundings?: RequestFundingUncheckedUpdateManyWithoutUserNestedInput
    requestComments?: RequestCommentUncheckedUpdateManyWithoutUserNestedInput
    requestBookmarks?: RequestBookmarkUncheckedUpdateManyWithoutUserNestedInput
    requestReports?: RequestReportUncheckedUpdateManyWithoutUserNestedInput
    requestInquiries?: RequestInquiryUncheckedUpdateManyWithoutUserNestedInput
    requestinquiryMessages?: RequestInquiryMessageUncheckedUpdateManyWithoutFromNestedInput
    requestCommentHearts?: RequestCommentHeartUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutReceiverNestedInput
    points?: PointUncheckedUpdateManyWithoutUserNestedInput
    rankings?: RankingUncheckedUpdateManyWithoutUserNestedInput
    creatorReviews?: CreatorReviewUncheckedUpdateManyWithoutUserNestedInput
    creator?: CreatorUncheckedUpdateOneWithoutUserNestedInput
    Log?: LogUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type RequestPostUpsertWithoutRequestReactionsInput = {
    update: XOR<RequestPostUpdateWithoutRequestReactionsInput, RequestPostUncheckedUpdateWithoutRequestReactionsInput>
    create: XOR<RequestPostCreateWithoutRequestReactionsInput, RequestPostUncheckedCreateWithoutRequestReactionsInput>
  }

  export type RequestPostUpdateWithoutRequestReactionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutRequestPostsNestedInput
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    creator?: CreatorUpdateOneWithoutRequestPostsNestedInput
    category?: NullableEnumRequestCategoryTypeFieldUpdateOperationsInput | RequestCategoryType | null
    expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalViews?: IntFieldUpdateOperationsInput | number
    status?: EnumRequestStatusTypeFieldUpdateOperationsInput | RequestStatusType
    solvedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    refusalReason?: NullableStringFieldUpdateOperationsInput | string | null
    totalQuantity?: IntFieldUpdateOperationsInput | number
    totalLikeScroe?: IntFieldUpdateOperationsInput | number
    isUnspecified?: BoolFieldUpdateOperationsInput | boolean
    requestFundings?: RequestFundingUpdateManyWithoutRequestNestedInput
    requestApplyCreators?: RequestApplyCreatorUpdateManyWithoutRequestNestedInput
    requestPlatforms?: RequestPlatformUpdateManyWithoutRequestNestedInput
    requestComments?: RequestCommentUpdateManyWithoutRequestNestedInput
    requestBookmarks?: RequestBookmarkUpdateManyWithoutRequestNestedInput
    requestReports?: RequestReportUpdateManyWithoutRequestNestedInput
    requestInquirys?: RequestInquiryUpdateManyWithoutRequestNestedInput
    Log?: LogUpdateManyWithoutRequestNestedInput
  }

  export type RequestPostUncheckedUpdateWithoutRequestReactionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableEnumRequestCategoryTypeFieldUpdateOperationsInput | RequestCategoryType | null
    creatorId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalViews?: IntFieldUpdateOperationsInput | number
    status?: EnumRequestStatusTypeFieldUpdateOperationsInput | RequestStatusType
    solvedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    refusalReason?: NullableStringFieldUpdateOperationsInput | string | null
    totalQuantity?: IntFieldUpdateOperationsInput | number
    totalLikeScroe?: IntFieldUpdateOperationsInput | number
    isUnspecified?: BoolFieldUpdateOperationsInput | boolean
    requestFundings?: RequestFundingUncheckedUpdateManyWithoutRequestNestedInput
    requestApplyCreators?: RequestApplyCreatorUncheckedUpdateManyWithoutRequestNestedInput
    requestPlatforms?: RequestPlatformUncheckedUpdateManyWithoutRequestNestedInput
    requestComments?: RequestCommentUncheckedUpdateManyWithoutRequestNestedInput
    requestBookmarks?: RequestBookmarkUncheckedUpdateManyWithoutRequestNestedInput
    requestReports?: RequestReportUncheckedUpdateManyWithoutRequestNestedInput
    requestInquirys?: RequestInquiryUncheckedUpdateManyWithoutRequestNestedInput
    Log?: LogUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type RequestPostCreateWithoutRequestCommentsInput = {
    id?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutRequestPostsInput
    title: string
    content: string
    creator?: CreatorCreateNestedOneWithoutRequestPostsInput
    category?: RequestCategoryType | null
    expires?: Date | string | null
    totalViews?: number
    status?: RequestStatusType
    solvedUrl?: string | null
    thumbnailUrl?: string | null
    refusalReason?: string | null
    totalQuantity?: number
    totalLikeScroe?: number
    isUnspecified?: boolean
    requestFundings?: RequestFundingCreateNestedManyWithoutRequestInput
    requestReactions?: RequestReactionCreateNestedManyWithoutRequestInput
    requestApplyCreators?: RequestApplyCreatorCreateNestedManyWithoutRequestInput
    requestPlatforms?: RequestPlatformCreateNestedManyWithoutRequestInput
    requestBookmarks?: RequestBookmarkCreateNestedManyWithoutRequestInput
    requestReports?: RequestReportCreateNestedManyWithoutRequestInput
    requestInquirys?: RequestInquiryCreateNestedManyWithoutRequestInput
    Log?: LogCreateNestedManyWithoutRequestInput
  }

  export type RequestPostUncheckedCreateWithoutRequestCommentsInput = {
    id?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    title: string
    content: string
    category?: RequestCategoryType | null
    creatorId?: bigint | number | null
    expires?: Date | string | null
    totalViews?: number
    status?: RequestStatusType
    solvedUrl?: string | null
    thumbnailUrl?: string | null
    refusalReason?: string | null
    totalQuantity?: number
    totalLikeScroe?: number
    isUnspecified?: boolean
    requestFundings?: RequestFundingUncheckedCreateNestedManyWithoutRequestInput
    requestReactions?: RequestReactionUncheckedCreateNestedManyWithoutRequestInput
    requestApplyCreators?: RequestApplyCreatorUncheckedCreateNestedManyWithoutRequestInput
    requestPlatforms?: RequestPlatformUncheckedCreateNestedManyWithoutRequestInput
    requestBookmarks?: RequestBookmarkUncheckedCreateNestedManyWithoutRequestInput
    requestReports?: RequestReportUncheckedCreateNestedManyWithoutRequestInput
    requestInquirys?: RequestInquiryUncheckedCreateNestedManyWithoutRequestInput
    Log?: LogUncheckedCreateNestedManyWithoutRequestInput
  }

  export type RequestPostCreateOrConnectWithoutRequestCommentsInput = {
    where: RequestPostWhereUniqueInput
    create: XOR<RequestPostCreateWithoutRequestCommentsInput, RequestPostUncheckedCreateWithoutRequestCommentsInput>
  }

  export type UserCreateWithoutRequestCommentsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    introduction?: string | null
    totalPoint?: number
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    requestPosts?: RequestPostCreateNestedManyWithoutUserInput
    requestFundings?: RequestFundingCreateNestedManyWithoutUserInput
    requestReactions?: RequestReactionCreateNestedManyWithoutUserInput
    requestBookmarks?: RequestBookmarkCreateNestedManyWithoutUserInput
    requestReports?: RequestReportCreateNestedManyWithoutUserInput
    requestInquiries?: RequestInquiryCreateNestedManyWithoutUserInput
    requestinquiryMessages?: RequestInquiryMessageCreateNestedManyWithoutFromInput
    requestCommentHearts?: RequestCommentHeartCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutReceiverInput
    points?: PointCreateNestedManyWithoutUserInput
    rankings?: RankingCreateNestedManyWithoutUserInput
    creatorReviews?: CreatorReviewCreateNestedManyWithoutUserInput
    creator?: CreatorCreateNestedOneWithoutUserInput
    Log?: LogCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutRequestCommentsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    introduction?: string | null
    totalPoint?: number
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    requestPosts?: RequestPostUncheckedCreateNestedManyWithoutUserInput
    requestFundings?: RequestFundingUncheckedCreateNestedManyWithoutUserInput
    requestReactions?: RequestReactionUncheckedCreateNestedManyWithoutUserInput
    requestBookmarks?: RequestBookmarkUncheckedCreateNestedManyWithoutUserInput
    requestReports?: RequestReportUncheckedCreateNestedManyWithoutUserInput
    requestInquiries?: RequestInquiryUncheckedCreateNestedManyWithoutUserInput
    requestinquiryMessages?: RequestInquiryMessageUncheckedCreateNestedManyWithoutFromInput
    requestCommentHearts?: RequestCommentHeartUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutReceiverInput
    points?: PointUncheckedCreateNestedManyWithoutUserInput
    rankings?: RankingUncheckedCreateNestedManyWithoutUserInput
    creatorReviews?: CreatorReviewUncheckedCreateNestedManyWithoutUserInput
    creator?: CreatorUncheckedCreateNestedOneWithoutUserInput
    Log?: LogUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutRequestCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRequestCommentsInput, UserUncheckedCreateWithoutRequestCommentsInput>
  }

  export type RequestCommentCreateWithoutChildrenCommentsInput = {
    id?: bigint | number
    request: RequestPostCreateNestedOneWithoutRequestCommentsInput
    user?: UserCreateNestedOneWithoutRequestCommentsInput
    parentComment?: RequestCommentCreateNestedOneWithoutChildrenCommentsInput
    rootId?: bigint | number | null
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    hearts?: RequestCommentHeartCreateNestedManyWithoutRequestCommentInput
  }

  export type RequestCommentUncheckedCreateWithoutChildrenCommentsInput = {
    id?: bigint | number
    requestId: bigint | number
    userId?: string | null
    parentId?: bigint | number | null
    rootId?: bigint | number | null
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    hearts?: RequestCommentHeartUncheckedCreateNestedManyWithoutRequestCommentInput
  }

  export type RequestCommentCreateOrConnectWithoutChildrenCommentsInput = {
    where: RequestCommentWhereUniqueInput
    create: XOR<RequestCommentCreateWithoutChildrenCommentsInput, RequestCommentUncheckedCreateWithoutChildrenCommentsInput>
  }

  export type RequestCommentHeartCreateWithoutRequestCommentInput = {
    id?: bigint | number
    user: UserCreateNestedOneWithoutRequestCommentHeartsInput
    createdAt?: Date | string
  }

  export type RequestCommentHeartUncheckedCreateWithoutRequestCommentInput = {
    id?: bigint | number
    userId: string
    createdAt?: Date | string
  }

  export type RequestCommentHeartCreateOrConnectWithoutRequestCommentInput = {
    where: RequestCommentHeartWhereUniqueInput
    create: XOR<RequestCommentHeartCreateWithoutRequestCommentInput, RequestCommentHeartUncheckedCreateWithoutRequestCommentInput>
  }

  export type RequestCommentHeartCreateManyRequestCommentInputEnvelope = {
    data: Enumerable<RequestCommentHeartCreateManyRequestCommentInput>
    skipDuplicates?: boolean
  }

  export type RequestCommentCreateWithoutParentCommentInput = {
    id?: bigint | number
    request: RequestPostCreateNestedOneWithoutRequestCommentsInput
    user?: UserCreateNestedOneWithoutRequestCommentsInput
    rootId?: bigint | number | null
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    hearts?: RequestCommentHeartCreateNestedManyWithoutRequestCommentInput
    childrenComments?: RequestCommentCreateNestedManyWithoutParentCommentInput
  }

  export type RequestCommentUncheckedCreateWithoutParentCommentInput = {
    id?: bigint | number
    requestId: bigint | number
    userId?: string | null
    rootId?: bigint | number | null
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    hearts?: RequestCommentHeartUncheckedCreateNestedManyWithoutRequestCommentInput
    childrenComments?: RequestCommentUncheckedCreateNestedManyWithoutParentCommentInput
  }

  export type RequestCommentCreateOrConnectWithoutParentCommentInput = {
    where: RequestCommentWhereUniqueInput
    create: XOR<RequestCommentCreateWithoutParentCommentInput, RequestCommentUncheckedCreateWithoutParentCommentInput>
  }

  export type RequestCommentCreateManyParentCommentInputEnvelope = {
    data: Enumerable<RequestCommentCreateManyParentCommentInput>
    skipDuplicates?: boolean
  }

  export type RequestPostUpsertWithoutRequestCommentsInput = {
    update: XOR<RequestPostUpdateWithoutRequestCommentsInput, RequestPostUncheckedUpdateWithoutRequestCommentsInput>
    create: XOR<RequestPostCreateWithoutRequestCommentsInput, RequestPostUncheckedCreateWithoutRequestCommentsInput>
  }

  export type RequestPostUpdateWithoutRequestCommentsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutRequestPostsNestedInput
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    creator?: CreatorUpdateOneWithoutRequestPostsNestedInput
    category?: NullableEnumRequestCategoryTypeFieldUpdateOperationsInput | RequestCategoryType | null
    expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalViews?: IntFieldUpdateOperationsInput | number
    status?: EnumRequestStatusTypeFieldUpdateOperationsInput | RequestStatusType
    solvedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    refusalReason?: NullableStringFieldUpdateOperationsInput | string | null
    totalQuantity?: IntFieldUpdateOperationsInput | number
    totalLikeScroe?: IntFieldUpdateOperationsInput | number
    isUnspecified?: BoolFieldUpdateOperationsInput | boolean
    requestFundings?: RequestFundingUpdateManyWithoutRequestNestedInput
    requestReactions?: RequestReactionUpdateManyWithoutRequestNestedInput
    requestApplyCreators?: RequestApplyCreatorUpdateManyWithoutRequestNestedInput
    requestPlatforms?: RequestPlatformUpdateManyWithoutRequestNestedInput
    requestBookmarks?: RequestBookmarkUpdateManyWithoutRequestNestedInput
    requestReports?: RequestReportUpdateManyWithoutRequestNestedInput
    requestInquirys?: RequestInquiryUpdateManyWithoutRequestNestedInput
    Log?: LogUpdateManyWithoutRequestNestedInput
  }

  export type RequestPostUncheckedUpdateWithoutRequestCommentsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableEnumRequestCategoryTypeFieldUpdateOperationsInput | RequestCategoryType | null
    creatorId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalViews?: IntFieldUpdateOperationsInput | number
    status?: EnumRequestStatusTypeFieldUpdateOperationsInput | RequestStatusType
    solvedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    refusalReason?: NullableStringFieldUpdateOperationsInput | string | null
    totalQuantity?: IntFieldUpdateOperationsInput | number
    totalLikeScroe?: IntFieldUpdateOperationsInput | number
    isUnspecified?: BoolFieldUpdateOperationsInput | boolean
    requestFundings?: RequestFundingUncheckedUpdateManyWithoutRequestNestedInput
    requestReactions?: RequestReactionUncheckedUpdateManyWithoutRequestNestedInput
    requestApplyCreators?: RequestApplyCreatorUncheckedUpdateManyWithoutRequestNestedInput
    requestPlatforms?: RequestPlatformUncheckedUpdateManyWithoutRequestNestedInput
    requestBookmarks?: RequestBookmarkUncheckedUpdateManyWithoutRequestNestedInput
    requestReports?: RequestReportUncheckedUpdateManyWithoutRequestNestedInput
    requestInquirys?: RequestInquiryUncheckedUpdateManyWithoutRequestNestedInput
    Log?: LogUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type UserUpsertWithoutRequestCommentsInput = {
    update: XOR<UserUpdateWithoutRequestCommentsInput, UserUncheckedUpdateWithoutRequestCommentsInput>
    create: XOR<UserCreateWithoutRequestCommentsInput, UserUncheckedCreateWithoutRequestCommentsInput>
  }

  export type UserUpdateWithoutRequestCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoint?: IntFieldUpdateOperationsInput | number
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    requestPosts?: RequestPostUpdateManyWithoutUserNestedInput
    requestFundings?: RequestFundingUpdateManyWithoutUserNestedInput
    requestReactions?: RequestReactionUpdateManyWithoutUserNestedInput
    requestBookmarks?: RequestBookmarkUpdateManyWithoutUserNestedInput
    requestReports?: RequestReportUpdateManyWithoutUserNestedInput
    requestInquiries?: RequestInquiryUpdateManyWithoutUserNestedInput
    requestinquiryMessages?: RequestInquiryMessageUpdateManyWithoutFromNestedInput
    requestCommentHearts?: RequestCommentHeartUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutReceiverNestedInput
    points?: PointUpdateManyWithoutUserNestedInput
    rankings?: RankingUpdateManyWithoutUserNestedInput
    creatorReviews?: CreatorReviewUpdateManyWithoutUserNestedInput
    creator?: CreatorUpdateOneWithoutUserNestedInput
    Log?: LogUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutRequestCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoint?: IntFieldUpdateOperationsInput | number
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    requestPosts?: RequestPostUncheckedUpdateManyWithoutUserNestedInput
    requestFundings?: RequestFundingUncheckedUpdateManyWithoutUserNestedInput
    requestReactions?: RequestReactionUncheckedUpdateManyWithoutUserNestedInput
    requestBookmarks?: RequestBookmarkUncheckedUpdateManyWithoutUserNestedInput
    requestReports?: RequestReportUncheckedUpdateManyWithoutUserNestedInput
    requestInquiries?: RequestInquiryUncheckedUpdateManyWithoutUserNestedInput
    requestinquiryMessages?: RequestInquiryMessageUncheckedUpdateManyWithoutFromNestedInput
    requestCommentHearts?: RequestCommentHeartUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutReceiverNestedInput
    points?: PointUncheckedUpdateManyWithoutUserNestedInput
    rankings?: RankingUncheckedUpdateManyWithoutUserNestedInput
    creatorReviews?: CreatorReviewUncheckedUpdateManyWithoutUserNestedInput
    creator?: CreatorUncheckedUpdateOneWithoutUserNestedInput
    Log?: LogUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type RequestCommentUpsertWithoutChildrenCommentsInput = {
    update: XOR<RequestCommentUpdateWithoutChildrenCommentsInput, RequestCommentUncheckedUpdateWithoutChildrenCommentsInput>
    create: XOR<RequestCommentCreateWithoutChildrenCommentsInput, RequestCommentUncheckedCreateWithoutChildrenCommentsInput>
  }

  export type RequestCommentUpdateWithoutChildrenCommentsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    request?: RequestPostUpdateOneRequiredWithoutRequestCommentsNestedInput
    user?: UserUpdateOneWithoutRequestCommentsNestedInput
    parentComment?: RequestCommentUpdateOneWithoutChildrenCommentsNestedInput
    rootId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hearts?: RequestCommentHeartUpdateManyWithoutRequestCommentNestedInput
  }

  export type RequestCommentUncheckedUpdateWithoutChildrenCommentsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    requestId?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    rootId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hearts?: RequestCommentHeartUncheckedUpdateManyWithoutRequestCommentNestedInput
  }

  export type RequestCommentHeartUpsertWithWhereUniqueWithoutRequestCommentInput = {
    where: RequestCommentHeartWhereUniqueInput
    update: XOR<RequestCommentHeartUpdateWithoutRequestCommentInput, RequestCommentHeartUncheckedUpdateWithoutRequestCommentInput>
    create: XOR<RequestCommentHeartCreateWithoutRequestCommentInput, RequestCommentHeartUncheckedCreateWithoutRequestCommentInput>
  }

  export type RequestCommentHeartUpdateWithWhereUniqueWithoutRequestCommentInput = {
    where: RequestCommentHeartWhereUniqueInput
    data: XOR<RequestCommentHeartUpdateWithoutRequestCommentInput, RequestCommentHeartUncheckedUpdateWithoutRequestCommentInput>
  }

  export type RequestCommentHeartUpdateManyWithWhereWithoutRequestCommentInput = {
    where: RequestCommentHeartScalarWhereInput
    data: XOR<RequestCommentHeartUpdateManyMutationInput, RequestCommentHeartUncheckedUpdateManyWithoutHeartsInput>
  }

  export type RequestCommentUpsertWithWhereUniqueWithoutParentCommentInput = {
    where: RequestCommentWhereUniqueInput
    update: XOR<RequestCommentUpdateWithoutParentCommentInput, RequestCommentUncheckedUpdateWithoutParentCommentInput>
    create: XOR<RequestCommentCreateWithoutParentCommentInput, RequestCommentUncheckedCreateWithoutParentCommentInput>
  }

  export type RequestCommentUpdateWithWhereUniqueWithoutParentCommentInput = {
    where: RequestCommentWhereUniqueInput
    data: XOR<RequestCommentUpdateWithoutParentCommentInput, RequestCommentUncheckedUpdateWithoutParentCommentInput>
  }

  export type RequestCommentUpdateManyWithWhereWithoutParentCommentInput = {
    where: RequestCommentScalarWhereInput
    data: XOR<RequestCommentUpdateManyMutationInput, RequestCommentUncheckedUpdateManyWithoutChildrenCommentsInput>
  }

  export type RequestCommentCreateWithoutHeartsInput = {
    id?: bigint | number
    request: RequestPostCreateNestedOneWithoutRequestCommentsInput
    user?: UserCreateNestedOneWithoutRequestCommentsInput
    parentComment?: RequestCommentCreateNestedOneWithoutChildrenCommentsInput
    rootId?: bigint | number | null
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    childrenComments?: RequestCommentCreateNestedManyWithoutParentCommentInput
  }

  export type RequestCommentUncheckedCreateWithoutHeartsInput = {
    id?: bigint | number
    requestId: bigint | number
    userId?: string | null
    parentId?: bigint | number | null
    rootId?: bigint | number | null
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    childrenComments?: RequestCommentUncheckedCreateNestedManyWithoutParentCommentInput
  }

  export type RequestCommentCreateOrConnectWithoutHeartsInput = {
    where: RequestCommentWhereUniqueInput
    create: XOR<RequestCommentCreateWithoutHeartsInput, RequestCommentUncheckedCreateWithoutHeartsInput>
  }

  export type UserCreateWithoutRequestCommentHeartsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    introduction?: string | null
    totalPoint?: number
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    requestPosts?: RequestPostCreateNestedManyWithoutUserInput
    requestFundings?: RequestFundingCreateNestedManyWithoutUserInput
    requestComments?: RequestCommentCreateNestedManyWithoutUserInput
    requestReactions?: RequestReactionCreateNestedManyWithoutUserInput
    requestBookmarks?: RequestBookmarkCreateNestedManyWithoutUserInput
    requestReports?: RequestReportCreateNestedManyWithoutUserInput
    requestInquiries?: RequestInquiryCreateNestedManyWithoutUserInput
    requestinquiryMessages?: RequestInquiryMessageCreateNestedManyWithoutFromInput
    logs?: LogCreateNestedManyWithoutReceiverInput
    points?: PointCreateNestedManyWithoutUserInput
    rankings?: RankingCreateNestedManyWithoutUserInput
    creatorReviews?: CreatorReviewCreateNestedManyWithoutUserInput
    creator?: CreatorCreateNestedOneWithoutUserInput
    Log?: LogCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutRequestCommentHeartsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    introduction?: string | null
    totalPoint?: number
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    requestPosts?: RequestPostUncheckedCreateNestedManyWithoutUserInput
    requestFundings?: RequestFundingUncheckedCreateNestedManyWithoutUserInput
    requestComments?: RequestCommentUncheckedCreateNestedManyWithoutUserInput
    requestReactions?: RequestReactionUncheckedCreateNestedManyWithoutUserInput
    requestBookmarks?: RequestBookmarkUncheckedCreateNestedManyWithoutUserInput
    requestReports?: RequestReportUncheckedCreateNestedManyWithoutUserInput
    requestInquiries?: RequestInquiryUncheckedCreateNestedManyWithoutUserInput
    requestinquiryMessages?: RequestInquiryMessageUncheckedCreateNestedManyWithoutFromInput
    logs?: LogUncheckedCreateNestedManyWithoutReceiverInput
    points?: PointUncheckedCreateNestedManyWithoutUserInput
    rankings?: RankingUncheckedCreateNestedManyWithoutUserInput
    creatorReviews?: CreatorReviewUncheckedCreateNestedManyWithoutUserInput
    creator?: CreatorUncheckedCreateNestedOneWithoutUserInput
    Log?: LogUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutRequestCommentHeartsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRequestCommentHeartsInput, UserUncheckedCreateWithoutRequestCommentHeartsInput>
  }

  export type RequestCommentUpsertWithoutHeartsInput = {
    update: XOR<RequestCommentUpdateWithoutHeartsInput, RequestCommentUncheckedUpdateWithoutHeartsInput>
    create: XOR<RequestCommentCreateWithoutHeartsInput, RequestCommentUncheckedCreateWithoutHeartsInput>
  }

  export type RequestCommentUpdateWithoutHeartsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    request?: RequestPostUpdateOneRequiredWithoutRequestCommentsNestedInput
    user?: UserUpdateOneWithoutRequestCommentsNestedInput
    parentComment?: RequestCommentUpdateOneWithoutChildrenCommentsNestedInput
    rootId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    childrenComments?: RequestCommentUpdateManyWithoutParentCommentNestedInput
  }

  export type RequestCommentUncheckedUpdateWithoutHeartsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    requestId?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    rootId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    childrenComments?: RequestCommentUncheckedUpdateManyWithoutParentCommentNestedInput
  }

  export type UserUpsertWithoutRequestCommentHeartsInput = {
    update: XOR<UserUpdateWithoutRequestCommentHeartsInput, UserUncheckedUpdateWithoutRequestCommentHeartsInput>
    create: XOR<UserCreateWithoutRequestCommentHeartsInput, UserUncheckedCreateWithoutRequestCommentHeartsInput>
  }

  export type UserUpdateWithoutRequestCommentHeartsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoint?: IntFieldUpdateOperationsInput | number
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    requestPosts?: RequestPostUpdateManyWithoutUserNestedInput
    requestFundings?: RequestFundingUpdateManyWithoutUserNestedInput
    requestComments?: RequestCommentUpdateManyWithoutUserNestedInput
    requestReactions?: RequestReactionUpdateManyWithoutUserNestedInput
    requestBookmarks?: RequestBookmarkUpdateManyWithoutUserNestedInput
    requestReports?: RequestReportUpdateManyWithoutUserNestedInput
    requestInquiries?: RequestInquiryUpdateManyWithoutUserNestedInput
    requestinquiryMessages?: RequestInquiryMessageUpdateManyWithoutFromNestedInput
    logs?: LogUpdateManyWithoutReceiverNestedInput
    points?: PointUpdateManyWithoutUserNestedInput
    rankings?: RankingUpdateManyWithoutUserNestedInput
    creatorReviews?: CreatorReviewUpdateManyWithoutUserNestedInput
    creator?: CreatorUpdateOneWithoutUserNestedInput
    Log?: LogUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutRequestCommentHeartsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoint?: IntFieldUpdateOperationsInput | number
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    requestPosts?: RequestPostUncheckedUpdateManyWithoutUserNestedInput
    requestFundings?: RequestFundingUncheckedUpdateManyWithoutUserNestedInput
    requestComments?: RequestCommentUncheckedUpdateManyWithoutUserNestedInput
    requestReactions?: RequestReactionUncheckedUpdateManyWithoutUserNestedInput
    requestBookmarks?: RequestBookmarkUncheckedUpdateManyWithoutUserNestedInput
    requestReports?: RequestReportUncheckedUpdateManyWithoutUserNestedInput
    requestInquiries?: RequestInquiryUncheckedUpdateManyWithoutUserNestedInput
    requestinquiryMessages?: RequestInquiryMessageUncheckedUpdateManyWithoutFromNestedInput
    logs?: LogUncheckedUpdateManyWithoutReceiverNestedInput
    points?: PointUncheckedUpdateManyWithoutUserNestedInput
    rankings?: RankingUncheckedUpdateManyWithoutUserNestedInput
    creatorReviews?: CreatorReviewUncheckedUpdateManyWithoutUserNestedInput
    creator?: CreatorUncheckedUpdateOneWithoutUserNestedInput
    Log?: LogUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type RequestPostCreateWithoutRequestBookmarksInput = {
    id?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutRequestPostsInput
    title: string
    content: string
    creator?: CreatorCreateNestedOneWithoutRequestPostsInput
    category?: RequestCategoryType | null
    expires?: Date | string | null
    totalViews?: number
    status?: RequestStatusType
    solvedUrl?: string | null
    thumbnailUrl?: string | null
    refusalReason?: string | null
    totalQuantity?: number
    totalLikeScroe?: number
    isUnspecified?: boolean
    requestFundings?: RequestFundingCreateNestedManyWithoutRequestInput
    requestReactions?: RequestReactionCreateNestedManyWithoutRequestInput
    requestApplyCreators?: RequestApplyCreatorCreateNestedManyWithoutRequestInput
    requestPlatforms?: RequestPlatformCreateNestedManyWithoutRequestInput
    requestComments?: RequestCommentCreateNestedManyWithoutRequestInput
    requestReports?: RequestReportCreateNestedManyWithoutRequestInput
    requestInquirys?: RequestInquiryCreateNestedManyWithoutRequestInput
    Log?: LogCreateNestedManyWithoutRequestInput
  }

  export type RequestPostUncheckedCreateWithoutRequestBookmarksInput = {
    id?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    title: string
    content: string
    category?: RequestCategoryType | null
    creatorId?: bigint | number | null
    expires?: Date | string | null
    totalViews?: number
    status?: RequestStatusType
    solvedUrl?: string | null
    thumbnailUrl?: string | null
    refusalReason?: string | null
    totalQuantity?: number
    totalLikeScroe?: number
    isUnspecified?: boolean
    requestFundings?: RequestFundingUncheckedCreateNestedManyWithoutRequestInput
    requestReactions?: RequestReactionUncheckedCreateNestedManyWithoutRequestInput
    requestApplyCreators?: RequestApplyCreatorUncheckedCreateNestedManyWithoutRequestInput
    requestPlatforms?: RequestPlatformUncheckedCreateNestedManyWithoutRequestInput
    requestComments?: RequestCommentUncheckedCreateNestedManyWithoutRequestInput
    requestReports?: RequestReportUncheckedCreateNestedManyWithoutRequestInput
    requestInquirys?: RequestInquiryUncheckedCreateNestedManyWithoutRequestInput
    Log?: LogUncheckedCreateNestedManyWithoutRequestInput
  }

  export type RequestPostCreateOrConnectWithoutRequestBookmarksInput = {
    where: RequestPostWhereUniqueInput
    create: XOR<RequestPostCreateWithoutRequestBookmarksInput, RequestPostUncheckedCreateWithoutRequestBookmarksInput>
  }

  export type UserCreateWithoutRequestBookmarksInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    introduction?: string | null
    totalPoint?: number
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    requestPosts?: RequestPostCreateNestedManyWithoutUserInput
    requestFundings?: RequestFundingCreateNestedManyWithoutUserInput
    requestComments?: RequestCommentCreateNestedManyWithoutUserInput
    requestReactions?: RequestReactionCreateNestedManyWithoutUserInput
    requestReports?: RequestReportCreateNestedManyWithoutUserInput
    requestInquiries?: RequestInquiryCreateNestedManyWithoutUserInput
    requestinquiryMessages?: RequestInquiryMessageCreateNestedManyWithoutFromInput
    requestCommentHearts?: RequestCommentHeartCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutReceiverInput
    points?: PointCreateNestedManyWithoutUserInput
    rankings?: RankingCreateNestedManyWithoutUserInput
    creatorReviews?: CreatorReviewCreateNestedManyWithoutUserInput
    creator?: CreatorCreateNestedOneWithoutUserInput
    Log?: LogCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutRequestBookmarksInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    introduction?: string | null
    totalPoint?: number
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    requestPosts?: RequestPostUncheckedCreateNestedManyWithoutUserInput
    requestFundings?: RequestFundingUncheckedCreateNestedManyWithoutUserInput
    requestComments?: RequestCommentUncheckedCreateNestedManyWithoutUserInput
    requestReactions?: RequestReactionUncheckedCreateNestedManyWithoutUserInput
    requestReports?: RequestReportUncheckedCreateNestedManyWithoutUserInput
    requestInquiries?: RequestInquiryUncheckedCreateNestedManyWithoutUserInput
    requestinquiryMessages?: RequestInquiryMessageUncheckedCreateNestedManyWithoutFromInput
    requestCommentHearts?: RequestCommentHeartUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutReceiverInput
    points?: PointUncheckedCreateNestedManyWithoutUserInput
    rankings?: RankingUncheckedCreateNestedManyWithoutUserInput
    creatorReviews?: CreatorReviewUncheckedCreateNestedManyWithoutUserInput
    creator?: CreatorUncheckedCreateNestedOneWithoutUserInput
    Log?: LogUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutRequestBookmarksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRequestBookmarksInput, UserUncheckedCreateWithoutRequestBookmarksInput>
  }

  export type RequestPostUpsertWithoutRequestBookmarksInput = {
    update: XOR<RequestPostUpdateWithoutRequestBookmarksInput, RequestPostUncheckedUpdateWithoutRequestBookmarksInput>
    create: XOR<RequestPostCreateWithoutRequestBookmarksInput, RequestPostUncheckedCreateWithoutRequestBookmarksInput>
  }

  export type RequestPostUpdateWithoutRequestBookmarksInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutRequestPostsNestedInput
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    creator?: CreatorUpdateOneWithoutRequestPostsNestedInput
    category?: NullableEnumRequestCategoryTypeFieldUpdateOperationsInput | RequestCategoryType | null
    expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalViews?: IntFieldUpdateOperationsInput | number
    status?: EnumRequestStatusTypeFieldUpdateOperationsInput | RequestStatusType
    solvedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    refusalReason?: NullableStringFieldUpdateOperationsInput | string | null
    totalQuantity?: IntFieldUpdateOperationsInput | number
    totalLikeScroe?: IntFieldUpdateOperationsInput | number
    isUnspecified?: BoolFieldUpdateOperationsInput | boolean
    requestFundings?: RequestFundingUpdateManyWithoutRequestNestedInput
    requestReactions?: RequestReactionUpdateManyWithoutRequestNestedInput
    requestApplyCreators?: RequestApplyCreatorUpdateManyWithoutRequestNestedInput
    requestPlatforms?: RequestPlatformUpdateManyWithoutRequestNestedInput
    requestComments?: RequestCommentUpdateManyWithoutRequestNestedInput
    requestReports?: RequestReportUpdateManyWithoutRequestNestedInput
    requestInquirys?: RequestInquiryUpdateManyWithoutRequestNestedInput
    Log?: LogUpdateManyWithoutRequestNestedInput
  }

  export type RequestPostUncheckedUpdateWithoutRequestBookmarksInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableEnumRequestCategoryTypeFieldUpdateOperationsInput | RequestCategoryType | null
    creatorId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalViews?: IntFieldUpdateOperationsInput | number
    status?: EnumRequestStatusTypeFieldUpdateOperationsInput | RequestStatusType
    solvedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    refusalReason?: NullableStringFieldUpdateOperationsInput | string | null
    totalQuantity?: IntFieldUpdateOperationsInput | number
    totalLikeScroe?: IntFieldUpdateOperationsInput | number
    isUnspecified?: BoolFieldUpdateOperationsInput | boolean
    requestFundings?: RequestFundingUncheckedUpdateManyWithoutRequestNestedInput
    requestReactions?: RequestReactionUncheckedUpdateManyWithoutRequestNestedInput
    requestApplyCreators?: RequestApplyCreatorUncheckedUpdateManyWithoutRequestNestedInput
    requestPlatforms?: RequestPlatformUncheckedUpdateManyWithoutRequestNestedInput
    requestComments?: RequestCommentUncheckedUpdateManyWithoutRequestNestedInput
    requestReports?: RequestReportUncheckedUpdateManyWithoutRequestNestedInput
    requestInquirys?: RequestInquiryUncheckedUpdateManyWithoutRequestNestedInput
    Log?: LogUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type UserUpsertWithoutRequestBookmarksInput = {
    update: XOR<UserUpdateWithoutRequestBookmarksInput, UserUncheckedUpdateWithoutRequestBookmarksInput>
    create: XOR<UserCreateWithoutRequestBookmarksInput, UserUncheckedCreateWithoutRequestBookmarksInput>
  }

  export type UserUpdateWithoutRequestBookmarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoint?: IntFieldUpdateOperationsInput | number
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    requestPosts?: RequestPostUpdateManyWithoutUserNestedInput
    requestFundings?: RequestFundingUpdateManyWithoutUserNestedInput
    requestComments?: RequestCommentUpdateManyWithoutUserNestedInput
    requestReactions?: RequestReactionUpdateManyWithoutUserNestedInput
    requestReports?: RequestReportUpdateManyWithoutUserNestedInput
    requestInquiries?: RequestInquiryUpdateManyWithoutUserNestedInput
    requestinquiryMessages?: RequestInquiryMessageUpdateManyWithoutFromNestedInput
    requestCommentHearts?: RequestCommentHeartUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutReceiverNestedInput
    points?: PointUpdateManyWithoutUserNestedInput
    rankings?: RankingUpdateManyWithoutUserNestedInput
    creatorReviews?: CreatorReviewUpdateManyWithoutUserNestedInput
    creator?: CreatorUpdateOneWithoutUserNestedInput
    Log?: LogUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutRequestBookmarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoint?: IntFieldUpdateOperationsInput | number
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    requestPosts?: RequestPostUncheckedUpdateManyWithoutUserNestedInput
    requestFundings?: RequestFundingUncheckedUpdateManyWithoutUserNestedInput
    requestComments?: RequestCommentUncheckedUpdateManyWithoutUserNestedInput
    requestReactions?: RequestReactionUncheckedUpdateManyWithoutUserNestedInput
    requestReports?: RequestReportUncheckedUpdateManyWithoutUserNestedInput
    requestInquiries?: RequestInquiryUncheckedUpdateManyWithoutUserNestedInput
    requestinquiryMessages?: RequestInquiryMessageUncheckedUpdateManyWithoutFromNestedInput
    requestCommentHearts?: RequestCommentHeartUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutReceiverNestedInput
    points?: PointUncheckedUpdateManyWithoutUserNestedInput
    rankings?: RankingUncheckedUpdateManyWithoutUserNestedInput
    creatorReviews?: CreatorReviewUncheckedUpdateManyWithoutUserNestedInput
    creator?: CreatorUncheckedUpdateOneWithoutUserNestedInput
    Log?: LogUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type RequestPostCreateWithoutRequestPlatformsInput = {
    id?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutRequestPostsInput
    title: string
    content: string
    creator?: CreatorCreateNestedOneWithoutRequestPostsInput
    category?: RequestCategoryType | null
    expires?: Date | string | null
    totalViews?: number
    status?: RequestStatusType
    solvedUrl?: string | null
    thumbnailUrl?: string | null
    refusalReason?: string | null
    totalQuantity?: number
    totalLikeScroe?: number
    isUnspecified?: boolean
    requestFundings?: RequestFundingCreateNestedManyWithoutRequestInput
    requestReactions?: RequestReactionCreateNestedManyWithoutRequestInput
    requestApplyCreators?: RequestApplyCreatorCreateNestedManyWithoutRequestInput
    requestComments?: RequestCommentCreateNestedManyWithoutRequestInput
    requestBookmarks?: RequestBookmarkCreateNestedManyWithoutRequestInput
    requestReports?: RequestReportCreateNestedManyWithoutRequestInput
    requestInquirys?: RequestInquiryCreateNestedManyWithoutRequestInput
    Log?: LogCreateNestedManyWithoutRequestInput
  }

  export type RequestPostUncheckedCreateWithoutRequestPlatformsInput = {
    id?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    title: string
    content: string
    category?: RequestCategoryType | null
    creatorId?: bigint | number | null
    expires?: Date | string | null
    totalViews?: number
    status?: RequestStatusType
    solvedUrl?: string | null
    thumbnailUrl?: string | null
    refusalReason?: string | null
    totalQuantity?: number
    totalLikeScroe?: number
    isUnspecified?: boolean
    requestFundings?: RequestFundingUncheckedCreateNestedManyWithoutRequestInput
    requestReactions?: RequestReactionUncheckedCreateNestedManyWithoutRequestInput
    requestApplyCreators?: RequestApplyCreatorUncheckedCreateNestedManyWithoutRequestInput
    requestComments?: RequestCommentUncheckedCreateNestedManyWithoutRequestInput
    requestBookmarks?: RequestBookmarkUncheckedCreateNestedManyWithoutRequestInput
    requestReports?: RequestReportUncheckedCreateNestedManyWithoutRequestInput
    requestInquirys?: RequestInquiryUncheckedCreateNestedManyWithoutRequestInput
    Log?: LogUncheckedCreateNestedManyWithoutRequestInput
  }

  export type RequestPostCreateOrConnectWithoutRequestPlatformsInput = {
    where: RequestPostWhereUniqueInput
    create: XOR<RequestPostCreateWithoutRequestPlatformsInput, RequestPostUncheckedCreateWithoutRequestPlatformsInput>
  }

  export type RequestPostUpsertWithoutRequestPlatformsInput = {
    update: XOR<RequestPostUpdateWithoutRequestPlatformsInput, RequestPostUncheckedUpdateWithoutRequestPlatformsInput>
    create: XOR<RequestPostCreateWithoutRequestPlatformsInput, RequestPostUncheckedCreateWithoutRequestPlatformsInput>
  }

  export type RequestPostUpdateWithoutRequestPlatformsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutRequestPostsNestedInput
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    creator?: CreatorUpdateOneWithoutRequestPostsNestedInput
    category?: NullableEnumRequestCategoryTypeFieldUpdateOperationsInput | RequestCategoryType | null
    expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalViews?: IntFieldUpdateOperationsInput | number
    status?: EnumRequestStatusTypeFieldUpdateOperationsInput | RequestStatusType
    solvedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    refusalReason?: NullableStringFieldUpdateOperationsInput | string | null
    totalQuantity?: IntFieldUpdateOperationsInput | number
    totalLikeScroe?: IntFieldUpdateOperationsInput | number
    isUnspecified?: BoolFieldUpdateOperationsInput | boolean
    requestFundings?: RequestFundingUpdateManyWithoutRequestNestedInput
    requestReactions?: RequestReactionUpdateManyWithoutRequestNestedInput
    requestApplyCreators?: RequestApplyCreatorUpdateManyWithoutRequestNestedInput
    requestComments?: RequestCommentUpdateManyWithoutRequestNestedInput
    requestBookmarks?: RequestBookmarkUpdateManyWithoutRequestNestedInput
    requestReports?: RequestReportUpdateManyWithoutRequestNestedInput
    requestInquirys?: RequestInquiryUpdateManyWithoutRequestNestedInput
    Log?: LogUpdateManyWithoutRequestNestedInput
  }

  export type RequestPostUncheckedUpdateWithoutRequestPlatformsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableEnumRequestCategoryTypeFieldUpdateOperationsInput | RequestCategoryType | null
    creatorId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalViews?: IntFieldUpdateOperationsInput | number
    status?: EnumRequestStatusTypeFieldUpdateOperationsInput | RequestStatusType
    solvedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    refusalReason?: NullableStringFieldUpdateOperationsInput | string | null
    totalQuantity?: IntFieldUpdateOperationsInput | number
    totalLikeScroe?: IntFieldUpdateOperationsInput | number
    isUnspecified?: BoolFieldUpdateOperationsInput | boolean
    requestFundings?: RequestFundingUncheckedUpdateManyWithoutRequestNestedInput
    requestReactions?: RequestReactionUncheckedUpdateManyWithoutRequestNestedInput
    requestApplyCreators?: RequestApplyCreatorUncheckedUpdateManyWithoutRequestNestedInput
    requestComments?: RequestCommentUncheckedUpdateManyWithoutRequestNestedInput
    requestBookmarks?: RequestBookmarkUncheckedUpdateManyWithoutRequestNestedInput
    requestReports?: RequestReportUncheckedUpdateManyWithoutRequestNestedInput
    requestInquirys?: RequestInquiryUncheckedUpdateManyWithoutRequestNestedInput
    Log?: LogUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type RequestPostCreateWithoutRequestApplyCreatorsInput = {
    id?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutRequestPostsInput
    title: string
    content: string
    creator?: CreatorCreateNestedOneWithoutRequestPostsInput
    category?: RequestCategoryType | null
    expires?: Date | string | null
    totalViews?: number
    status?: RequestStatusType
    solvedUrl?: string | null
    thumbnailUrl?: string | null
    refusalReason?: string | null
    totalQuantity?: number
    totalLikeScroe?: number
    isUnspecified?: boolean
    requestFundings?: RequestFundingCreateNestedManyWithoutRequestInput
    requestReactions?: RequestReactionCreateNestedManyWithoutRequestInput
    requestPlatforms?: RequestPlatformCreateNestedManyWithoutRequestInput
    requestComments?: RequestCommentCreateNestedManyWithoutRequestInput
    requestBookmarks?: RequestBookmarkCreateNestedManyWithoutRequestInput
    requestReports?: RequestReportCreateNestedManyWithoutRequestInput
    requestInquirys?: RequestInquiryCreateNestedManyWithoutRequestInput
    Log?: LogCreateNestedManyWithoutRequestInput
  }

  export type RequestPostUncheckedCreateWithoutRequestApplyCreatorsInput = {
    id?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    title: string
    content: string
    category?: RequestCategoryType | null
    creatorId?: bigint | number | null
    expires?: Date | string | null
    totalViews?: number
    status?: RequestStatusType
    solvedUrl?: string | null
    thumbnailUrl?: string | null
    refusalReason?: string | null
    totalQuantity?: number
    totalLikeScroe?: number
    isUnspecified?: boolean
    requestFundings?: RequestFundingUncheckedCreateNestedManyWithoutRequestInput
    requestReactions?: RequestReactionUncheckedCreateNestedManyWithoutRequestInput
    requestPlatforms?: RequestPlatformUncheckedCreateNestedManyWithoutRequestInput
    requestComments?: RequestCommentUncheckedCreateNestedManyWithoutRequestInput
    requestBookmarks?: RequestBookmarkUncheckedCreateNestedManyWithoutRequestInput
    requestReports?: RequestReportUncheckedCreateNestedManyWithoutRequestInput
    requestInquirys?: RequestInquiryUncheckedCreateNestedManyWithoutRequestInput
    Log?: LogUncheckedCreateNestedManyWithoutRequestInput
  }

  export type RequestPostCreateOrConnectWithoutRequestApplyCreatorsInput = {
    where: RequestPostWhereUniqueInput
    create: XOR<RequestPostCreateWithoutRequestApplyCreatorsInput, RequestPostUncheckedCreateWithoutRequestApplyCreatorsInput>
  }

  export type CreatorCreateWithoutRequestApplyCreatorsInput = {
    id?: bigint | number
    user: UserCreateNestedOneWithoutCreatorInput
    createdAt?: Date | string
    requestPosts?: RequestPostCreateNestedManyWithoutCreatorInput
    requestInquiries?: RequestInquiryCreateNestedManyWithoutCreatorInput
    creatorAuths?: CreatorAuthCreateNestedManyWithoutCreatorInput
    creatorReviews?: CreatorReviewCreateNestedManyWithoutCreatorInput
  }

  export type CreatorUncheckedCreateWithoutRequestApplyCreatorsInput = {
    id?: bigint | number
    userId: string
    createdAt?: Date | string
    requestPosts?: RequestPostUncheckedCreateNestedManyWithoutCreatorInput
    requestInquiries?: RequestInquiryUncheckedCreateNestedManyWithoutCreatorInput
    creatorAuths?: CreatorAuthUncheckedCreateNestedManyWithoutCreatorInput
    creatorReviews?: CreatorReviewUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type CreatorCreateOrConnectWithoutRequestApplyCreatorsInput = {
    where: CreatorWhereUniqueInput
    create: XOR<CreatorCreateWithoutRequestApplyCreatorsInput, CreatorUncheckedCreateWithoutRequestApplyCreatorsInput>
  }

  export type RequestPostUpsertWithoutRequestApplyCreatorsInput = {
    update: XOR<RequestPostUpdateWithoutRequestApplyCreatorsInput, RequestPostUncheckedUpdateWithoutRequestApplyCreatorsInput>
    create: XOR<RequestPostCreateWithoutRequestApplyCreatorsInput, RequestPostUncheckedCreateWithoutRequestApplyCreatorsInput>
  }

  export type RequestPostUpdateWithoutRequestApplyCreatorsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutRequestPostsNestedInput
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    creator?: CreatorUpdateOneWithoutRequestPostsNestedInput
    category?: NullableEnumRequestCategoryTypeFieldUpdateOperationsInput | RequestCategoryType | null
    expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalViews?: IntFieldUpdateOperationsInput | number
    status?: EnumRequestStatusTypeFieldUpdateOperationsInput | RequestStatusType
    solvedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    refusalReason?: NullableStringFieldUpdateOperationsInput | string | null
    totalQuantity?: IntFieldUpdateOperationsInput | number
    totalLikeScroe?: IntFieldUpdateOperationsInput | number
    isUnspecified?: BoolFieldUpdateOperationsInput | boolean
    requestFundings?: RequestFundingUpdateManyWithoutRequestNestedInput
    requestReactions?: RequestReactionUpdateManyWithoutRequestNestedInput
    requestPlatforms?: RequestPlatformUpdateManyWithoutRequestNestedInput
    requestComments?: RequestCommentUpdateManyWithoutRequestNestedInput
    requestBookmarks?: RequestBookmarkUpdateManyWithoutRequestNestedInput
    requestReports?: RequestReportUpdateManyWithoutRequestNestedInput
    requestInquirys?: RequestInquiryUpdateManyWithoutRequestNestedInput
    Log?: LogUpdateManyWithoutRequestNestedInput
  }

  export type RequestPostUncheckedUpdateWithoutRequestApplyCreatorsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableEnumRequestCategoryTypeFieldUpdateOperationsInput | RequestCategoryType | null
    creatorId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalViews?: IntFieldUpdateOperationsInput | number
    status?: EnumRequestStatusTypeFieldUpdateOperationsInput | RequestStatusType
    solvedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    refusalReason?: NullableStringFieldUpdateOperationsInput | string | null
    totalQuantity?: IntFieldUpdateOperationsInput | number
    totalLikeScroe?: IntFieldUpdateOperationsInput | number
    isUnspecified?: BoolFieldUpdateOperationsInput | boolean
    requestFundings?: RequestFundingUncheckedUpdateManyWithoutRequestNestedInput
    requestReactions?: RequestReactionUncheckedUpdateManyWithoutRequestNestedInput
    requestPlatforms?: RequestPlatformUncheckedUpdateManyWithoutRequestNestedInput
    requestComments?: RequestCommentUncheckedUpdateManyWithoutRequestNestedInput
    requestBookmarks?: RequestBookmarkUncheckedUpdateManyWithoutRequestNestedInput
    requestReports?: RequestReportUncheckedUpdateManyWithoutRequestNestedInput
    requestInquirys?: RequestInquiryUncheckedUpdateManyWithoutRequestNestedInput
    Log?: LogUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type CreatorUpsertWithoutRequestApplyCreatorsInput = {
    update: XOR<CreatorUpdateWithoutRequestApplyCreatorsInput, CreatorUncheckedUpdateWithoutRequestApplyCreatorsInput>
    create: XOR<CreatorCreateWithoutRequestApplyCreatorsInput, CreatorUncheckedCreateWithoutRequestApplyCreatorsInput>
  }

  export type CreatorUpdateWithoutRequestApplyCreatorsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user?: UserUpdateOneRequiredWithoutCreatorNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestPosts?: RequestPostUpdateManyWithoutCreatorNestedInput
    requestInquiries?: RequestInquiryUpdateManyWithoutCreatorNestedInput
    creatorAuths?: CreatorAuthUpdateManyWithoutCreatorNestedInput
    creatorReviews?: CreatorReviewUpdateManyWithoutCreatorNestedInput
  }

  export type CreatorUncheckedUpdateWithoutRequestApplyCreatorsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestPosts?: RequestPostUncheckedUpdateManyWithoutCreatorNestedInput
    requestInquiries?: RequestInquiryUncheckedUpdateManyWithoutCreatorNestedInput
    creatorAuths?: CreatorAuthUncheckedUpdateManyWithoutCreatorNestedInput
    creatorReviews?: CreatorReviewUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type RequestPostCreateWithoutRequestReportsInput = {
    id?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutRequestPostsInput
    title: string
    content: string
    creator?: CreatorCreateNestedOneWithoutRequestPostsInput
    category?: RequestCategoryType | null
    expires?: Date | string | null
    totalViews?: number
    status?: RequestStatusType
    solvedUrl?: string | null
    thumbnailUrl?: string | null
    refusalReason?: string | null
    totalQuantity?: number
    totalLikeScroe?: number
    isUnspecified?: boolean
    requestFundings?: RequestFundingCreateNestedManyWithoutRequestInput
    requestReactions?: RequestReactionCreateNestedManyWithoutRequestInput
    requestApplyCreators?: RequestApplyCreatorCreateNestedManyWithoutRequestInput
    requestPlatforms?: RequestPlatformCreateNestedManyWithoutRequestInput
    requestComments?: RequestCommentCreateNestedManyWithoutRequestInput
    requestBookmarks?: RequestBookmarkCreateNestedManyWithoutRequestInput
    requestInquirys?: RequestInquiryCreateNestedManyWithoutRequestInput
    Log?: LogCreateNestedManyWithoutRequestInput
  }

  export type RequestPostUncheckedCreateWithoutRequestReportsInput = {
    id?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    title: string
    content: string
    category?: RequestCategoryType | null
    creatorId?: bigint | number | null
    expires?: Date | string | null
    totalViews?: number
    status?: RequestStatusType
    solvedUrl?: string | null
    thumbnailUrl?: string | null
    refusalReason?: string | null
    totalQuantity?: number
    totalLikeScroe?: number
    isUnspecified?: boolean
    requestFundings?: RequestFundingUncheckedCreateNestedManyWithoutRequestInput
    requestReactions?: RequestReactionUncheckedCreateNestedManyWithoutRequestInput
    requestApplyCreators?: RequestApplyCreatorUncheckedCreateNestedManyWithoutRequestInput
    requestPlatforms?: RequestPlatformUncheckedCreateNestedManyWithoutRequestInput
    requestComments?: RequestCommentUncheckedCreateNestedManyWithoutRequestInput
    requestBookmarks?: RequestBookmarkUncheckedCreateNestedManyWithoutRequestInput
    requestInquirys?: RequestInquiryUncheckedCreateNestedManyWithoutRequestInput
    Log?: LogUncheckedCreateNestedManyWithoutRequestInput
  }

  export type RequestPostCreateOrConnectWithoutRequestReportsInput = {
    where: RequestPostWhereUniqueInput
    create: XOR<RequestPostCreateWithoutRequestReportsInput, RequestPostUncheckedCreateWithoutRequestReportsInput>
  }

  export type UserCreateWithoutRequestReportsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    introduction?: string | null
    totalPoint?: number
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    requestPosts?: RequestPostCreateNestedManyWithoutUserInput
    requestFundings?: RequestFundingCreateNestedManyWithoutUserInput
    requestComments?: RequestCommentCreateNestedManyWithoutUserInput
    requestReactions?: RequestReactionCreateNestedManyWithoutUserInput
    requestBookmarks?: RequestBookmarkCreateNestedManyWithoutUserInput
    requestInquiries?: RequestInquiryCreateNestedManyWithoutUserInput
    requestinquiryMessages?: RequestInquiryMessageCreateNestedManyWithoutFromInput
    requestCommentHearts?: RequestCommentHeartCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutReceiverInput
    points?: PointCreateNestedManyWithoutUserInput
    rankings?: RankingCreateNestedManyWithoutUserInput
    creatorReviews?: CreatorReviewCreateNestedManyWithoutUserInput
    creator?: CreatorCreateNestedOneWithoutUserInput
    Log?: LogCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutRequestReportsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    introduction?: string | null
    totalPoint?: number
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    requestPosts?: RequestPostUncheckedCreateNestedManyWithoutUserInput
    requestFundings?: RequestFundingUncheckedCreateNestedManyWithoutUserInput
    requestComments?: RequestCommentUncheckedCreateNestedManyWithoutUserInput
    requestReactions?: RequestReactionUncheckedCreateNestedManyWithoutUserInput
    requestBookmarks?: RequestBookmarkUncheckedCreateNestedManyWithoutUserInput
    requestInquiries?: RequestInquiryUncheckedCreateNestedManyWithoutUserInput
    requestinquiryMessages?: RequestInquiryMessageUncheckedCreateNestedManyWithoutFromInput
    requestCommentHearts?: RequestCommentHeartUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutReceiverInput
    points?: PointUncheckedCreateNestedManyWithoutUserInput
    rankings?: RankingUncheckedCreateNestedManyWithoutUserInput
    creatorReviews?: CreatorReviewUncheckedCreateNestedManyWithoutUserInput
    creator?: CreatorUncheckedCreateNestedOneWithoutUserInput
    Log?: LogUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutRequestReportsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRequestReportsInput, UserUncheckedCreateWithoutRequestReportsInput>
  }

  export type RequestPostUpsertWithoutRequestReportsInput = {
    update: XOR<RequestPostUpdateWithoutRequestReportsInput, RequestPostUncheckedUpdateWithoutRequestReportsInput>
    create: XOR<RequestPostCreateWithoutRequestReportsInput, RequestPostUncheckedCreateWithoutRequestReportsInput>
  }

  export type RequestPostUpdateWithoutRequestReportsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutRequestPostsNestedInput
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    creator?: CreatorUpdateOneWithoutRequestPostsNestedInput
    category?: NullableEnumRequestCategoryTypeFieldUpdateOperationsInput | RequestCategoryType | null
    expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalViews?: IntFieldUpdateOperationsInput | number
    status?: EnumRequestStatusTypeFieldUpdateOperationsInput | RequestStatusType
    solvedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    refusalReason?: NullableStringFieldUpdateOperationsInput | string | null
    totalQuantity?: IntFieldUpdateOperationsInput | number
    totalLikeScroe?: IntFieldUpdateOperationsInput | number
    isUnspecified?: BoolFieldUpdateOperationsInput | boolean
    requestFundings?: RequestFundingUpdateManyWithoutRequestNestedInput
    requestReactions?: RequestReactionUpdateManyWithoutRequestNestedInput
    requestApplyCreators?: RequestApplyCreatorUpdateManyWithoutRequestNestedInput
    requestPlatforms?: RequestPlatformUpdateManyWithoutRequestNestedInput
    requestComments?: RequestCommentUpdateManyWithoutRequestNestedInput
    requestBookmarks?: RequestBookmarkUpdateManyWithoutRequestNestedInput
    requestInquirys?: RequestInquiryUpdateManyWithoutRequestNestedInput
    Log?: LogUpdateManyWithoutRequestNestedInput
  }

  export type RequestPostUncheckedUpdateWithoutRequestReportsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableEnumRequestCategoryTypeFieldUpdateOperationsInput | RequestCategoryType | null
    creatorId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalViews?: IntFieldUpdateOperationsInput | number
    status?: EnumRequestStatusTypeFieldUpdateOperationsInput | RequestStatusType
    solvedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    refusalReason?: NullableStringFieldUpdateOperationsInput | string | null
    totalQuantity?: IntFieldUpdateOperationsInput | number
    totalLikeScroe?: IntFieldUpdateOperationsInput | number
    isUnspecified?: BoolFieldUpdateOperationsInput | boolean
    requestFundings?: RequestFundingUncheckedUpdateManyWithoutRequestNestedInput
    requestReactions?: RequestReactionUncheckedUpdateManyWithoutRequestNestedInput
    requestApplyCreators?: RequestApplyCreatorUncheckedUpdateManyWithoutRequestNestedInput
    requestPlatforms?: RequestPlatformUncheckedUpdateManyWithoutRequestNestedInput
    requestComments?: RequestCommentUncheckedUpdateManyWithoutRequestNestedInput
    requestBookmarks?: RequestBookmarkUncheckedUpdateManyWithoutRequestNestedInput
    requestInquirys?: RequestInquiryUncheckedUpdateManyWithoutRequestNestedInput
    Log?: LogUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type UserUpsertWithoutRequestReportsInput = {
    update: XOR<UserUpdateWithoutRequestReportsInput, UserUncheckedUpdateWithoutRequestReportsInput>
    create: XOR<UserCreateWithoutRequestReportsInput, UserUncheckedCreateWithoutRequestReportsInput>
  }

  export type UserUpdateWithoutRequestReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoint?: IntFieldUpdateOperationsInput | number
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    requestPosts?: RequestPostUpdateManyWithoutUserNestedInput
    requestFundings?: RequestFundingUpdateManyWithoutUserNestedInput
    requestComments?: RequestCommentUpdateManyWithoutUserNestedInput
    requestReactions?: RequestReactionUpdateManyWithoutUserNestedInput
    requestBookmarks?: RequestBookmarkUpdateManyWithoutUserNestedInput
    requestInquiries?: RequestInquiryUpdateManyWithoutUserNestedInput
    requestinquiryMessages?: RequestInquiryMessageUpdateManyWithoutFromNestedInput
    requestCommentHearts?: RequestCommentHeartUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutReceiverNestedInput
    points?: PointUpdateManyWithoutUserNestedInput
    rankings?: RankingUpdateManyWithoutUserNestedInput
    creatorReviews?: CreatorReviewUpdateManyWithoutUserNestedInput
    creator?: CreatorUpdateOneWithoutUserNestedInput
    Log?: LogUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutRequestReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoint?: IntFieldUpdateOperationsInput | number
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    requestPosts?: RequestPostUncheckedUpdateManyWithoutUserNestedInput
    requestFundings?: RequestFundingUncheckedUpdateManyWithoutUserNestedInput
    requestComments?: RequestCommentUncheckedUpdateManyWithoutUserNestedInput
    requestReactions?: RequestReactionUncheckedUpdateManyWithoutUserNestedInput
    requestBookmarks?: RequestBookmarkUncheckedUpdateManyWithoutUserNestedInput
    requestInquiries?: RequestInquiryUncheckedUpdateManyWithoutUserNestedInput
    requestinquiryMessages?: RequestInquiryMessageUncheckedUpdateManyWithoutFromNestedInput
    requestCommentHearts?: RequestCommentHeartUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutReceiverNestedInput
    points?: PointUncheckedUpdateManyWithoutUserNestedInput
    rankings?: RankingUncheckedUpdateManyWithoutUserNestedInput
    creatorReviews?: CreatorReviewUncheckedUpdateManyWithoutUserNestedInput
    creator?: CreatorUncheckedUpdateOneWithoutUserNestedInput
    Log?: LogUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type RequestPostCreateWithoutRequestInquirysInput = {
    id?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutRequestPostsInput
    title: string
    content: string
    creator?: CreatorCreateNestedOneWithoutRequestPostsInput
    category?: RequestCategoryType | null
    expires?: Date | string | null
    totalViews?: number
    status?: RequestStatusType
    solvedUrl?: string | null
    thumbnailUrl?: string | null
    refusalReason?: string | null
    totalQuantity?: number
    totalLikeScroe?: number
    isUnspecified?: boolean
    requestFundings?: RequestFundingCreateNestedManyWithoutRequestInput
    requestReactions?: RequestReactionCreateNestedManyWithoutRequestInput
    requestApplyCreators?: RequestApplyCreatorCreateNestedManyWithoutRequestInput
    requestPlatforms?: RequestPlatformCreateNestedManyWithoutRequestInput
    requestComments?: RequestCommentCreateNestedManyWithoutRequestInput
    requestBookmarks?: RequestBookmarkCreateNestedManyWithoutRequestInput
    requestReports?: RequestReportCreateNestedManyWithoutRequestInput
    Log?: LogCreateNestedManyWithoutRequestInput
  }

  export type RequestPostUncheckedCreateWithoutRequestInquirysInput = {
    id?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    title: string
    content: string
    category?: RequestCategoryType | null
    creatorId?: bigint | number | null
    expires?: Date | string | null
    totalViews?: number
    status?: RequestStatusType
    solvedUrl?: string | null
    thumbnailUrl?: string | null
    refusalReason?: string | null
    totalQuantity?: number
    totalLikeScroe?: number
    isUnspecified?: boolean
    requestFundings?: RequestFundingUncheckedCreateNestedManyWithoutRequestInput
    requestReactions?: RequestReactionUncheckedCreateNestedManyWithoutRequestInput
    requestApplyCreators?: RequestApplyCreatorUncheckedCreateNestedManyWithoutRequestInput
    requestPlatforms?: RequestPlatformUncheckedCreateNestedManyWithoutRequestInput
    requestComments?: RequestCommentUncheckedCreateNestedManyWithoutRequestInput
    requestBookmarks?: RequestBookmarkUncheckedCreateNestedManyWithoutRequestInput
    requestReports?: RequestReportUncheckedCreateNestedManyWithoutRequestInput
    Log?: LogUncheckedCreateNestedManyWithoutRequestInput
  }

  export type RequestPostCreateOrConnectWithoutRequestInquirysInput = {
    where: RequestPostWhereUniqueInput
    create: XOR<RequestPostCreateWithoutRequestInquirysInput, RequestPostUncheckedCreateWithoutRequestInquirysInput>
  }

  export type CreatorCreateWithoutRequestInquiriesInput = {
    id?: bigint | number
    user: UserCreateNestedOneWithoutCreatorInput
    createdAt?: Date | string
    requestPosts?: RequestPostCreateNestedManyWithoutCreatorInput
    requestApplyCreators?: RequestApplyCreatorCreateNestedManyWithoutCreatorInput
    creatorAuths?: CreatorAuthCreateNestedManyWithoutCreatorInput
    creatorReviews?: CreatorReviewCreateNestedManyWithoutCreatorInput
  }

  export type CreatorUncheckedCreateWithoutRequestInquiriesInput = {
    id?: bigint | number
    userId: string
    createdAt?: Date | string
    requestPosts?: RequestPostUncheckedCreateNestedManyWithoutCreatorInput
    requestApplyCreators?: RequestApplyCreatorUncheckedCreateNestedManyWithoutCreatorInput
    creatorAuths?: CreatorAuthUncheckedCreateNestedManyWithoutCreatorInput
    creatorReviews?: CreatorReviewUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type CreatorCreateOrConnectWithoutRequestInquiriesInput = {
    where: CreatorWhereUniqueInput
    create: XOR<CreatorCreateWithoutRequestInquiriesInput, CreatorUncheckedCreateWithoutRequestInquiriesInput>
  }

  export type UserCreateWithoutRequestInquiriesInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    introduction?: string | null
    totalPoint?: number
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    requestPosts?: RequestPostCreateNestedManyWithoutUserInput
    requestFundings?: RequestFundingCreateNestedManyWithoutUserInput
    requestComments?: RequestCommentCreateNestedManyWithoutUserInput
    requestReactions?: RequestReactionCreateNestedManyWithoutUserInput
    requestBookmarks?: RequestBookmarkCreateNestedManyWithoutUserInput
    requestReports?: RequestReportCreateNestedManyWithoutUserInput
    requestinquiryMessages?: RequestInquiryMessageCreateNestedManyWithoutFromInput
    requestCommentHearts?: RequestCommentHeartCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutReceiverInput
    points?: PointCreateNestedManyWithoutUserInput
    rankings?: RankingCreateNestedManyWithoutUserInput
    creatorReviews?: CreatorReviewCreateNestedManyWithoutUserInput
    creator?: CreatorCreateNestedOneWithoutUserInput
    Log?: LogCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutRequestInquiriesInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    introduction?: string | null
    totalPoint?: number
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    requestPosts?: RequestPostUncheckedCreateNestedManyWithoutUserInput
    requestFundings?: RequestFundingUncheckedCreateNestedManyWithoutUserInput
    requestComments?: RequestCommentUncheckedCreateNestedManyWithoutUserInput
    requestReactions?: RequestReactionUncheckedCreateNestedManyWithoutUserInput
    requestBookmarks?: RequestBookmarkUncheckedCreateNestedManyWithoutUserInput
    requestReports?: RequestReportUncheckedCreateNestedManyWithoutUserInput
    requestinquiryMessages?: RequestInquiryMessageUncheckedCreateNestedManyWithoutFromInput
    requestCommentHearts?: RequestCommentHeartUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutReceiverInput
    points?: PointUncheckedCreateNestedManyWithoutUserInput
    rankings?: RankingUncheckedCreateNestedManyWithoutUserInput
    creatorReviews?: CreatorReviewUncheckedCreateNestedManyWithoutUserInput
    creator?: CreatorUncheckedCreateNestedOneWithoutUserInput
    Log?: LogUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutRequestInquiriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRequestInquiriesInput, UserUncheckedCreateWithoutRequestInquiriesInput>
  }

  export type RequestInquiryMessageCreateWithoutRoomInput = {
    id?: bigint | number
    from: UserCreateNestedOneWithoutRequestinquiryMessagesInput
    text: string
    fileUrl?: string | null
    type?: MessageType
    isRead?: boolean | null
    createdAt?: Date | string
  }

  export type RequestInquiryMessageUncheckedCreateWithoutRoomInput = {
    id?: bigint | number
    fromId: string
    text: string
    fileUrl?: string | null
    type?: MessageType
    isRead?: boolean | null
    createdAt?: Date | string
  }

  export type RequestInquiryMessageCreateOrConnectWithoutRoomInput = {
    where: RequestInquiryMessageWhereUniqueInput
    create: XOR<RequestInquiryMessageCreateWithoutRoomInput, RequestInquiryMessageUncheckedCreateWithoutRoomInput>
  }

  export type RequestInquiryMessageCreateManyRoomInputEnvelope = {
    data: Enumerable<RequestInquiryMessageCreateManyRoomInput>
    skipDuplicates?: boolean
  }

  export type RequestPostUpsertWithoutRequestInquirysInput = {
    update: XOR<RequestPostUpdateWithoutRequestInquirysInput, RequestPostUncheckedUpdateWithoutRequestInquirysInput>
    create: XOR<RequestPostCreateWithoutRequestInquirysInput, RequestPostUncheckedCreateWithoutRequestInquirysInput>
  }

  export type RequestPostUpdateWithoutRequestInquirysInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutRequestPostsNestedInput
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    creator?: CreatorUpdateOneWithoutRequestPostsNestedInput
    category?: NullableEnumRequestCategoryTypeFieldUpdateOperationsInput | RequestCategoryType | null
    expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalViews?: IntFieldUpdateOperationsInput | number
    status?: EnumRequestStatusTypeFieldUpdateOperationsInput | RequestStatusType
    solvedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    refusalReason?: NullableStringFieldUpdateOperationsInput | string | null
    totalQuantity?: IntFieldUpdateOperationsInput | number
    totalLikeScroe?: IntFieldUpdateOperationsInput | number
    isUnspecified?: BoolFieldUpdateOperationsInput | boolean
    requestFundings?: RequestFundingUpdateManyWithoutRequestNestedInput
    requestReactions?: RequestReactionUpdateManyWithoutRequestNestedInput
    requestApplyCreators?: RequestApplyCreatorUpdateManyWithoutRequestNestedInput
    requestPlatforms?: RequestPlatformUpdateManyWithoutRequestNestedInput
    requestComments?: RequestCommentUpdateManyWithoutRequestNestedInput
    requestBookmarks?: RequestBookmarkUpdateManyWithoutRequestNestedInput
    requestReports?: RequestReportUpdateManyWithoutRequestNestedInput
    Log?: LogUpdateManyWithoutRequestNestedInput
  }

  export type RequestPostUncheckedUpdateWithoutRequestInquirysInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableEnumRequestCategoryTypeFieldUpdateOperationsInput | RequestCategoryType | null
    creatorId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalViews?: IntFieldUpdateOperationsInput | number
    status?: EnumRequestStatusTypeFieldUpdateOperationsInput | RequestStatusType
    solvedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    refusalReason?: NullableStringFieldUpdateOperationsInput | string | null
    totalQuantity?: IntFieldUpdateOperationsInput | number
    totalLikeScroe?: IntFieldUpdateOperationsInput | number
    isUnspecified?: BoolFieldUpdateOperationsInput | boolean
    requestFundings?: RequestFundingUncheckedUpdateManyWithoutRequestNestedInput
    requestReactions?: RequestReactionUncheckedUpdateManyWithoutRequestNestedInput
    requestApplyCreators?: RequestApplyCreatorUncheckedUpdateManyWithoutRequestNestedInput
    requestPlatforms?: RequestPlatformUncheckedUpdateManyWithoutRequestNestedInput
    requestComments?: RequestCommentUncheckedUpdateManyWithoutRequestNestedInput
    requestBookmarks?: RequestBookmarkUncheckedUpdateManyWithoutRequestNestedInput
    requestReports?: RequestReportUncheckedUpdateManyWithoutRequestNestedInput
    Log?: LogUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type CreatorUpsertWithoutRequestInquiriesInput = {
    update: XOR<CreatorUpdateWithoutRequestInquiriesInput, CreatorUncheckedUpdateWithoutRequestInquiriesInput>
    create: XOR<CreatorCreateWithoutRequestInquiriesInput, CreatorUncheckedCreateWithoutRequestInquiriesInput>
  }

  export type CreatorUpdateWithoutRequestInquiriesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user?: UserUpdateOneRequiredWithoutCreatorNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestPosts?: RequestPostUpdateManyWithoutCreatorNestedInput
    requestApplyCreators?: RequestApplyCreatorUpdateManyWithoutCreatorNestedInput
    creatorAuths?: CreatorAuthUpdateManyWithoutCreatorNestedInput
    creatorReviews?: CreatorReviewUpdateManyWithoutCreatorNestedInput
  }

  export type CreatorUncheckedUpdateWithoutRequestInquiriesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestPosts?: RequestPostUncheckedUpdateManyWithoutCreatorNestedInput
    requestApplyCreators?: RequestApplyCreatorUncheckedUpdateManyWithoutCreatorNestedInput
    creatorAuths?: CreatorAuthUncheckedUpdateManyWithoutCreatorNestedInput
    creatorReviews?: CreatorReviewUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserUpsertWithoutRequestInquiriesInput = {
    update: XOR<UserUpdateWithoutRequestInquiriesInput, UserUncheckedUpdateWithoutRequestInquiriesInput>
    create: XOR<UserCreateWithoutRequestInquiriesInput, UserUncheckedCreateWithoutRequestInquiriesInput>
  }

  export type UserUpdateWithoutRequestInquiriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoint?: IntFieldUpdateOperationsInput | number
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    requestPosts?: RequestPostUpdateManyWithoutUserNestedInput
    requestFundings?: RequestFundingUpdateManyWithoutUserNestedInput
    requestComments?: RequestCommentUpdateManyWithoutUserNestedInput
    requestReactions?: RequestReactionUpdateManyWithoutUserNestedInput
    requestBookmarks?: RequestBookmarkUpdateManyWithoutUserNestedInput
    requestReports?: RequestReportUpdateManyWithoutUserNestedInput
    requestinquiryMessages?: RequestInquiryMessageUpdateManyWithoutFromNestedInput
    requestCommentHearts?: RequestCommentHeartUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutReceiverNestedInput
    points?: PointUpdateManyWithoutUserNestedInput
    rankings?: RankingUpdateManyWithoutUserNestedInput
    creatorReviews?: CreatorReviewUpdateManyWithoutUserNestedInput
    creator?: CreatorUpdateOneWithoutUserNestedInput
    Log?: LogUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutRequestInquiriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoint?: IntFieldUpdateOperationsInput | number
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    requestPosts?: RequestPostUncheckedUpdateManyWithoutUserNestedInput
    requestFundings?: RequestFundingUncheckedUpdateManyWithoutUserNestedInput
    requestComments?: RequestCommentUncheckedUpdateManyWithoutUserNestedInput
    requestReactions?: RequestReactionUncheckedUpdateManyWithoutUserNestedInput
    requestBookmarks?: RequestBookmarkUncheckedUpdateManyWithoutUserNestedInput
    requestReports?: RequestReportUncheckedUpdateManyWithoutUserNestedInput
    requestinquiryMessages?: RequestInquiryMessageUncheckedUpdateManyWithoutFromNestedInput
    requestCommentHearts?: RequestCommentHeartUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutReceiverNestedInput
    points?: PointUncheckedUpdateManyWithoutUserNestedInput
    rankings?: RankingUncheckedUpdateManyWithoutUserNestedInput
    creatorReviews?: CreatorReviewUncheckedUpdateManyWithoutUserNestedInput
    creator?: CreatorUncheckedUpdateOneWithoutUserNestedInput
    Log?: LogUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type RequestInquiryMessageUpsertWithWhereUniqueWithoutRoomInput = {
    where: RequestInquiryMessageWhereUniqueInput
    update: XOR<RequestInquiryMessageUpdateWithoutRoomInput, RequestInquiryMessageUncheckedUpdateWithoutRoomInput>
    create: XOR<RequestInquiryMessageCreateWithoutRoomInput, RequestInquiryMessageUncheckedCreateWithoutRoomInput>
  }

  export type RequestInquiryMessageUpdateWithWhereUniqueWithoutRoomInput = {
    where: RequestInquiryMessageWhereUniqueInput
    data: XOR<RequestInquiryMessageUpdateWithoutRoomInput, RequestInquiryMessageUncheckedUpdateWithoutRoomInput>
  }

  export type RequestInquiryMessageUpdateManyWithWhereWithoutRoomInput = {
    where: RequestInquiryMessageScalarWhereInput
    data: XOR<RequestInquiryMessageUpdateManyMutationInput, RequestInquiryMessageUncheckedUpdateManyWithoutRequestInquiryMessagesInput>
  }

  export type RequestInquiryCreateWithoutRequestInquiryMessagesInput = {
    id?: bigint | number
    request: RequestPostCreateNestedOneWithoutRequestInquirysInput
    creator?: CreatorCreateNestedOneWithoutRequestInquiriesInput
    user?: UserCreateNestedOneWithoutRequestInquiriesInput
    createdAt?: Date | string
  }

  export type RequestInquiryUncheckedCreateWithoutRequestInquiryMessagesInput = {
    id?: bigint | number
    requestId: bigint | number
    creatorId?: bigint | number | null
    userId?: string | null
    createdAt?: Date | string
  }

  export type RequestInquiryCreateOrConnectWithoutRequestInquiryMessagesInput = {
    where: RequestInquiryWhereUniqueInput
    create: XOR<RequestInquiryCreateWithoutRequestInquiryMessagesInput, RequestInquiryUncheckedCreateWithoutRequestInquiryMessagesInput>
  }

  export type UserCreateWithoutRequestinquiryMessagesInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    introduction?: string | null
    totalPoint?: number
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    requestPosts?: RequestPostCreateNestedManyWithoutUserInput
    requestFundings?: RequestFundingCreateNestedManyWithoutUserInput
    requestComments?: RequestCommentCreateNestedManyWithoutUserInput
    requestReactions?: RequestReactionCreateNestedManyWithoutUserInput
    requestBookmarks?: RequestBookmarkCreateNestedManyWithoutUserInput
    requestReports?: RequestReportCreateNestedManyWithoutUserInput
    requestInquiries?: RequestInquiryCreateNestedManyWithoutUserInput
    requestCommentHearts?: RequestCommentHeartCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutReceiverInput
    points?: PointCreateNestedManyWithoutUserInput
    rankings?: RankingCreateNestedManyWithoutUserInput
    creatorReviews?: CreatorReviewCreateNestedManyWithoutUserInput
    creator?: CreatorCreateNestedOneWithoutUserInput
    Log?: LogCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutRequestinquiryMessagesInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    introduction?: string | null
    totalPoint?: number
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    requestPosts?: RequestPostUncheckedCreateNestedManyWithoutUserInput
    requestFundings?: RequestFundingUncheckedCreateNestedManyWithoutUserInput
    requestComments?: RequestCommentUncheckedCreateNestedManyWithoutUserInput
    requestReactions?: RequestReactionUncheckedCreateNestedManyWithoutUserInput
    requestBookmarks?: RequestBookmarkUncheckedCreateNestedManyWithoutUserInput
    requestReports?: RequestReportUncheckedCreateNestedManyWithoutUserInput
    requestInquiries?: RequestInquiryUncheckedCreateNestedManyWithoutUserInput
    requestCommentHearts?: RequestCommentHeartUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutReceiverInput
    points?: PointUncheckedCreateNestedManyWithoutUserInput
    rankings?: RankingUncheckedCreateNestedManyWithoutUserInput
    creatorReviews?: CreatorReviewUncheckedCreateNestedManyWithoutUserInput
    creator?: CreatorUncheckedCreateNestedOneWithoutUserInput
    Log?: LogUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutRequestinquiryMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRequestinquiryMessagesInput, UserUncheckedCreateWithoutRequestinquiryMessagesInput>
  }

  export type RequestInquiryUpsertWithoutRequestInquiryMessagesInput = {
    update: XOR<RequestInquiryUpdateWithoutRequestInquiryMessagesInput, RequestInquiryUncheckedUpdateWithoutRequestInquiryMessagesInput>
    create: XOR<RequestInquiryCreateWithoutRequestInquiryMessagesInput, RequestInquiryUncheckedCreateWithoutRequestInquiryMessagesInput>
  }

  export type RequestInquiryUpdateWithoutRequestInquiryMessagesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    request?: RequestPostUpdateOneRequiredWithoutRequestInquirysNestedInput
    creator?: CreatorUpdateOneWithoutRequestInquiriesNestedInput
    user?: UserUpdateOneWithoutRequestInquiriesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestInquiryUncheckedUpdateWithoutRequestInquiryMessagesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    requestId?: BigIntFieldUpdateOperationsInput | bigint | number
    creatorId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutRequestinquiryMessagesInput = {
    update: XOR<UserUpdateWithoutRequestinquiryMessagesInput, UserUncheckedUpdateWithoutRequestinquiryMessagesInput>
    create: XOR<UserCreateWithoutRequestinquiryMessagesInput, UserUncheckedCreateWithoutRequestinquiryMessagesInput>
  }

  export type UserUpdateWithoutRequestinquiryMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoint?: IntFieldUpdateOperationsInput | number
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    requestPosts?: RequestPostUpdateManyWithoutUserNestedInput
    requestFundings?: RequestFundingUpdateManyWithoutUserNestedInput
    requestComments?: RequestCommentUpdateManyWithoutUserNestedInput
    requestReactions?: RequestReactionUpdateManyWithoutUserNestedInput
    requestBookmarks?: RequestBookmarkUpdateManyWithoutUserNestedInput
    requestReports?: RequestReportUpdateManyWithoutUserNestedInput
    requestInquiries?: RequestInquiryUpdateManyWithoutUserNestedInput
    requestCommentHearts?: RequestCommentHeartUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutReceiverNestedInput
    points?: PointUpdateManyWithoutUserNestedInput
    rankings?: RankingUpdateManyWithoutUserNestedInput
    creatorReviews?: CreatorReviewUpdateManyWithoutUserNestedInput
    creator?: CreatorUpdateOneWithoutUserNestedInput
    Log?: LogUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutRequestinquiryMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoint?: IntFieldUpdateOperationsInput | number
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    requestPosts?: RequestPostUncheckedUpdateManyWithoutUserNestedInput
    requestFundings?: RequestFundingUncheckedUpdateManyWithoutUserNestedInput
    requestComments?: RequestCommentUncheckedUpdateManyWithoutUserNestedInput
    requestReactions?: RequestReactionUncheckedUpdateManyWithoutUserNestedInput
    requestBookmarks?: RequestBookmarkUncheckedUpdateManyWithoutUserNestedInput
    requestReports?: RequestReportUncheckedUpdateManyWithoutUserNestedInput
    requestInquiries?: RequestInquiryUncheckedUpdateManyWithoutUserNestedInput
    requestCommentHearts?: RequestCommentHeartUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutReceiverNestedInput
    points?: PointUncheckedUpdateManyWithoutUserNestedInput
    rankings?: RankingUncheckedUpdateManyWithoutUserNestedInput
    creatorReviews?: CreatorReviewUncheckedUpdateManyWithoutUserNestedInput
    creator?: CreatorUncheckedUpdateOneWithoutUserNestedInput
    Log?: LogUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserCreateWithoutPointsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    introduction?: string | null
    totalPoint?: number
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    requestPosts?: RequestPostCreateNestedManyWithoutUserInput
    requestFundings?: RequestFundingCreateNestedManyWithoutUserInput
    requestComments?: RequestCommentCreateNestedManyWithoutUserInput
    requestReactions?: RequestReactionCreateNestedManyWithoutUserInput
    requestBookmarks?: RequestBookmarkCreateNestedManyWithoutUserInput
    requestReports?: RequestReportCreateNestedManyWithoutUserInput
    requestInquiries?: RequestInquiryCreateNestedManyWithoutUserInput
    requestinquiryMessages?: RequestInquiryMessageCreateNestedManyWithoutFromInput
    requestCommentHearts?: RequestCommentHeartCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutReceiverInput
    rankings?: RankingCreateNestedManyWithoutUserInput
    creatorReviews?: CreatorReviewCreateNestedManyWithoutUserInput
    creator?: CreatorCreateNestedOneWithoutUserInput
    Log?: LogCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutPointsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    introduction?: string | null
    totalPoint?: number
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    requestPosts?: RequestPostUncheckedCreateNestedManyWithoutUserInput
    requestFundings?: RequestFundingUncheckedCreateNestedManyWithoutUserInput
    requestComments?: RequestCommentUncheckedCreateNestedManyWithoutUserInput
    requestReactions?: RequestReactionUncheckedCreateNestedManyWithoutUserInput
    requestBookmarks?: RequestBookmarkUncheckedCreateNestedManyWithoutUserInput
    requestReports?: RequestReportUncheckedCreateNestedManyWithoutUserInput
    requestInquiries?: RequestInquiryUncheckedCreateNestedManyWithoutUserInput
    requestinquiryMessages?: RequestInquiryMessageUncheckedCreateNestedManyWithoutFromInput
    requestCommentHearts?: RequestCommentHeartUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutReceiverInput
    rankings?: RankingUncheckedCreateNestedManyWithoutUserInput
    creatorReviews?: CreatorReviewUncheckedCreateNestedManyWithoutUserInput
    creator?: CreatorUncheckedCreateNestedOneWithoutUserInput
    Log?: LogUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutPointsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPointsInput, UserUncheckedCreateWithoutPointsInput>
  }

  export type UserUpsertWithoutPointsInput = {
    update: XOR<UserUpdateWithoutPointsInput, UserUncheckedUpdateWithoutPointsInput>
    create: XOR<UserCreateWithoutPointsInput, UserUncheckedCreateWithoutPointsInput>
  }

  export type UserUpdateWithoutPointsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoint?: IntFieldUpdateOperationsInput | number
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    requestPosts?: RequestPostUpdateManyWithoutUserNestedInput
    requestFundings?: RequestFundingUpdateManyWithoutUserNestedInput
    requestComments?: RequestCommentUpdateManyWithoutUserNestedInput
    requestReactions?: RequestReactionUpdateManyWithoutUserNestedInput
    requestBookmarks?: RequestBookmarkUpdateManyWithoutUserNestedInput
    requestReports?: RequestReportUpdateManyWithoutUserNestedInput
    requestInquiries?: RequestInquiryUpdateManyWithoutUserNestedInput
    requestinquiryMessages?: RequestInquiryMessageUpdateManyWithoutFromNestedInput
    requestCommentHearts?: RequestCommentHeartUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutReceiverNestedInput
    rankings?: RankingUpdateManyWithoutUserNestedInput
    creatorReviews?: CreatorReviewUpdateManyWithoutUserNestedInput
    creator?: CreatorUpdateOneWithoutUserNestedInput
    Log?: LogUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutPointsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoint?: IntFieldUpdateOperationsInput | number
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    requestPosts?: RequestPostUncheckedUpdateManyWithoutUserNestedInput
    requestFundings?: RequestFundingUncheckedUpdateManyWithoutUserNestedInput
    requestComments?: RequestCommentUncheckedUpdateManyWithoutUserNestedInput
    requestReactions?: RequestReactionUncheckedUpdateManyWithoutUserNestedInput
    requestBookmarks?: RequestBookmarkUncheckedUpdateManyWithoutUserNestedInput
    requestReports?: RequestReportUncheckedUpdateManyWithoutUserNestedInput
    requestInquiries?: RequestInquiryUncheckedUpdateManyWithoutUserNestedInput
    requestinquiryMessages?: RequestInquiryMessageUncheckedUpdateManyWithoutFromNestedInput
    requestCommentHearts?: RequestCommentHeartUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutReceiverNestedInput
    rankings?: RankingUncheckedUpdateManyWithoutUserNestedInput
    creatorReviews?: CreatorReviewUncheckedUpdateManyWithoutUserNestedInput
    creator?: CreatorUncheckedUpdateOneWithoutUserNestedInput
    Log?: LogUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserCreateWithoutRankingsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    introduction?: string | null
    totalPoint?: number
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    requestPosts?: RequestPostCreateNestedManyWithoutUserInput
    requestFundings?: RequestFundingCreateNestedManyWithoutUserInput
    requestComments?: RequestCommentCreateNestedManyWithoutUserInput
    requestReactions?: RequestReactionCreateNestedManyWithoutUserInput
    requestBookmarks?: RequestBookmarkCreateNestedManyWithoutUserInput
    requestReports?: RequestReportCreateNestedManyWithoutUserInput
    requestInquiries?: RequestInquiryCreateNestedManyWithoutUserInput
    requestinquiryMessages?: RequestInquiryMessageCreateNestedManyWithoutFromInput
    requestCommentHearts?: RequestCommentHeartCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutReceiverInput
    points?: PointCreateNestedManyWithoutUserInput
    creatorReviews?: CreatorReviewCreateNestedManyWithoutUserInput
    creator?: CreatorCreateNestedOneWithoutUserInput
    Log?: LogCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutRankingsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    introduction?: string | null
    totalPoint?: number
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    requestPosts?: RequestPostUncheckedCreateNestedManyWithoutUserInput
    requestFundings?: RequestFundingUncheckedCreateNestedManyWithoutUserInput
    requestComments?: RequestCommentUncheckedCreateNestedManyWithoutUserInput
    requestReactions?: RequestReactionUncheckedCreateNestedManyWithoutUserInput
    requestBookmarks?: RequestBookmarkUncheckedCreateNestedManyWithoutUserInput
    requestReports?: RequestReportUncheckedCreateNestedManyWithoutUserInput
    requestInquiries?: RequestInquiryUncheckedCreateNestedManyWithoutUserInput
    requestinquiryMessages?: RequestInquiryMessageUncheckedCreateNestedManyWithoutFromInput
    requestCommentHearts?: RequestCommentHeartUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutReceiverInput
    points?: PointUncheckedCreateNestedManyWithoutUserInput
    creatorReviews?: CreatorReviewUncheckedCreateNestedManyWithoutUserInput
    creator?: CreatorUncheckedCreateNestedOneWithoutUserInput
    Log?: LogUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutRankingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRankingsInput, UserUncheckedCreateWithoutRankingsInput>
  }

  export type UserUpsertWithoutRankingsInput = {
    update: XOR<UserUpdateWithoutRankingsInput, UserUncheckedUpdateWithoutRankingsInput>
    create: XOR<UserCreateWithoutRankingsInput, UserUncheckedCreateWithoutRankingsInput>
  }

  export type UserUpdateWithoutRankingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoint?: IntFieldUpdateOperationsInput | number
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    requestPosts?: RequestPostUpdateManyWithoutUserNestedInput
    requestFundings?: RequestFundingUpdateManyWithoutUserNestedInput
    requestComments?: RequestCommentUpdateManyWithoutUserNestedInput
    requestReactions?: RequestReactionUpdateManyWithoutUserNestedInput
    requestBookmarks?: RequestBookmarkUpdateManyWithoutUserNestedInput
    requestReports?: RequestReportUpdateManyWithoutUserNestedInput
    requestInquiries?: RequestInquiryUpdateManyWithoutUserNestedInput
    requestinquiryMessages?: RequestInquiryMessageUpdateManyWithoutFromNestedInput
    requestCommentHearts?: RequestCommentHeartUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutReceiverNestedInput
    points?: PointUpdateManyWithoutUserNestedInput
    creatorReviews?: CreatorReviewUpdateManyWithoutUserNestedInput
    creator?: CreatorUpdateOneWithoutUserNestedInput
    Log?: LogUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutRankingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoint?: IntFieldUpdateOperationsInput | number
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    requestPosts?: RequestPostUncheckedUpdateManyWithoutUserNestedInput
    requestFundings?: RequestFundingUncheckedUpdateManyWithoutUserNestedInput
    requestComments?: RequestCommentUncheckedUpdateManyWithoutUserNestedInput
    requestReactions?: RequestReactionUncheckedUpdateManyWithoutUserNestedInput
    requestBookmarks?: RequestBookmarkUncheckedUpdateManyWithoutUserNestedInput
    requestReports?: RequestReportUncheckedUpdateManyWithoutUserNestedInput
    requestInquiries?: RequestInquiryUncheckedUpdateManyWithoutUserNestedInput
    requestinquiryMessages?: RequestInquiryMessageUncheckedUpdateManyWithoutFromNestedInput
    requestCommentHearts?: RequestCommentHeartUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutReceiverNestedInput
    points?: PointUncheckedUpdateManyWithoutUserNestedInput
    creatorReviews?: CreatorReviewUncheckedUpdateManyWithoutUserNestedInput
    creator?: CreatorUncheckedUpdateOneWithoutUserNestedInput
    Log?: LogUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserCreateWithoutCreatorInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    introduction?: string | null
    totalPoint?: number
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    requestPosts?: RequestPostCreateNestedManyWithoutUserInput
    requestFundings?: RequestFundingCreateNestedManyWithoutUserInput
    requestComments?: RequestCommentCreateNestedManyWithoutUserInput
    requestReactions?: RequestReactionCreateNestedManyWithoutUserInput
    requestBookmarks?: RequestBookmarkCreateNestedManyWithoutUserInput
    requestReports?: RequestReportCreateNestedManyWithoutUserInput
    requestInquiries?: RequestInquiryCreateNestedManyWithoutUserInput
    requestinquiryMessages?: RequestInquiryMessageCreateNestedManyWithoutFromInput
    requestCommentHearts?: RequestCommentHeartCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutReceiverInput
    points?: PointCreateNestedManyWithoutUserInput
    rankings?: RankingCreateNestedManyWithoutUserInput
    creatorReviews?: CreatorReviewCreateNestedManyWithoutUserInput
    Log?: LogCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutCreatorInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    introduction?: string | null
    totalPoint?: number
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    requestPosts?: RequestPostUncheckedCreateNestedManyWithoutUserInput
    requestFundings?: RequestFundingUncheckedCreateNestedManyWithoutUserInput
    requestComments?: RequestCommentUncheckedCreateNestedManyWithoutUserInput
    requestReactions?: RequestReactionUncheckedCreateNestedManyWithoutUserInput
    requestBookmarks?: RequestBookmarkUncheckedCreateNestedManyWithoutUserInput
    requestReports?: RequestReportUncheckedCreateNestedManyWithoutUserInput
    requestInquiries?: RequestInquiryUncheckedCreateNestedManyWithoutUserInput
    requestinquiryMessages?: RequestInquiryMessageUncheckedCreateNestedManyWithoutFromInput
    requestCommentHearts?: RequestCommentHeartUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutReceiverInput
    points?: PointUncheckedCreateNestedManyWithoutUserInput
    rankings?: RankingUncheckedCreateNestedManyWithoutUserInput
    creatorReviews?: CreatorReviewUncheckedCreateNestedManyWithoutUserInput
    Log?: LogUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutCreatorInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatorInput, UserUncheckedCreateWithoutCreatorInput>
  }

  export type RequestPostCreateWithoutCreatorInput = {
    id?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutRequestPostsInput
    title: string
    content: string
    category?: RequestCategoryType | null
    expires?: Date | string | null
    totalViews?: number
    status?: RequestStatusType
    solvedUrl?: string | null
    thumbnailUrl?: string | null
    refusalReason?: string | null
    totalQuantity?: number
    totalLikeScroe?: number
    isUnspecified?: boolean
    requestFundings?: RequestFundingCreateNestedManyWithoutRequestInput
    requestReactions?: RequestReactionCreateNestedManyWithoutRequestInput
    requestApplyCreators?: RequestApplyCreatorCreateNestedManyWithoutRequestInput
    requestPlatforms?: RequestPlatformCreateNestedManyWithoutRequestInput
    requestComments?: RequestCommentCreateNestedManyWithoutRequestInput
    requestBookmarks?: RequestBookmarkCreateNestedManyWithoutRequestInput
    requestReports?: RequestReportCreateNestedManyWithoutRequestInput
    requestInquirys?: RequestInquiryCreateNestedManyWithoutRequestInput
    Log?: LogCreateNestedManyWithoutRequestInput
  }

  export type RequestPostUncheckedCreateWithoutCreatorInput = {
    id?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    title: string
    content: string
    category?: RequestCategoryType | null
    expires?: Date | string | null
    totalViews?: number
    status?: RequestStatusType
    solvedUrl?: string | null
    thumbnailUrl?: string | null
    refusalReason?: string | null
    totalQuantity?: number
    totalLikeScroe?: number
    isUnspecified?: boolean
    requestFundings?: RequestFundingUncheckedCreateNestedManyWithoutRequestInput
    requestReactions?: RequestReactionUncheckedCreateNestedManyWithoutRequestInput
    requestApplyCreators?: RequestApplyCreatorUncheckedCreateNestedManyWithoutRequestInput
    requestPlatforms?: RequestPlatformUncheckedCreateNestedManyWithoutRequestInput
    requestComments?: RequestCommentUncheckedCreateNestedManyWithoutRequestInput
    requestBookmarks?: RequestBookmarkUncheckedCreateNestedManyWithoutRequestInput
    requestReports?: RequestReportUncheckedCreateNestedManyWithoutRequestInput
    requestInquirys?: RequestInquiryUncheckedCreateNestedManyWithoutRequestInput
    Log?: LogUncheckedCreateNestedManyWithoutRequestInput
  }

  export type RequestPostCreateOrConnectWithoutCreatorInput = {
    where: RequestPostWhereUniqueInput
    create: XOR<RequestPostCreateWithoutCreatorInput, RequestPostUncheckedCreateWithoutCreatorInput>
  }

  export type RequestPostCreateManyCreatorInputEnvelope = {
    data: Enumerable<RequestPostCreateManyCreatorInput>
    skipDuplicates?: boolean
  }

  export type RequestApplyCreatorCreateWithoutCreatorInput = {
    id?: bigint | number
    request: RequestPostCreateNestedOneWithoutRequestApplyCreatorsInput
  }

  export type RequestApplyCreatorUncheckedCreateWithoutCreatorInput = {
    id?: bigint | number
    requestId: bigint | number
  }

  export type RequestApplyCreatorCreateOrConnectWithoutCreatorInput = {
    where: RequestApplyCreatorWhereUniqueInput
    create: XOR<RequestApplyCreatorCreateWithoutCreatorInput, RequestApplyCreatorUncheckedCreateWithoutCreatorInput>
  }

  export type RequestApplyCreatorCreateManyCreatorInputEnvelope = {
    data: Enumerable<RequestApplyCreatorCreateManyCreatorInput>
    skipDuplicates?: boolean
  }

  export type RequestInquiryCreateWithoutCreatorInput = {
    id?: bigint | number
    request: RequestPostCreateNestedOneWithoutRequestInquirysInput
    user?: UserCreateNestedOneWithoutRequestInquiriesInput
    requestInquiryMessages?: RequestInquiryMessageCreateNestedManyWithoutRoomInput
    createdAt?: Date | string
  }

  export type RequestInquiryUncheckedCreateWithoutCreatorInput = {
    id?: bigint | number
    requestId: bigint | number
    userId?: string | null
    requestInquiryMessages?: RequestInquiryMessageUncheckedCreateNestedManyWithoutRoomInput
    createdAt?: Date | string
  }

  export type RequestInquiryCreateOrConnectWithoutCreatorInput = {
    where: RequestInquiryWhereUniqueInput
    create: XOR<RequestInquiryCreateWithoutCreatorInput, RequestInquiryUncheckedCreateWithoutCreatorInput>
  }

  export type RequestInquiryCreateManyCreatorInputEnvelope = {
    data: Enumerable<RequestInquiryCreateManyCreatorInput>
    skipDuplicates?: boolean
  }

  export type CreatorAuthCreateWithoutCreatorInput = {
    id?: bigint | number
    isMain?: boolean
    profileUrl?: string | null
    platform: AuthPlatformType
    createdAt?: Date | string
  }

  export type CreatorAuthUncheckedCreateWithoutCreatorInput = {
    id?: bigint | number
    isMain?: boolean
    profileUrl?: string | null
    platform: AuthPlatformType
    createdAt?: Date | string
  }

  export type CreatorAuthCreateOrConnectWithoutCreatorInput = {
    where: CreatorAuthWhereUniqueInput
    create: XOR<CreatorAuthCreateWithoutCreatorInput, CreatorAuthUncheckedCreateWithoutCreatorInput>
  }

  export type CreatorAuthCreateManyCreatorInputEnvelope = {
    data: Enumerable<CreatorAuthCreateManyCreatorInput>
    skipDuplicates?: boolean
  }

  export type CreatorReviewCreateWithoutCreatorInput = {
    id?: bigint | number
    user?: UserCreateNestedOneWithoutCreatorReviewsInput
    reviewItems?: CreatorReviewItemCreateNestedManyWithoutReviewInput
    content?: string | null
    createdAt?: Date | string
  }

  export type CreatorReviewUncheckedCreateWithoutCreatorInput = {
    id?: bigint | number
    userId?: string | null
    reviewItems?: CreatorReviewItemUncheckedCreateNestedManyWithoutReviewInput
    content?: string | null
    createdAt?: Date | string
  }

  export type CreatorReviewCreateOrConnectWithoutCreatorInput = {
    where: CreatorReviewWhereUniqueInput
    create: XOR<CreatorReviewCreateWithoutCreatorInput, CreatorReviewUncheckedCreateWithoutCreatorInput>
  }

  export type CreatorReviewCreateManyCreatorInputEnvelope = {
    data: Enumerable<CreatorReviewCreateManyCreatorInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCreatorInput = {
    update: XOR<UserUpdateWithoutCreatorInput, UserUncheckedUpdateWithoutCreatorInput>
    create: XOR<UserCreateWithoutCreatorInput, UserUncheckedCreateWithoutCreatorInput>
  }

  export type UserUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoint?: IntFieldUpdateOperationsInput | number
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    requestPosts?: RequestPostUpdateManyWithoutUserNestedInput
    requestFundings?: RequestFundingUpdateManyWithoutUserNestedInput
    requestComments?: RequestCommentUpdateManyWithoutUserNestedInput
    requestReactions?: RequestReactionUpdateManyWithoutUserNestedInput
    requestBookmarks?: RequestBookmarkUpdateManyWithoutUserNestedInput
    requestReports?: RequestReportUpdateManyWithoutUserNestedInput
    requestInquiries?: RequestInquiryUpdateManyWithoutUserNestedInput
    requestinquiryMessages?: RequestInquiryMessageUpdateManyWithoutFromNestedInput
    requestCommentHearts?: RequestCommentHeartUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutReceiverNestedInput
    points?: PointUpdateManyWithoutUserNestedInput
    rankings?: RankingUpdateManyWithoutUserNestedInput
    creatorReviews?: CreatorReviewUpdateManyWithoutUserNestedInput
    Log?: LogUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoint?: IntFieldUpdateOperationsInput | number
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    requestPosts?: RequestPostUncheckedUpdateManyWithoutUserNestedInput
    requestFundings?: RequestFundingUncheckedUpdateManyWithoutUserNestedInput
    requestComments?: RequestCommentUncheckedUpdateManyWithoutUserNestedInput
    requestReactions?: RequestReactionUncheckedUpdateManyWithoutUserNestedInput
    requestBookmarks?: RequestBookmarkUncheckedUpdateManyWithoutUserNestedInput
    requestReports?: RequestReportUncheckedUpdateManyWithoutUserNestedInput
    requestInquiries?: RequestInquiryUncheckedUpdateManyWithoutUserNestedInput
    requestinquiryMessages?: RequestInquiryMessageUncheckedUpdateManyWithoutFromNestedInput
    requestCommentHearts?: RequestCommentHeartUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutReceiverNestedInput
    points?: PointUncheckedUpdateManyWithoutUserNestedInput
    rankings?: RankingUncheckedUpdateManyWithoutUserNestedInput
    creatorReviews?: CreatorReviewUncheckedUpdateManyWithoutUserNestedInput
    Log?: LogUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type RequestPostUpsertWithWhereUniqueWithoutCreatorInput = {
    where: RequestPostWhereUniqueInput
    update: XOR<RequestPostUpdateWithoutCreatorInput, RequestPostUncheckedUpdateWithoutCreatorInput>
    create: XOR<RequestPostCreateWithoutCreatorInput, RequestPostUncheckedCreateWithoutCreatorInput>
  }

  export type RequestPostUpdateWithWhereUniqueWithoutCreatorInput = {
    where: RequestPostWhereUniqueInput
    data: XOR<RequestPostUpdateWithoutCreatorInput, RequestPostUncheckedUpdateWithoutCreatorInput>
  }

  export type RequestPostUpdateManyWithWhereWithoutCreatorInput = {
    where: RequestPostScalarWhereInput
    data: XOR<RequestPostUpdateManyMutationInput, RequestPostUncheckedUpdateManyWithoutRequestPostsInput>
  }

  export type RequestApplyCreatorUpsertWithWhereUniqueWithoutCreatorInput = {
    where: RequestApplyCreatorWhereUniqueInput
    update: XOR<RequestApplyCreatorUpdateWithoutCreatorInput, RequestApplyCreatorUncheckedUpdateWithoutCreatorInput>
    create: XOR<RequestApplyCreatorCreateWithoutCreatorInput, RequestApplyCreatorUncheckedCreateWithoutCreatorInput>
  }

  export type RequestApplyCreatorUpdateWithWhereUniqueWithoutCreatorInput = {
    where: RequestApplyCreatorWhereUniqueInput
    data: XOR<RequestApplyCreatorUpdateWithoutCreatorInput, RequestApplyCreatorUncheckedUpdateWithoutCreatorInput>
  }

  export type RequestApplyCreatorUpdateManyWithWhereWithoutCreatorInput = {
    where: RequestApplyCreatorScalarWhereInput
    data: XOR<RequestApplyCreatorUpdateManyMutationInput, RequestApplyCreatorUncheckedUpdateManyWithoutRequestApplyCreatorsInput>
  }

  export type RequestInquiryUpsertWithWhereUniqueWithoutCreatorInput = {
    where: RequestInquiryWhereUniqueInput
    update: XOR<RequestInquiryUpdateWithoutCreatorInput, RequestInquiryUncheckedUpdateWithoutCreatorInput>
    create: XOR<RequestInquiryCreateWithoutCreatorInput, RequestInquiryUncheckedCreateWithoutCreatorInput>
  }

  export type RequestInquiryUpdateWithWhereUniqueWithoutCreatorInput = {
    where: RequestInquiryWhereUniqueInput
    data: XOR<RequestInquiryUpdateWithoutCreatorInput, RequestInquiryUncheckedUpdateWithoutCreatorInput>
  }

  export type RequestInquiryUpdateManyWithWhereWithoutCreatorInput = {
    where: RequestInquiryScalarWhereInput
    data: XOR<RequestInquiryUpdateManyMutationInput, RequestInquiryUncheckedUpdateManyWithoutRequestInquiriesInput>
  }

  export type CreatorAuthUpsertWithWhereUniqueWithoutCreatorInput = {
    where: CreatorAuthWhereUniqueInput
    update: XOR<CreatorAuthUpdateWithoutCreatorInput, CreatorAuthUncheckedUpdateWithoutCreatorInput>
    create: XOR<CreatorAuthCreateWithoutCreatorInput, CreatorAuthUncheckedCreateWithoutCreatorInput>
  }

  export type CreatorAuthUpdateWithWhereUniqueWithoutCreatorInput = {
    where: CreatorAuthWhereUniqueInput
    data: XOR<CreatorAuthUpdateWithoutCreatorInput, CreatorAuthUncheckedUpdateWithoutCreatorInput>
  }

  export type CreatorAuthUpdateManyWithWhereWithoutCreatorInput = {
    where: CreatorAuthScalarWhereInput
    data: XOR<CreatorAuthUpdateManyMutationInput, CreatorAuthUncheckedUpdateManyWithoutCreatorAuthsInput>
  }

  export type CreatorAuthScalarWhereInput = {
    AND?: Enumerable<CreatorAuthScalarWhereInput>
    OR?: Enumerable<CreatorAuthScalarWhereInput>
    NOT?: Enumerable<CreatorAuthScalarWhereInput>
    id?: BigIntFilter | bigint | number
    creatorId?: BigIntFilter | bigint | number
    isMain?: BoolFilter | boolean
    profileUrl?: StringNullableFilter | string | null
    platform?: EnumAuthPlatformTypeFilter | AuthPlatformType
    createdAt?: DateTimeFilter | Date | string
  }

  export type CreatorReviewUpsertWithWhereUniqueWithoutCreatorInput = {
    where: CreatorReviewWhereUniqueInput
    update: XOR<CreatorReviewUpdateWithoutCreatorInput, CreatorReviewUncheckedUpdateWithoutCreatorInput>
    create: XOR<CreatorReviewCreateWithoutCreatorInput, CreatorReviewUncheckedCreateWithoutCreatorInput>
  }

  export type CreatorReviewUpdateWithWhereUniqueWithoutCreatorInput = {
    where: CreatorReviewWhereUniqueInput
    data: XOR<CreatorReviewUpdateWithoutCreatorInput, CreatorReviewUncheckedUpdateWithoutCreatorInput>
  }

  export type CreatorReviewUpdateManyWithWhereWithoutCreatorInput = {
    where: CreatorReviewScalarWhereInput
    data: XOR<CreatorReviewUpdateManyMutationInput, CreatorReviewUncheckedUpdateManyWithoutCreatorReviewsInput>
  }

  export type CreatorCreateWithoutCreatorAuthsInput = {
    id?: bigint | number
    user: UserCreateNestedOneWithoutCreatorInput
    createdAt?: Date | string
    requestPosts?: RequestPostCreateNestedManyWithoutCreatorInput
    requestApplyCreators?: RequestApplyCreatorCreateNestedManyWithoutCreatorInput
    requestInquiries?: RequestInquiryCreateNestedManyWithoutCreatorInput
    creatorReviews?: CreatorReviewCreateNestedManyWithoutCreatorInput
  }

  export type CreatorUncheckedCreateWithoutCreatorAuthsInput = {
    id?: bigint | number
    userId: string
    createdAt?: Date | string
    requestPosts?: RequestPostUncheckedCreateNestedManyWithoutCreatorInput
    requestApplyCreators?: RequestApplyCreatorUncheckedCreateNestedManyWithoutCreatorInput
    requestInquiries?: RequestInquiryUncheckedCreateNestedManyWithoutCreatorInput
    creatorReviews?: CreatorReviewUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type CreatorCreateOrConnectWithoutCreatorAuthsInput = {
    where: CreatorWhereUniqueInput
    create: XOR<CreatorCreateWithoutCreatorAuthsInput, CreatorUncheckedCreateWithoutCreatorAuthsInput>
  }

  export type CreatorUpsertWithoutCreatorAuthsInput = {
    update: XOR<CreatorUpdateWithoutCreatorAuthsInput, CreatorUncheckedUpdateWithoutCreatorAuthsInput>
    create: XOR<CreatorCreateWithoutCreatorAuthsInput, CreatorUncheckedCreateWithoutCreatorAuthsInput>
  }

  export type CreatorUpdateWithoutCreatorAuthsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user?: UserUpdateOneRequiredWithoutCreatorNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestPosts?: RequestPostUpdateManyWithoutCreatorNestedInput
    requestApplyCreators?: RequestApplyCreatorUpdateManyWithoutCreatorNestedInput
    requestInquiries?: RequestInquiryUpdateManyWithoutCreatorNestedInput
    creatorReviews?: CreatorReviewUpdateManyWithoutCreatorNestedInput
  }

  export type CreatorUncheckedUpdateWithoutCreatorAuthsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestPosts?: RequestPostUncheckedUpdateManyWithoutCreatorNestedInput
    requestApplyCreators?: RequestApplyCreatorUncheckedUpdateManyWithoutCreatorNestedInput
    requestInquiries?: RequestInquiryUncheckedUpdateManyWithoutCreatorNestedInput
    creatorReviews?: CreatorReviewUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type CreatorCreateWithoutCreatorReviewsInput = {
    id?: bigint | number
    user: UserCreateNestedOneWithoutCreatorInput
    createdAt?: Date | string
    requestPosts?: RequestPostCreateNestedManyWithoutCreatorInput
    requestApplyCreators?: RequestApplyCreatorCreateNestedManyWithoutCreatorInput
    requestInquiries?: RequestInquiryCreateNestedManyWithoutCreatorInput
    creatorAuths?: CreatorAuthCreateNestedManyWithoutCreatorInput
  }

  export type CreatorUncheckedCreateWithoutCreatorReviewsInput = {
    id?: bigint | number
    userId: string
    createdAt?: Date | string
    requestPosts?: RequestPostUncheckedCreateNestedManyWithoutCreatorInput
    requestApplyCreators?: RequestApplyCreatorUncheckedCreateNestedManyWithoutCreatorInput
    requestInquiries?: RequestInquiryUncheckedCreateNestedManyWithoutCreatorInput
    creatorAuths?: CreatorAuthUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type CreatorCreateOrConnectWithoutCreatorReviewsInput = {
    where: CreatorWhereUniqueInput
    create: XOR<CreatorCreateWithoutCreatorReviewsInput, CreatorUncheckedCreateWithoutCreatorReviewsInput>
  }

  export type UserCreateWithoutCreatorReviewsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    introduction?: string | null
    totalPoint?: number
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    requestPosts?: RequestPostCreateNestedManyWithoutUserInput
    requestFundings?: RequestFundingCreateNestedManyWithoutUserInput
    requestComments?: RequestCommentCreateNestedManyWithoutUserInput
    requestReactions?: RequestReactionCreateNestedManyWithoutUserInput
    requestBookmarks?: RequestBookmarkCreateNestedManyWithoutUserInput
    requestReports?: RequestReportCreateNestedManyWithoutUserInput
    requestInquiries?: RequestInquiryCreateNestedManyWithoutUserInput
    requestinquiryMessages?: RequestInquiryMessageCreateNestedManyWithoutFromInput
    requestCommentHearts?: RequestCommentHeartCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutReceiverInput
    points?: PointCreateNestedManyWithoutUserInput
    rankings?: RankingCreateNestedManyWithoutUserInput
    creator?: CreatorCreateNestedOneWithoutUserInput
    Log?: LogCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutCreatorReviewsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    introduction?: string | null
    totalPoint?: number
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    requestPosts?: RequestPostUncheckedCreateNestedManyWithoutUserInput
    requestFundings?: RequestFundingUncheckedCreateNestedManyWithoutUserInput
    requestComments?: RequestCommentUncheckedCreateNestedManyWithoutUserInput
    requestReactions?: RequestReactionUncheckedCreateNestedManyWithoutUserInput
    requestBookmarks?: RequestBookmarkUncheckedCreateNestedManyWithoutUserInput
    requestReports?: RequestReportUncheckedCreateNestedManyWithoutUserInput
    requestInquiries?: RequestInquiryUncheckedCreateNestedManyWithoutUserInput
    requestinquiryMessages?: RequestInquiryMessageUncheckedCreateNestedManyWithoutFromInput
    requestCommentHearts?: RequestCommentHeartUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutReceiverInput
    points?: PointUncheckedCreateNestedManyWithoutUserInput
    rankings?: RankingUncheckedCreateNestedManyWithoutUserInput
    creator?: CreatorUncheckedCreateNestedOneWithoutUserInput
    Log?: LogUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutCreatorReviewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatorReviewsInput, UserUncheckedCreateWithoutCreatorReviewsInput>
  }

  export type CreatorReviewItemCreateWithoutReviewInput = {
    id?: bigint | number
    content: string
    isChecked?: boolean
  }

  export type CreatorReviewItemUncheckedCreateWithoutReviewInput = {
    id?: bigint | number
    content: string
    isChecked?: boolean
  }

  export type CreatorReviewItemCreateOrConnectWithoutReviewInput = {
    where: CreatorReviewItemWhereUniqueInput
    create: XOR<CreatorReviewItemCreateWithoutReviewInput, CreatorReviewItemUncheckedCreateWithoutReviewInput>
  }

  export type CreatorReviewItemCreateManyReviewInputEnvelope = {
    data: Enumerable<CreatorReviewItemCreateManyReviewInput>
    skipDuplicates?: boolean
  }

  export type CreatorUpsertWithoutCreatorReviewsInput = {
    update: XOR<CreatorUpdateWithoutCreatorReviewsInput, CreatorUncheckedUpdateWithoutCreatorReviewsInput>
    create: XOR<CreatorCreateWithoutCreatorReviewsInput, CreatorUncheckedCreateWithoutCreatorReviewsInput>
  }

  export type CreatorUpdateWithoutCreatorReviewsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user?: UserUpdateOneRequiredWithoutCreatorNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestPosts?: RequestPostUpdateManyWithoutCreatorNestedInput
    requestApplyCreators?: RequestApplyCreatorUpdateManyWithoutCreatorNestedInput
    requestInquiries?: RequestInquiryUpdateManyWithoutCreatorNestedInput
    creatorAuths?: CreatorAuthUpdateManyWithoutCreatorNestedInput
  }

  export type CreatorUncheckedUpdateWithoutCreatorReviewsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestPosts?: RequestPostUncheckedUpdateManyWithoutCreatorNestedInput
    requestApplyCreators?: RequestApplyCreatorUncheckedUpdateManyWithoutCreatorNestedInput
    requestInquiries?: RequestInquiryUncheckedUpdateManyWithoutCreatorNestedInput
    creatorAuths?: CreatorAuthUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserUpsertWithoutCreatorReviewsInput = {
    update: XOR<UserUpdateWithoutCreatorReviewsInput, UserUncheckedUpdateWithoutCreatorReviewsInput>
    create: XOR<UserCreateWithoutCreatorReviewsInput, UserUncheckedCreateWithoutCreatorReviewsInput>
  }

  export type UserUpdateWithoutCreatorReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoint?: IntFieldUpdateOperationsInput | number
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    requestPosts?: RequestPostUpdateManyWithoutUserNestedInput
    requestFundings?: RequestFundingUpdateManyWithoutUserNestedInput
    requestComments?: RequestCommentUpdateManyWithoutUserNestedInput
    requestReactions?: RequestReactionUpdateManyWithoutUserNestedInput
    requestBookmarks?: RequestBookmarkUpdateManyWithoutUserNestedInput
    requestReports?: RequestReportUpdateManyWithoutUserNestedInput
    requestInquiries?: RequestInquiryUpdateManyWithoutUserNestedInput
    requestinquiryMessages?: RequestInquiryMessageUpdateManyWithoutFromNestedInput
    requestCommentHearts?: RequestCommentHeartUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutReceiverNestedInput
    points?: PointUpdateManyWithoutUserNestedInput
    rankings?: RankingUpdateManyWithoutUserNestedInput
    creator?: CreatorUpdateOneWithoutUserNestedInput
    Log?: LogUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatorReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoint?: IntFieldUpdateOperationsInput | number
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    requestPosts?: RequestPostUncheckedUpdateManyWithoutUserNestedInput
    requestFundings?: RequestFundingUncheckedUpdateManyWithoutUserNestedInput
    requestComments?: RequestCommentUncheckedUpdateManyWithoutUserNestedInput
    requestReactions?: RequestReactionUncheckedUpdateManyWithoutUserNestedInput
    requestBookmarks?: RequestBookmarkUncheckedUpdateManyWithoutUserNestedInput
    requestReports?: RequestReportUncheckedUpdateManyWithoutUserNestedInput
    requestInquiries?: RequestInquiryUncheckedUpdateManyWithoutUserNestedInput
    requestinquiryMessages?: RequestInquiryMessageUncheckedUpdateManyWithoutFromNestedInput
    requestCommentHearts?: RequestCommentHeartUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutReceiverNestedInput
    points?: PointUncheckedUpdateManyWithoutUserNestedInput
    rankings?: RankingUncheckedUpdateManyWithoutUserNestedInput
    creator?: CreatorUncheckedUpdateOneWithoutUserNestedInput
    Log?: LogUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type CreatorReviewItemUpsertWithWhereUniqueWithoutReviewInput = {
    where: CreatorReviewItemWhereUniqueInput
    update: XOR<CreatorReviewItemUpdateWithoutReviewInput, CreatorReviewItemUncheckedUpdateWithoutReviewInput>
    create: XOR<CreatorReviewItemCreateWithoutReviewInput, CreatorReviewItemUncheckedCreateWithoutReviewInput>
  }

  export type CreatorReviewItemUpdateWithWhereUniqueWithoutReviewInput = {
    where: CreatorReviewItemWhereUniqueInput
    data: XOR<CreatorReviewItemUpdateWithoutReviewInput, CreatorReviewItemUncheckedUpdateWithoutReviewInput>
  }

  export type CreatorReviewItemUpdateManyWithWhereWithoutReviewInput = {
    where: CreatorReviewItemScalarWhereInput
    data: XOR<CreatorReviewItemUpdateManyMutationInput, CreatorReviewItemUncheckedUpdateManyWithoutReviewItemsInput>
  }

  export type CreatorReviewItemScalarWhereInput = {
    AND?: Enumerable<CreatorReviewItemScalarWhereInput>
    OR?: Enumerable<CreatorReviewItemScalarWhereInput>
    NOT?: Enumerable<CreatorReviewItemScalarWhereInput>
    id?: BigIntFilter | bigint | number
    reviewId?: BigIntFilter | bigint | number
    content?: StringFilter | string
    isChecked?: BoolFilter | boolean
  }

  export type CreatorReviewCreateWithoutReviewItemsInput = {
    id?: bigint | number
    creator: CreatorCreateNestedOneWithoutCreatorReviewsInput
    user?: UserCreateNestedOneWithoutCreatorReviewsInput
    content?: string | null
    createdAt?: Date | string
  }

  export type CreatorReviewUncheckedCreateWithoutReviewItemsInput = {
    id?: bigint | number
    creatorId: bigint | number
    userId?: string | null
    content?: string | null
    createdAt?: Date | string
  }

  export type CreatorReviewCreateOrConnectWithoutReviewItemsInput = {
    where: CreatorReviewWhereUniqueInput
    create: XOR<CreatorReviewCreateWithoutReviewItemsInput, CreatorReviewUncheckedCreateWithoutReviewItemsInput>
  }

  export type CreatorReviewUpsertWithoutReviewItemsInput = {
    update: XOR<CreatorReviewUpdateWithoutReviewItemsInput, CreatorReviewUncheckedUpdateWithoutReviewItemsInput>
    create: XOR<CreatorReviewCreateWithoutReviewItemsInput, CreatorReviewUncheckedCreateWithoutReviewItemsInput>
  }

  export type CreatorReviewUpdateWithoutReviewItemsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    creator?: CreatorUpdateOneRequiredWithoutCreatorReviewsNestedInput
    user?: UserUpdateOneWithoutCreatorReviewsNestedInput
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreatorReviewUncheckedUpdateWithoutReviewItemsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    creatorId?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutLogInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    introduction?: string | null
    totalPoint?: number
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    requestPosts?: RequestPostCreateNestedManyWithoutUserInput
    requestFundings?: RequestFundingCreateNestedManyWithoutUserInput
    requestComments?: RequestCommentCreateNestedManyWithoutUserInput
    requestReactions?: RequestReactionCreateNestedManyWithoutUserInput
    requestBookmarks?: RequestBookmarkCreateNestedManyWithoutUserInput
    requestReports?: RequestReportCreateNestedManyWithoutUserInput
    requestInquiries?: RequestInquiryCreateNestedManyWithoutUserInput
    requestinquiryMessages?: RequestInquiryMessageCreateNestedManyWithoutFromInput
    requestCommentHearts?: RequestCommentHeartCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutReceiverInput
    points?: PointCreateNestedManyWithoutUserInput
    rankings?: RankingCreateNestedManyWithoutUserInput
    creatorReviews?: CreatorReviewCreateNestedManyWithoutUserInput
    creator?: CreatorCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLogInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    introduction?: string | null
    totalPoint?: number
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    requestPosts?: RequestPostUncheckedCreateNestedManyWithoutUserInput
    requestFundings?: RequestFundingUncheckedCreateNestedManyWithoutUserInput
    requestComments?: RequestCommentUncheckedCreateNestedManyWithoutUserInput
    requestReactions?: RequestReactionUncheckedCreateNestedManyWithoutUserInput
    requestBookmarks?: RequestBookmarkUncheckedCreateNestedManyWithoutUserInput
    requestReports?: RequestReportUncheckedCreateNestedManyWithoutUserInput
    requestInquiries?: RequestInquiryUncheckedCreateNestedManyWithoutUserInput
    requestinquiryMessages?: RequestInquiryMessageUncheckedCreateNestedManyWithoutFromInput
    requestCommentHearts?: RequestCommentHeartUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutReceiverInput
    points?: PointUncheckedCreateNestedManyWithoutUserInput
    rankings?: RankingUncheckedCreateNestedManyWithoutUserInput
    creatorReviews?: CreatorReviewUncheckedCreateNestedManyWithoutUserInput
    creator?: CreatorUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLogInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLogInput, UserUncheckedCreateWithoutLogInput>
  }

  export type UserCreateWithoutLogsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    introduction?: string | null
    totalPoint?: number
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    requestPosts?: RequestPostCreateNestedManyWithoutUserInput
    requestFundings?: RequestFundingCreateNestedManyWithoutUserInput
    requestComments?: RequestCommentCreateNestedManyWithoutUserInput
    requestReactions?: RequestReactionCreateNestedManyWithoutUserInput
    requestBookmarks?: RequestBookmarkCreateNestedManyWithoutUserInput
    requestReports?: RequestReportCreateNestedManyWithoutUserInput
    requestInquiries?: RequestInquiryCreateNestedManyWithoutUserInput
    requestinquiryMessages?: RequestInquiryMessageCreateNestedManyWithoutFromInput
    requestCommentHearts?: RequestCommentHeartCreateNestedManyWithoutUserInput
    points?: PointCreateNestedManyWithoutUserInput
    rankings?: RankingCreateNestedManyWithoutUserInput
    creatorReviews?: CreatorReviewCreateNestedManyWithoutUserInput
    creator?: CreatorCreateNestedOneWithoutUserInput
    Log?: LogCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutLogsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    introduction?: string | null
    totalPoint?: number
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    requestPosts?: RequestPostUncheckedCreateNestedManyWithoutUserInput
    requestFundings?: RequestFundingUncheckedCreateNestedManyWithoutUserInput
    requestComments?: RequestCommentUncheckedCreateNestedManyWithoutUserInput
    requestReactions?: RequestReactionUncheckedCreateNestedManyWithoutUserInput
    requestBookmarks?: RequestBookmarkUncheckedCreateNestedManyWithoutUserInput
    requestReports?: RequestReportUncheckedCreateNestedManyWithoutUserInput
    requestInquiries?: RequestInquiryUncheckedCreateNestedManyWithoutUserInput
    requestinquiryMessages?: RequestInquiryMessageUncheckedCreateNestedManyWithoutFromInput
    requestCommentHearts?: RequestCommentHeartUncheckedCreateNestedManyWithoutUserInput
    points?: PointUncheckedCreateNestedManyWithoutUserInput
    rankings?: RankingUncheckedCreateNestedManyWithoutUserInput
    creatorReviews?: CreatorReviewUncheckedCreateNestedManyWithoutUserInput
    creator?: CreatorUncheckedCreateNestedOneWithoutUserInput
    Log?: LogUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
  }

  export type RequestPostCreateWithoutLogInput = {
    id?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutRequestPostsInput
    title: string
    content: string
    creator?: CreatorCreateNestedOneWithoutRequestPostsInput
    category?: RequestCategoryType | null
    expires?: Date | string | null
    totalViews?: number
    status?: RequestStatusType
    solvedUrl?: string | null
    thumbnailUrl?: string | null
    refusalReason?: string | null
    totalQuantity?: number
    totalLikeScroe?: number
    isUnspecified?: boolean
    requestFundings?: RequestFundingCreateNestedManyWithoutRequestInput
    requestReactions?: RequestReactionCreateNestedManyWithoutRequestInput
    requestApplyCreators?: RequestApplyCreatorCreateNestedManyWithoutRequestInput
    requestPlatforms?: RequestPlatformCreateNestedManyWithoutRequestInput
    requestComments?: RequestCommentCreateNestedManyWithoutRequestInput
    requestBookmarks?: RequestBookmarkCreateNestedManyWithoutRequestInput
    requestReports?: RequestReportCreateNestedManyWithoutRequestInput
    requestInquirys?: RequestInquiryCreateNestedManyWithoutRequestInput
  }

  export type RequestPostUncheckedCreateWithoutLogInput = {
    id?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    title: string
    content: string
    category?: RequestCategoryType | null
    creatorId?: bigint | number | null
    expires?: Date | string | null
    totalViews?: number
    status?: RequestStatusType
    solvedUrl?: string | null
    thumbnailUrl?: string | null
    refusalReason?: string | null
    totalQuantity?: number
    totalLikeScroe?: number
    isUnspecified?: boolean
    requestFundings?: RequestFundingUncheckedCreateNestedManyWithoutRequestInput
    requestReactions?: RequestReactionUncheckedCreateNestedManyWithoutRequestInput
    requestApplyCreators?: RequestApplyCreatorUncheckedCreateNestedManyWithoutRequestInput
    requestPlatforms?: RequestPlatformUncheckedCreateNestedManyWithoutRequestInput
    requestComments?: RequestCommentUncheckedCreateNestedManyWithoutRequestInput
    requestBookmarks?: RequestBookmarkUncheckedCreateNestedManyWithoutRequestInput
    requestReports?: RequestReportUncheckedCreateNestedManyWithoutRequestInput
    requestInquirys?: RequestInquiryUncheckedCreateNestedManyWithoutRequestInput
  }

  export type RequestPostCreateOrConnectWithoutLogInput = {
    where: RequestPostWhereUniqueInput
    create: XOR<RequestPostCreateWithoutLogInput, RequestPostUncheckedCreateWithoutLogInput>
  }

  export type UserUpsertWithoutLogInput = {
    update: XOR<UserUpdateWithoutLogInput, UserUncheckedUpdateWithoutLogInput>
    create: XOR<UserCreateWithoutLogInput, UserUncheckedCreateWithoutLogInput>
  }

  export type UserUpdateWithoutLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoint?: IntFieldUpdateOperationsInput | number
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    requestPosts?: RequestPostUpdateManyWithoutUserNestedInput
    requestFundings?: RequestFundingUpdateManyWithoutUserNestedInput
    requestComments?: RequestCommentUpdateManyWithoutUserNestedInput
    requestReactions?: RequestReactionUpdateManyWithoutUserNestedInput
    requestBookmarks?: RequestBookmarkUpdateManyWithoutUserNestedInput
    requestReports?: RequestReportUpdateManyWithoutUserNestedInput
    requestInquiries?: RequestInquiryUpdateManyWithoutUserNestedInput
    requestinquiryMessages?: RequestInquiryMessageUpdateManyWithoutFromNestedInput
    requestCommentHearts?: RequestCommentHeartUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutReceiverNestedInput
    points?: PointUpdateManyWithoutUserNestedInput
    rankings?: RankingUpdateManyWithoutUserNestedInput
    creatorReviews?: CreatorReviewUpdateManyWithoutUserNestedInput
    creator?: CreatorUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoint?: IntFieldUpdateOperationsInput | number
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    requestPosts?: RequestPostUncheckedUpdateManyWithoutUserNestedInput
    requestFundings?: RequestFundingUncheckedUpdateManyWithoutUserNestedInput
    requestComments?: RequestCommentUncheckedUpdateManyWithoutUserNestedInput
    requestReactions?: RequestReactionUncheckedUpdateManyWithoutUserNestedInput
    requestBookmarks?: RequestBookmarkUncheckedUpdateManyWithoutUserNestedInput
    requestReports?: RequestReportUncheckedUpdateManyWithoutUserNestedInput
    requestInquiries?: RequestInquiryUncheckedUpdateManyWithoutUserNestedInput
    requestinquiryMessages?: RequestInquiryMessageUncheckedUpdateManyWithoutFromNestedInput
    requestCommentHearts?: RequestCommentHeartUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutReceiverNestedInput
    points?: PointUncheckedUpdateManyWithoutUserNestedInput
    rankings?: RankingUncheckedUpdateManyWithoutUserNestedInput
    creatorReviews?: CreatorReviewUncheckedUpdateManyWithoutUserNestedInput
    creator?: CreatorUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutLogsInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutLogsInput, UserUncheckedUpdateWithoutLogsInput>
    create: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
  }

  export type UserUpdateWithWhereUniqueWithoutLogsInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutLogsInput, UserUncheckedUpdateWithoutLogsInput>
  }

  export type UserUpdateManyWithWhereWithoutLogsInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutReceiverInput>
  }

  export type UserScalarWhereInput = {
    AND?: Enumerable<UserScalarWhereInput>
    OR?: Enumerable<UserScalarWhereInput>
    NOT?: Enumerable<UserScalarWhereInput>
    id?: StringFilter | string
    name?: StringNullableFilter | string | null
    email?: StringNullableFilter | string | null
    emailVerified?: DateTimeNullableFilter | Date | string | null
    image?: StringNullableFilter | string | null
    introduction?: StringNullableFilter | string | null
    totalPoint?: IntFilter | number
  }

  export type RequestPostUpsertWithoutLogInput = {
    update: XOR<RequestPostUpdateWithoutLogInput, RequestPostUncheckedUpdateWithoutLogInput>
    create: XOR<RequestPostCreateWithoutLogInput, RequestPostUncheckedCreateWithoutLogInput>
  }

  export type RequestPostUpdateWithoutLogInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutRequestPostsNestedInput
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    creator?: CreatorUpdateOneWithoutRequestPostsNestedInput
    category?: NullableEnumRequestCategoryTypeFieldUpdateOperationsInput | RequestCategoryType | null
    expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalViews?: IntFieldUpdateOperationsInput | number
    status?: EnumRequestStatusTypeFieldUpdateOperationsInput | RequestStatusType
    solvedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    refusalReason?: NullableStringFieldUpdateOperationsInput | string | null
    totalQuantity?: IntFieldUpdateOperationsInput | number
    totalLikeScroe?: IntFieldUpdateOperationsInput | number
    isUnspecified?: BoolFieldUpdateOperationsInput | boolean
    requestFundings?: RequestFundingUpdateManyWithoutRequestNestedInput
    requestReactions?: RequestReactionUpdateManyWithoutRequestNestedInput
    requestApplyCreators?: RequestApplyCreatorUpdateManyWithoutRequestNestedInput
    requestPlatforms?: RequestPlatformUpdateManyWithoutRequestNestedInput
    requestComments?: RequestCommentUpdateManyWithoutRequestNestedInput
    requestBookmarks?: RequestBookmarkUpdateManyWithoutRequestNestedInput
    requestReports?: RequestReportUpdateManyWithoutRequestNestedInput
    requestInquirys?: RequestInquiryUpdateManyWithoutRequestNestedInput
  }

  export type RequestPostUncheckedUpdateWithoutLogInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableEnumRequestCategoryTypeFieldUpdateOperationsInput | RequestCategoryType | null
    creatorId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalViews?: IntFieldUpdateOperationsInput | number
    status?: EnumRequestStatusTypeFieldUpdateOperationsInput | RequestStatusType
    solvedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    refusalReason?: NullableStringFieldUpdateOperationsInput | string | null
    totalQuantity?: IntFieldUpdateOperationsInput | number
    totalLikeScroe?: IntFieldUpdateOperationsInput | number
    isUnspecified?: BoolFieldUpdateOperationsInput | boolean
    requestFundings?: RequestFundingUncheckedUpdateManyWithoutRequestNestedInput
    requestReactions?: RequestReactionUncheckedUpdateManyWithoutRequestNestedInput
    requestApplyCreators?: RequestApplyCreatorUncheckedUpdateManyWithoutRequestNestedInput
    requestPlatforms?: RequestPlatformUncheckedUpdateManyWithoutRequestNestedInput
    requestComments?: RequestCommentUncheckedUpdateManyWithoutRequestNestedInput
    requestBookmarks?: RequestBookmarkUncheckedUpdateManyWithoutRequestNestedInput
    requestReports?: RequestReportUncheckedUpdateManyWithoutRequestNestedInput
    requestInquirys?: RequestInquiryUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type RequestPostCreateManyUserInput = {
    id?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    content: string
    category?: RequestCategoryType | null
    creatorId?: bigint | number | null
    expires?: Date | string | null
    totalViews?: number
    status?: RequestStatusType
    solvedUrl?: string | null
    thumbnailUrl?: string | null
    refusalReason?: string | null
    totalQuantity?: number
    totalLikeScroe?: number
    isUnspecified?: boolean
  }

  export type RequestFundingCreateManyUserInput = {
    id?: bigint | number
    quantity: number
    requestId?: bigint | number | null
    createdAt?: Date | string
    status?: RequestFundingStatus
  }

  export type RequestCommentCreateManyUserInput = {
    id?: bigint | number
    requestId: bigint | number
    parentId?: bigint | number | null
    rootId?: bigint | number | null
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequestReactionCreateManyUserInput = {
    id?: bigint | number
    type: ReactionType
    requestId: bigint | number
    createdAt?: Date | string
  }

  export type RequestBookmarkCreateManyUserInput = {
    id?: bigint | number
    requestId?: bigint | number | null
    createdAt?: Date | string
  }

  export type RequestReportCreateManyUserInput = {
    id?: bigint | number
    requestId: bigint | number
    content: string
    type: RequestReportType
    status: RequestReportStatus
    createdAt?: Date | string
  }

  export type RequestInquiryCreateManyUserInput = {
    id?: bigint | number
    requestId: bigint | number
    creatorId?: bigint | number | null
    createdAt?: Date | string
  }

  export type RequestInquiryMessageCreateManyFromInput = {
    id?: bigint | number
    roomId: bigint | number
    text: string
    fileUrl?: string | null
    type?: MessageType
    isRead?: boolean | null
    createdAt?: Date | string
  }

  export type RequestCommentHeartCreateManyUserInput = {
    id?: bigint | number
    requestCommentId: bigint | number
    createdAt?: Date | string
  }

  export type PointCreateManyUserInput = {
    id?: bigint | number
    quantity: number
    type: PoinType
    createdAt?: Date | string
  }

  export type RankingCreateManyUserInput = {
    id?: number
    ranking: number
    type: RankingType
    score: bigint | number
    change: number
    createdAt?: Date | string
  }

  export type CreatorReviewCreateManyUserInput = {
    id?: bigint | number
    creatorId: bigint | number
    content?: string | null
    createdAt?: Date | string
  }

  export type LogCreateManySenderInput = {
    id?: bigint | number
    logType: LogType
    message?: string | null
    isRead?: boolean | null
    requestId?: bigint | number | null
    createdAt?: Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestPostUpdateWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    creator?: CreatorUpdateOneWithoutRequestPostsNestedInput
    category?: NullableEnumRequestCategoryTypeFieldUpdateOperationsInput | RequestCategoryType | null
    expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalViews?: IntFieldUpdateOperationsInput | number
    status?: EnumRequestStatusTypeFieldUpdateOperationsInput | RequestStatusType
    solvedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    refusalReason?: NullableStringFieldUpdateOperationsInput | string | null
    totalQuantity?: IntFieldUpdateOperationsInput | number
    totalLikeScroe?: IntFieldUpdateOperationsInput | number
    isUnspecified?: BoolFieldUpdateOperationsInput | boolean
    requestFundings?: RequestFundingUpdateManyWithoutRequestNestedInput
    requestReactions?: RequestReactionUpdateManyWithoutRequestNestedInput
    requestApplyCreators?: RequestApplyCreatorUpdateManyWithoutRequestNestedInput
    requestPlatforms?: RequestPlatformUpdateManyWithoutRequestNestedInput
    requestComments?: RequestCommentUpdateManyWithoutRequestNestedInput
    requestBookmarks?: RequestBookmarkUpdateManyWithoutRequestNestedInput
    requestReports?: RequestReportUpdateManyWithoutRequestNestedInput
    requestInquirys?: RequestInquiryUpdateManyWithoutRequestNestedInput
    Log?: LogUpdateManyWithoutRequestNestedInput
  }

  export type RequestPostUncheckedUpdateWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableEnumRequestCategoryTypeFieldUpdateOperationsInput | RequestCategoryType | null
    creatorId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalViews?: IntFieldUpdateOperationsInput | number
    status?: EnumRequestStatusTypeFieldUpdateOperationsInput | RequestStatusType
    solvedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    refusalReason?: NullableStringFieldUpdateOperationsInput | string | null
    totalQuantity?: IntFieldUpdateOperationsInput | number
    totalLikeScroe?: IntFieldUpdateOperationsInput | number
    isUnspecified?: BoolFieldUpdateOperationsInput | boolean
    requestFundings?: RequestFundingUncheckedUpdateManyWithoutRequestNestedInput
    requestReactions?: RequestReactionUncheckedUpdateManyWithoutRequestNestedInput
    requestApplyCreators?: RequestApplyCreatorUncheckedUpdateManyWithoutRequestNestedInput
    requestPlatforms?: RequestPlatformUncheckedUpdateManyWithoutRequestNestedInput
    requestComments?: RequestCommentUncheckedUpdateManyWithoutRequestNestedInput
    requestBookmarks?: RequestBookmarkUncheckedUpdateManyWithoutRequestNestedInput
    requestReports?: RequestReportUncheckedUpdateManyWithoutRequestNestedInput
    requestInquirys?: RequestInquiryUncheckedUpdateManyWithoutRequestNestedInput
    Log?: LogUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type RequestPostUncheckedUpdateManyWithoutRequestPostsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableEnumRequestCategoryTypeFieldUpdateOperationsInput | RequestCategoryType | null
    creatorId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalViews?: IntFieldUpdateOperationsInput | number
    status?: EnumRequestStatusTypeFieldUpdateOperationsInput | RequestStatusType
    solvedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    refusalReason?: NullableStringFieldUpdateOperationsInput | string | null
    totalQuantity?: IntFieldUpdateOperationsInput | number
    totalLikeScroe?: IntFieldUpdateOperationsInput | number
    isUnspecified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RequestFundingUpdateWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: IntFieldUpdateOperationsInput | number
    request?: RequestPostUpdateOneWithoutRequestFundingsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRequestFundingStatusFieldUpdateOperationsInput | RequestFundingStatus
  }

  export type RequestFundingUncheckedUpdateWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: IntFieldUpdateOperationsInput | number
    requestId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRequestFundingStatusFieldUpdateOperationsInput | RequestFundingStatus
  }

  export type RequestFundingUncheckedUpdateManyWithoutRequestFundingsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: IntFieldUpdateOperationsInput | number
    requestId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRequestFundingStatusFieldUpdateOperationsInput | RequestFundingStatus
  }

  export type RequestCommentUpdateWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    request?: RequestPostUpdateOneRequiredWithoutRequestCommentsNestedInput
    parentComment?: RequestCommentUpdateOneWithoutChildrenCommentsNestedInput
    rootId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hearts?: RequestCommentHeartUpdateManyWithoutRequestCommentNestedInput
    childrenComments?: RequestCommentUpdateManyWithoutParentCommentNestedInput
  }

  export type RequestCommentUncheckedUpdateWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    requestId?: BigIntFieldUpdateOperationsInput | bigint | number
    parentId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    rootId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hearts?: RequestCommentHeartUncheckedUpdateManyWithoutRequestCommentNestedInput
    childrenComments?: RequestCommentUncheckedUpdateManyWithoutParentCommentNestedInput
  }

  export type RequestCommentUncheckedUpdateManyWithoutRequestCommentsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    requestId?: BigIntFieldUpdateOperationsInput | bigint | number
    parentId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    rootId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestReactionUpdateWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    type?: EnumReactionTypeFieldUpdateOperationsInput | ReactionType
    request?: RequestPostUpdateOneRequiredWithoutRequestReactionsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestReactionUncheckedUpdateWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    type?: EnumReactionTypeFieldUpdateOperationsInput | ReactionType
    requestId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestReactionUncheckedUpdateManyWithoutRequestReactionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    type?: EnumReactionTypeFieldUpdateOperationsInput | ReactionType
    requestId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestBookmarkUpdateWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    request?: RequestPostUpdateOneWithoutRequestBookmarksNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestBookmarkUncheckedUpdateWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    requestId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestBookmarkUncheckedUpdateManyWithoutRequestBookmarksInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    requestId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestReportUpdateWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    request?: RequestPostUpdateOneRequiredWithoutRequestReportsNestedInput
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumRequestReportTypeFieldUpdateOperationsInput | RequestReportType
    status?: EnumRequestReportStatusFieldUpdateOperationsInput | RequestReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestReportUncheckedUpdateWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    requestId?: BigIntFieldUpdateOperationsInput | bigint | number
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumRequestReportTypeFieldUpdateOperationsInput | RequestReportType
    status?: EnumRequestReportStatusFieldUpdateOperationsInput | RequestReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestReportUncheckedUpdateManyWithoutRequestReportsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    requestId?: BigIntFieldUpdateOperationsInput | bigint | number
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumRequestReportTypeFieldUpdateOperationsInput | RequestReportType
    status?: EnumRequestReportStatusFieldUpdateOperationsInput | RequestReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestInquiryUpdateWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    request?: RequestPostUpdateOneRequiredWithoutRequestInquirysNestedInput
    creator?: CreatorUpdateOneWithoutRequestInquiriesNestedInput
    requestInquiryMessages?: RequestInquiryMessageUpdateManyWithoutRoomNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestInquiryUncheckedUpdateWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    requestId?: BigIntFieldUpdateOperationsInput | bigint | number
    creatorId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    requestInquiryMessages?: RequestInquiryMessageUncheckedUpdateManyWithoutRoomNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestInquiryUncheckedUpdateManyWithoutRequestInquiriesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    requestId?: BigIntFieldUpdateOperationsInput | bigint | number
    creatorId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestInquiryMessageUpdateWithoutFromInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    room?: RequestInquiryUpdateOneRequiredWithoutRequestInquiryMessagesNestedInput
    text?: StringFieldUpdateOperationsInput | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMessageTypeFieldUpdateOperationsInput | MessageType
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestInquiryMessageUncheckedUpdateWithoutFromInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    roomId?: BigIntFieldUpdateOperationsInput | bigint | number
    text?: StringFieldUpdateOperationsInput | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMessageTypeFieldUpdateOperationsInput | MessageType
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestInquiryMessageUncheckedUpdateManyWithoutRequestinquiryMessagesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    roomId?: BigIntFieldUpdateOperationsInput | bigint | number
    text?: StringFieldUpdateOperationsInput | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMessageTypeFieldUpdateOperationsInput | MessageType
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestCommentHeartUpdateWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    requestComment?: RequestCommentUpdateOneRequiredWithoutHeartsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestCommentHeartUncheckedUpdateWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    requestCommentId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestCommentHeartUncheckedUpdateManyWithoutRequestCommentHeartsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    requestCommentId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogUpdateWithoutReceiverInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    logType?: EnumLogTypeFieldUpdateOperationsInput | LogType
    message?: NullableStringFieldUpdateOperationsInput | string | null
    sender?: UserUpdateOneWithoutLogNestedInput
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    request?: RequestPostUpdateOneWithoutLogNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogUncheckedUpdateWithoutReceiverInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    logType?: EnumLogTypeFieldUpdateOperationsInput | LogType
    message?: NullableStringFieldUpdateOperationsInput | string | null
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    requestId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogUncheckedUpdateManyWithoutLogsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    logType?: EnumLogTypeFieldUpdateOperationsInput | LogType
    message?: NullableStringFieldUpdateOperationsInput | string | null
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    requestId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointUpdateWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: IntFieldUpdateOperationsInput | number
    type?: EnumPoinTypeFieldUpdateOperationsInput | PoinType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointUncheckedUpdateWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: IntFieldUpdateOperationsInput | number
    type?: EnumPoinTypeFieldUpdateOperationsInput | PoinType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointUncheckedUpdateManyWithoutPointsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: IntFieldUpdateOperationsInput | number
    type?: EnumPoinTypeFieldUpdateOperationsInput | PoinType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RankingUpdateWithoutUserInput = {
    ranking?: IntFieldUpdateOperationsInput | number
    type?: EnumRankingTypeFieldUpdateOperationsInput | RankingType
    score?: BigIntFieldUpdateOperationsInput | bigint | number
    change?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RankingUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    ranking?: IntFieldUpdateOperationsInput | number
    type?: EnumRankingTypeFieldUpdateOperationsInput | RankingType
    score?: BigIntFieldUpdateOperationsInput | bigint | number
    change?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RankingUncheckedUpdateManyWithoutRankingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    ranking?: IntFieldUpdateOperationsInput | number
    type?: EnumRankingTypeFieldUpdateOperationsInput | RankingType
    score?: BigIntFieldUpdateOperationsInput | bigint | number
    change?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreatorReviewUpdateWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    creator?: CreatorUpdateOneRequiredWithoutCreatorReviewsNestedInput
    reviewItems?: CreatorReviewItemUpdateManyWithoutReviewNestedInput
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreatorReviewUncheckedUpdateWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    creatorId?: BigIntFieldUpdateOperationsInput | bigint | number
    reviewItems?: CreatorReviewItemUncheckedUpdateManyWithoutReviewNestedInput
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreatorReviewUncheckedUpdateManyWithoutCreatorReviewsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    creatorId?: BigIntFieldUpdateOperationsInput | bigint | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogUpdateWithoutSenderInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    logType?: EnumLogTypeFieldUpdateOperationsInput | LogType
    message?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiver?: UserUpdateManyWithoutLogsNestedInput
    request?: RequestPostUpdateOneWithoutLogNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogUncheckedUpdateWithoutSenderInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    logType?: EnumLogTypeFieldUpdateOperationsInput | LogType
    message?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiver?: UserUncheckedUpdateManyWithoutLogsNestedInput
    requestId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogUncheckedUpdateManyWithoutLogInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    logType?: EnumLogTypeFieldUpdateOperationsInput | LogType
    message?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    requestId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestFundingCreateManyRequestInput = {
    id?: bigint | number
    userId?: string | null
    quantity: number
    createdAt?: Date | string
    status?: RequestFundingStatus
  }

  export type RequestReactionCreateManyRequestInput = {
    id?: bigint | number
    userId: string
    type: ReactionType
    createdAt?: Date | string
  }

  export type RequestApplyCreatorCreateManyRequestInput = {
    id?: bigint | number
    creatorId?: bigint | number | null
  }

  export type RequestPlatformCreateManyRequestInput = {
    id?: bigint | number
    name: RequestPlatformType
  }

  export type RequestCommentCreateManyRequestInput = {
    id?: bigint | number
    userId?: string | null
    parentId?: bigint | number | null
    rootId?: bigint | number | null
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequestBookmarkCreateManyRequestInput = {
    id?: bigint | number
    userId: string
    createdAt?: Date | string
  }

  export type RequestReportCreateManyRequestInput = {
    id?: bigint | number
    userId?: string | null
    content: string
    type: RequestReportType
    status: RequestReportStatus
    createdAt?: Date | string
  }

  export type RequestInquiryCreateManyRequestInput = {
    id?: bigint | number
    creatorId?: bigint | number | null
    userId?: string | null
    createdAt?: Date | string
  }

  export type LogCreateManyRequestInput = {
    id?: bigint | number
    logType: LogType
    message?: string | null
    senderId?: string | null
    isRead?: boolean | null
    createdAt?: Date | string
  }

  export type RequestFundingUpdateWithoutRequestInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user?: UserUpdateOneWithoutRequestFundingsNestedInput
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRequestFundingStatusFieldUpdateOperationsInput | RequestFundingStatus
  }

  export type RequestFundingUncheckedUpdateWithoutRequestInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRequestFundingStatusFieldUpdateOperationsInput | RequestFundingStatus
  }

  export type RequestReactionUpdateWithoutRequestInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user?: UserUpdateOneRequiredWithoutRequestReactionsNestedInput
    type?: EnumReactionTypeFieldUpdateOperationsInput | ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestReactionUncheckedUpdateWithoutRequestInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestApplyCreatorUpdateWithoutRequestInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    creator?: CreatorUpdateOneWithoutRequestApplyCreatorsNestedInput
  }

  export type RequestApplyCreatorUncheckedUpdateWithoutRequestInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    creatorId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type RequestApplyCreatorUncheckedUpdateManyWithoutRequestApplyCreatorsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    creatorId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type RequestPlatformUpdateWithoutRequestInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: EnumRequestPlatformTypeFieldUpdateOperationsInput | RequestPlatformType
  }

  export type RequestPlatformUncheckedUpdateWithoutRequestInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: EnumRequestPlatformTypeFieldUpdateOperationsInput | RequestPlatformType
  }

  export type RequestPlatformUncheckedUpdateManyWithoutRequestPlatformsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: EnumRequestPlatformTypeFieldUpdateOperationsInput | RequestPlatformType
  }

  export type RequestCommentUpdateWithoutRequestInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user?: UserUpdateOneWithoutRequestCommentsNestedInput
    parentComment?: RequestCommentUpdateOneWithoutChildrenCommentsNestedInput
    rootId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hearts?: RequestCommentHeartUpdateManyWithoutRequestCommentNestedInput
    childrenComments?: RequestCommentUpdateManyWithoutParentCommentNestedInput
  }

  export type RequestCommentUncheckedUpdateWithoutRequestInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    rootId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hearts?: RequestCommentHeartUncheckedUpdateManyWithoutRequestCommentNestedInput
    childrenComments?: RequestCommentUncheckedUpdateManyWithoutParentCommentNestedInput
  }

  export type RequestBookmarkUpdateWithoutRequestInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user?: UserUpdateOneRequiredWithoutRequestBookmarksNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestBookmarkUncheckedUpdateWithoutRequestInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestReportUpdateWithoutRequestInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user?: UserUpdateOneWithoutRequestReportsNestedInput
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumRequestReportTypeFieldUpdateOperationsInput | RequestReportType
    status?: EnumRequestReportStatusFieldUpdateOperationsInput | RequestReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestReportUncheckedUpdateWithoutRequestInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumRequestReportTypeFieldUpdateOperationsInput | RequestReportType
    status?: EnumRequestReportStatusFieldUpdateOperationsInput | RequestReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestInquiryUpdateWithoutRequestInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    creator?: CreatorUpdateOneWithoutRequestInquiriesNestedInput
    user?: UserUpdateOneWithoutRequestInquiriesNestedInput
    requestInquiryMessages?: RequestInquiryMessageUpdateManyWithoutRoomNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestInquiryUncheckedUpdateWithoutRequestInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    creatorId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    requestInquiryMessages?: RequestInquiryMessageUncheckedUpdateManyWithoutRoomNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestInquiryUncheckedUpdateManyWithoutRequestInquirysInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    creatorId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogUpdateWithoutRequestInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    logType?: EnumLogTypeFieldUpdateOperationsInput | LogType
    message?: NullableStringFieldUpdateOperationsInput | string | null
    sender?: UserUpdateOneWithoutLogNestedInput
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiver?: UserUpdateManyWithoutLogsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogUncheckedUpdateWithoutRequestInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    logType?: EnumLogTypeFieldUpdateOperationsInput | LogType
    message?: NullableStringFieldUpdateOperationsInput | string | null
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receiver?: UserUncheckedUpdateManyWithoutLogsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestCommentHeartCreateManyRequestCommentInput = {
    id?: bigint | number
    userId: string
    createdAt?: Date | string
  }

  export type RequestCommentCreateManyParentCommentInput = {
    id?: bigint | number
    requestId: bigint | number
    userId?: string | null
    rootId?: bigint | number | null
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequestCommentHeartUpdateWithoutRequestCommentInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user?: UserUpdateOneRequiredWithoutRequestCommentHeartsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestCommentHeartUncheckedUpdateWithoutRequestCommentInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestCommentHeartUncheckedUpdateManyWithoutHeartsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestCommentUpdateWithoutParentCommentInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    request?: RequestPostUpdateOneRequiredWithoutRequestCommentsNestedInput
    user?: UserUpdateOneWithoutRequestCommentsNestedInput
    rootId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hearts?: RequestCommentHeartUpdateManyWithoutRequestCommentNestedInput
    childrenComments?: RequestCommentUpdateManyWithoutParentCommentNestedInput
  }

  export type RequestCommentUncheckedUpdateWithoutParentCommentInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    requestId?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    rootId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hearts?: RequestCommentHeartUncheckedUpdateManyWithoutRequestCommentNestedInput
    childrenComments?: RequestCommentUncheckedUpdateManyWithoutParentCommentNestedInput
  }

  export type RequestCommentUncheckedUpdateManyWithoutChildrenCommentsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    requestId?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    rootId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestInquiryMessageCreateManyRoomInput = {
    id?: bigint | number
    fromId: string
    text: string
    fileUrl?: string | null
    type?: MessageType
    isRead?: boolean | null
    createdAt?: Date | string
  }

  export type RequestInquiryMessageUpdateWithoutRoomInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    from?: UserUpdateOneRequiredWithoutRequestinquiryMessagesNestedInput
    text?: StringFieldUpdateOperationsInput | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMessageTypeFieldUpdateOperationsInput | MessageType
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestInquiryMessageUncheckedUpdateWithoutRoomInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    fromId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMessageTypeFieldUpdateOperationsInput | MessageType
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestInquiryMessageUncheckedUpdateManyWithoutRequestInquiryMessagesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    fromId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMessageTypeFieldUpdateOperationsInput | MessageType
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestPostCreateManyCreatorInput = {
    id?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    title: string
    content: string
    category?: RequestCategoryType | null
    expires?: Date | string | null
    totalViews?: number
    status?: RequestStatusType
    solvedUrl?: string | null
    thumbnailUrl?: string | null
    refusalReason?: string | null
    totalQuantity?: number
    totalLikeScroe?: number
    isUnspecified?: boolean
  }

  export type RequestApplyCreatorCreateManyCreatorInput = {
    id?: bigint | number
    requestId: bigint | number
  }

  export type RequestInquiryCreateManyCreatorInput = {
    id?: bigint | number
    requestId: bigint | number
    userId?: string | null
    createdAt?: Date | string
  }

  export type CreatorAuthCreateManyCreatorInput = {
    id?: bigint | number
    isMain?: boolean
    profileUrl?: string | null
    platform: AuthPlatformType
    createdAt?: Date | string
  }

  export type CreatorReviewCreateManyCreatorInput = {
    id?: bigint | number
    userId?: string | null
    content?: string | null
    createdAt?: Date | string
  }

  export type RequestPostUpdateWithoutCreatorInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutRequestPostsNestedInput
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableEnumRequestCategoryTypeFieldUpdateOperationsInput | RequestCategoryType | null
    expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalViews?: IntFieldUpdateOperationsInput | number
    status?: EnumRequestStatusTypeFieldUpdateOperationsInput | RequestStatusType
    solvedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    refusalReason?: NullableStringFieldUpdateOperationsInput | string | null
    totalQuantity?: IntFieldUpdateOperationsInput | number
    totalLikeScroe?: IntFieldUpdateOperationsInput | number
    isUnspecified?: BoolFieldUpdateOperationsInput | boolean
    requestFundings?: RequestFundingUpdateManyWithoutRequestNestedInput
    requestReactions?: RequestReactionUpdateManyWithoutRequestNestedInput
    requestApplyCreators?: RequestApplyCreatorUpdateManyWithoutRequestNestedInput
    requestPlatforms?: RequestPlatformUpdateManyWithoutRequestNestedInput
    requestComments?: RequestCommentUpdateManyWithoutRequestNestedInput
    requestBookmarks?: RequestBookmarkUpdateManyWithoutRequestNestedInput
    requestReports?: RequestReportUpdateManyWithoutRequestNestedInput
    requestInquirys?: RequestInquiryUpdateManyWithoutRequestNestedInput
    Log?: LogUpdateManyWithoutRequestNestedInput
  }

  export type RequestPostUncheckedUpdateWithoutCreatorInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableEnumRequestCategoryTypeFieldUpdateOperationsInput | RequestCategoryType | null
    expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalViews?: IntFieldUpdateOperationsInput | number
    status?: EnumRequestStatusTypeFieldUpdateOperationsInput | RequestStatusType
    solvedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    refusalReason?: NullableStringFieldUpdateOperationsInput | string | null
    totalQuantity?: IntFieldUpdateOperationsInput | number
    totalLikeScroe?: IntFieldUpdateOperationsInput | number
    isUnspecified?: BoolFieldUpdateOperationsInput | boolean
    requestFundings?: RequestFundingUncheckedUpdateManyWithoutRequestNestedInput
    requestReactions?: RequestReactionUncheckedUpdateManyWithoutRequestNestedInput
    requestApplyCreators?: RequestApplyCreatorUncheckedUpdateManyWithoutRequestNestedInput
    requestPlatforms?: RequestPlatformUncheckedUpdateManyWithoutRequestNestedInput
    requestComments?: RequestCommentUncheckedUpdateManyWithoutRequestNestedInput
    requestBookmarks?: RequestBookmarkUncheckedUpdateManyWithoutRequestNestedInput
    requestReports?: RequestReportUncheckedUpdateManyWithoutRequestNestedInput
    requestInquirys?: RequestInquiryUncheckedUpdateManyWithoutRequestNestedInput
    Log?: LogUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type RequestApplyCreatorUpdateWithoutCreatorInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    request?: RequestPostUpdateOneRequiredWithoutRequestApplyCreatorsNestedInput
  }

  export type RequestApplyCreatorUncheckedUpdateWithoutCreatorInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    requestId?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type RequestInquiryUpdateWithoutCreatorInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    request?: RequestPostUpdateOneRequiredWithoutRequestInquirysNestedInput
    user?: UserUpdateOneWithoutRequestInquiriesNestedInput
    requestInquiryMessages?: RequestInquiryMessageUpdateManyWithoutRoomNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestInquiryUncheckedUpdateWithoutCreatorInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    requestId?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    requestInquiryMessages?: RequestInquiryMessageUncheckedUpdateManyWithoutRoomNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreatorAuthUpdateWithoutCreatorInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    isMain?: BoolFieldUpdateOperationsInput | boolean
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: EnumAuthPlatformTypeFieldUpdateOperationsInput | AuthPlatformType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreatorAuthUncheckedUpdateWithoutCreatorInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    isMain?: BoolFieldUpdateOperationsInput | boolean
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: EnumAuthPlatformTypeFieldUpdateOperationsInput | AuthPlatformType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreatorAuthUncheckedUpdateManyWithoutCreatorAuthsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    isMain?: BoolFieldUpdateOperationsInput | boolean
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: EnumAuthPlatformTypeFieldUpdateOperationsInput | AuthPlatformType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreatorReviewUpdateWithoutCreatorInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user?: UserUpdateOneWithoutCreatorReviewsNestedInput
    reviewItems?: CreatorReviewItemUpdateManyWithoutReviewNestedInput
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreatorReviewUncheckedUpdateWithoutCreatorInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewItems?: CreatorReviewItemUncheckedUpdateManyWithoutReviewNestedInput
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreatorReviewItemCreateManyReviewInput = {
    id?: bigint | number
    content: string
    isChecked?: boolean
  }

  export type CreatorReviewItemUpdateWithoutReviewInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    content?: StringFieldUpdateOperationsInput | string
    isChecked?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CreatorReviewItemUncheckedUpdateWithoutReviewInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    content?: StringFieldUpdateOperationsInput | string
    isChecked?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CreatorReviewItemUncheckedUpdateManyWithoutReviewItemsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    content?: StringFieldUpdateOperationsInput | string
    isChecked?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoint?: IntFieldUpdateOperationsInput | number
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    requestPosts?: RequestPostUpdateManyWithoutUserNestedInput
    requestFundings?: RequestFundingUpdateManyWithoutUserNestedInput
    requestComments?: RequestCommentUpdateManyWithoutUserNestedInput
    requestReactions?: RequestReactionUpdateManyWithoutUserNestedInput
    requestBookmarks?: RequestBookmarkUpdateManyWithoutUserNestedInput
    requestReports?: RequestReportUpdateManyWithoutUserNestedInput
    requestInquiries?: RequestInquiryUpdateManyWithoutUserNestedInput
    requestinquiryMessages?: RequestInquiryMessageUpdateManyWithoutFromNestedInput
    requestCommentHearts?: RequestCommentHeartUpdateManyWithoutUserNestedInput
    points?: PointUpdateManyWithoutUserNestedInput
    rankings?: RankingUpdateManyWithoutUserNestedInput
    creatorReviews?: CreatorReviewUpdateManyWithoutUserNestedInput
    creator?: CreatorUpdateOneWithoutUserNestedInput
    Log?: LogUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoint?: IntFieldUpdateOperationsInput | number
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    requestPosts?: RequestPostUncheckedUpdateManyWithoutUserNestedInput
    requestFundings?: RequestFundingUncheckedUpdateManyWithoutUserNestedInput
    requestComments?: RequestCommentUncheckedUpdateManyWithoutUserNestedInput
    requestReactions?: RequestReactionUncheckedUpdateManyWithoutUserNestedInput
    requestBookmarks?: RequestBookmarkUncheckedUpdateManyWithoutUserNestedInput
    requestReports?: RequestReportUncheckedUpdateManyWithoutUserNestedInput
    requestInquiries?: RequestInquiryUncheckedUpdateManyWithoutUserNestedInput
    requestinquiryMessages?: RequestInquiryMessageUncheckedUpdateManyWithoutFromNestedInput
    requestCommentHearts?: RequestCommentHeartUncheckedUpdateManyWithoutUserNestedInput
    points?: PointUncheckedUpdateManyWithoutUserNestedInput
    rankings?: RankingUncheckedUpdateManyWithoutUserNestedInput
    creatorReviews?: CreatorReviewUncheckedUpdateManyWithoutUserNestedInput
    creator?: CreatorUncheckedUpdateOneWithoutUserNestedInput
    Log?: LogUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateManyWithoutReceiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoint?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}